const { Magic } = require('@magic-sdk/admin');
const { Sequelize, DataTypes, where } = require('sequelize');
const { vl, indice, taux, fond, pays_regulateurs, sequelize, urll,urllsite, portefeuille, portefeuille_vl, portefeuilles_proposes_vls, portefeuilles_proposes, users, societe, classementfonds, performences, transaction, investissement, tsr, cashdb, frais, fiscalite, portefeuille_vl_cumul, devises, portefeuille_base100, favorisfonds, devisedechanges, personnel, documentss, performences_eurs, performences_usds, classementfonds_eurs, classementfonds_usds, actu, tsrhisto, rendement, simulation, simulationportefeuille,date_valorisation,apikeys } = require('../db/sequelize')
const moment = require('moment');
const math = require('mathjs');
const csv = require('csv-parser');
const nodemailer = require('nodemailer');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const crypto = require('crypto');
const fs = require('fs');
const cron = require('node-cron');
const _ = require('lodash');
const path = require('path');
const express = require('express');
const app = express();
const multer = require('multer');
const upload = multer({ dest: 'uploads/' }); // Set your upload directory
const PortfolioAnalytics = require('portfolio-analytics');
const ss = require('simple-statistics')
const socktrader = require('@socktrader/indicators');
const quants = require('quants');
const bodyParser = require('body-parser');
const NodeCache = require('node-cache');
const cache = new NodeCache({ stdTTL: 3600 }); // Cache valide pendant 1 heure
const magic = new Magic(process.env.MAGIC_SECRET_KEY);
const Bottleneck = require('bottleneck');
const { fork } = require('child_process');
const exceljs = require('exceljs');
const { PDFDocument, rgb } = require('pdf-lib');
const { Document, Packer, Paragraph, TextRun, ImageRun } = require('docx');
const PizZip = require('pizzip');
const Docxtemplater = require('docxtemplater');
const { Image } = require('docxtemplater');
const puppeteer = require('puppeteer');
const ImageModule = require('docxtemplater-image-module').ImageModule;


var limiter = new Bottleneck({
  minTime: 1000, // 1 request per second
  maxConcurrent: 3 // No more than 5 concurrent requests
});

// Fonction de réessai avec backoff exponentiel
async function retry(fn, retries = 3, delay = 1000) {
  try {
    return await fn();
  } catch (error) {
    if (retries > 1) {
      await new Promise(resolve => setTimeout(resolve, delay));
      return retry(fn, retries - 1, delay * 2);
    } else {
      throw error;
    }
  }
}
// Fonction fetch avec réessai
async function fetchWithRetry(url, options = {}, retries = 3, delay = 1000) {
  return retry(() => fetch(url, options).then(res => {
    if (!res.ok) {
      throw new Error(`Fetch error: ${res.statusText}`);
    }
    return res.json();
  }), retries, delay);
}
//const performanceData = await fetchWithRetry(`${urll}/api/performanceswithdate/fond/${fundId}/${currentDate}`);

//const performanceResponse = await retry(() => axios.get(`${urll}/api/performanceswithdate/fond/${fundId}/${currentDate}`));

async function checkAndUpdateData(filePath, res) {

  let report = [];


  const fileData = await new Promise((resolve, reject) => {
    const results = [];
    fs.createReadStream(filePath)
      .pipe(csv({ separator: ';' })) // Utilisez le séparateur correct pour le fichier CSV
      .on('headers', (headers) => {
        console.log('Headers:', headers); // Affiche les en-têtes pour vérifier leur structure
      })
      .on('data', (row) => results.push(row)) // Corrigez `data` en `row`
      .on('end', () => resolve(results))
      .on('error', (error) => reject(error));
  });

  for (const row of fileData) {
    const existingRow = await vl.findOne({
      where: {
        code_isin: row.code,
        date: row.date
      }
    });

    if (existingRow) {
      if (existingRow.value === parseFloat(row.value) && existingRow.actif_net === parseFloat(row.actif_net)) {
        report.push({
          date: row.date,
          code: row.code,
          value_db: existingRow.value,
          value_file: parseFloat(row.value),
          vlb_ddifferent_vl_file: 'Equal',
          actif_net_db: existingRow.actif_net,
          actif_net_file: parseFloat(row.actif_net),
          actif_net_different: 'Equal'
        });
      } else if (existingRow.value === parseFloat(row.value) || existingRow.actif_net !== parseFloat(row.actif_net)) {
        /* await existingRow.update({
           value: parseFloat(row.value),
           actif_net: parseFloat(row.actif_net)
         });*/
        report.push({
          date: row.date,
          code: row.code,
          value_db: existingRow.value,
          value_file: parseFloat(row.value),
          vlb_ddifferent_vl_file: 'Equal',
          actif_net_db: existingRow.actif_net,
          actif_net_file: parseFloat(row.actif_net),
          actif_net_different: 'Dif'
        });
      } else if (existingRow.value !== parseFloat(row.value) || existingRow.actif_net === parseFloat(row.actif_net)) {

        report.push({
          date: row.date,
          code: row.code,
          value_db: existingRow.value,
          value_file: parseFloat(row.value),
          vlb_ddifferent_vl_file: 'Dif',
          actif_net_db: existingRow.actif_net,
          actif_net_file: parseFloat(row.actif_net),
          actif_net_different: 'Equal'
        });
      }
    } else {
      /* await vl.create({
         fund_id: row.fund_id,
         date: row.date,
         value: parseFloat(row.value),
         actif_net: parseFloat(row.actif_net)
       });*/
      report.push({
        date: row.date,
        code: row.code,
        value_db: null,
        value_file: parseFloat(row.value),
        vlb_ddifferent_vl_file: 'New Entry',
        actif_net_db: null,
        actif_net_file: parseFloat(row.actif_net),
        actif_net_different: 'New Entry'
      });
    }
  }
  // Générer le fichier Excel à partir du rapport
  const workbook = new exceljs.Workbook();
  const worksheet = workbook.addWorksheet('Report');

  // Ajouter les en-têtes
  worksheet.columns = [
    { header: 'Date', key: 'date', width: 15 },
    { header: 'Code', key: 'code', width: 15 },
    { header: 'Value DB', key: 'value_db', width: 15 },
    { header: 'Value File', key: 'value_file', width: 15 },
    { header: 'Value Different', key: 'vlb_ddifferent_vl_file', width: 20 },
    { header: 'Actif Net DB', key: 'actif_net_db', width: 15 },
    { header: 'Actif Net File', key: 'actif_net_file', width: 15 },
    { header: 'Actif Net Different', key: 'actif_net_different', width: 20 },
  ];

  // Ajouter les données
  report.forEach(row => {
    worksheet.addRow(row);
  });


  res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  res.setHeader('Content-Disposition', 'attachment; filename=rapport.xlsx');

  await workbook.xlsx.write(res);
  res.end();

}

async function insertfondfile(filePath) {
  const fileData = await new Promise((resolve, reject) => {
    const results = [];
    fs.createReadStream(filePath)
      .pipe(csv({ separator: ';' })) // Utilisez le séparateur correct pour le fichier CSV
      .on('headers', (headers) => {
        console.log('Headers:', headers); // Affiche les en-têtes pour vérifier leur structure
      })
      .on('data', (row) => results.push(row)) // Corrigez `data` en `row`
      .on('end', () => resolve(results))
      .on('error', (error) => reject(error));
  });

  const report = [];

  for (const row of fileData) {
    const existingRow = await fond.findOne({
      where: {
        code_ISIN: row.code_ISIN
      }
    });

    if (existingRow) {
      await existingRow.update({
        code: row.code ? row.code : existingRow.code,
        nom_fond: row.nom_fond ? row.nom_fond : existingRow.nom_fond,
        structure_fond: row.structure_fond ? row.structure_fond : existingRow.structure_fond,
        societe_gestion: row.societe_gestion ? row.societe_gestion : existingRow.societe_gestion,
        categorie_libelle: row.categorie_libelle ? row.categorie_libelle : existingRow.categorie_libelle,
        sensibilite: row.sensibilite ? row.sensibilite : existingRow.sensibilite,
        indice_benchmark: row.indice_benchmark ? row.indice_benchmark : existingRow.indice_benchmark,
        periodicite: row.periodicite ? row.periodicite : existingRow.periodicite,
        type_investissement: row.type_investissement ? row.type_investissement : existingRow.type_investissement,
        affectation: row.affectation ? row.affectation : existingRow.affectation,
        frais_rachat: row.frais_rachat ? row.frais_rachat : existingRow.frais_rachat,
        frais_souscription: row.frais_souscription ? row.frais_souscription : existingRow.frais_souscription,
        frais_gestion: row.frais_gestion ? row.frais_gestion : existingRow.frais_gestion,
        depositaire: row.depositaire ? row.depositaire : existingRow.depositaire,
        reseau_placeur: row.reseau_placeur ? row.reseau_placeur : existingRow.reseau_placeur,
        structure_fond:row.structure_fond?row.structure_fond:existingRow.structure_fond,
        pays: "Maroc"
      });

      report.push({ action: 'updated', code_ISIN: row.code_ISIN });
    } else {
      await fond.create({
        code: row.code ? row.code : null,
        code_ISIN: row.code_ISIN ? row.code_ISIN : null,
        nom_fond: row.nom_fond ? row.nom_fond : null,
        structure_fond: row.structure_fond ? row.structure_fond : null,
        societe_gestion: row.societe_gestion ? row.societe_gestion : null,
        categorie_libelle: row.categorie_libelle ? row.categorie_libelle : null,
        sensibilite: row.sensibilite ? row.sensibilite : null,
        indice_benchmark: row.indice_benchmark ? row.indice_benchmark : null,
        periodicite: row.periodicite ? row.periodicite : null,
        type_investissement: row.type_investissement ? row.type_investissement : null,
        affectation: row.affectation ? row.affectation : null,
        frais_rachat: row.frais_rachat ? row.frais_rachat : null,
        frais_souscription: row.frais_souscription ? row.frais_souscription : null,
        frais_gestion: row.frais_gestion ? row.frais_gestion : null,
        depositaire: row.depositaire ? row.depositaire : null,
        reseau_placeur: row.reseau_placeur ? row.reseau_placeur : null,
        structure_fond:row.structure_fond?row.structure_fond:null,
        pays: "Maroc"
      });

      report.push({ action: 'created', code_ISIN: row.code_ISIN });
    }
  }

  fs.writeFileSync('report.json', JSON.stringify(report, null, 2));
}


// Fonction pour écrire dans un fichier de journal
function writeToLogFile(message) {
  fs.appendFile('logs.txt', message + '\n', (err) => {
    if (err) {
      console.error("Erreur lors de l'écriture dans le fichier de journal :", err);
    } else {
      console.log("Message de journal écrit avec succès dans le fichier de journal.");
    }
  });
}
//todo upCaptureRatio
const {
  AdaptTableaumonthwithdate,
  findNearestDateAnnualized,
  findLastDateOfPreviousMonth,
  findNearestDate,
  findNearestDateWeek,
  findNearestDateJanuary,
  findNearestDatetoyear,
  findLastDatesForEachPreviousYear,
  groupDatesByWeek,
  groupDatesByMonth,
  groupDatesByMonth1,
  groupDatesByYear,
  adaptValuesToGroupedWeeks,
  adaptValuesToGroupedYears,
  adaptValuesToGroupedMonths,
  AdaptTableauwithdate,
  AdaptTableauweekwithdate,
  findNearestDateMonthlized,
  findNearestDatemois
} = require('../functions/dates')

const { calculatePerformance, calculateAnnualizedPerformance, calculateAnnualizedPerformanceper100 } = require('../functions/performances')
/*const {
  calculateVolatility,
  calculateDSR,
  calculateSharpeRatio,
  calculateVAR95,
  calculateTrackingError,
  calculateVolatilityJour,
  calculateVolatilityMois,
  calculateVAR99,
  calculateSortinoRatio,
  calculateInformationRationew,
  calculateDSRnew,
  calculateDownCaptureRatio,
  calculateUpCaptureRatio,
  calculateMaxDrawdown,
  calculateDownsideBeta,
  calculateOmegaRatio,
  calculateCalmarRatio,
  calculateSortinoRationew,
  calculateVariance,
  calculateCovariance,
  calculateBetanew,
} = require('../functions/ratios')*/

const {
  calculateVolatility,
  calculateDSR,
  calculateSharpeRatio,
  calculateVAR95,
  calculateTrackingError,
  calculateVolatilityJour,
  calculateVolatilityMois,
  calculateVAR99,
  calculateInformationRatio,
  calculateSortinoRatio,
  calculateInformationRationew,
  calculateDSRnew,
  //calculateBetanew,
  calculateDownCaptureRatio,
  calculateUpCaptureRatio,
  calculateMaxDrawdown,
  calculateDownsideBeta,
  calculateHaussierBeta,
  calculateOmegaRatio,
  calculateCalmarRatio,
  calculerCAGR,
  calculateSortinoRationew,
  calculateVariance,
  calculateCovariance,
  calculateBetanew,
  calculateInformationRatiojour,
  calculerR2,
  calculerSkewness,
  calculateKurtosis,
  calculerDelaiRecouvrementOPCVM,
  calculerDelaiRecouvrementFonds,
  calculerDSRAnnualise
} = require('../functions/newratios')


const { CalculateRendHebdo, CalculateRendMensuel, CalculateRendJournalier, calculerRendements,
  grouperParAnnee,
  grouperParMois,
  grouperParSemaine,
  grouperTauxParSemaine,
  grouperParJour } = require('../functions/utils')

const {
  calculerDelaiRecouvrement,
  calculerUpCaptureRatio,
  calculerDownCaptureRatio,
  calculateBeta,
  calculateBetaHaussier,

  calculateBetaBaissier
} = require('../functions/delai_Beta_capture')
const { Fond } = require('../classes/fond')
const { Indice } = require('../classes/indice')
const { Op } = require("sequelize");
const { fastifySwaggerUi } = require("@fastify/swagger-ui");
const { da } = require('date-fns/locale');
const portefeuille_valorise = require('../models/portefeuille_valorise');
const { exit } = require('process');
const { url } = require('inspector');
const apikey = require('../models/apikey');
//const xlsx = require('xlsx');

//TAUX SANS RISQUE -0.0116
//TAUX ACCEPTABLE 0
/**
 * Middleware pour la gestion des routes liées à l'application.
 *
 * @param {Object} app - Instance de l'application Fastify.
 */
module.exports = (app) => {
  /**
  * Middleware pour autoriser toutes les origines (pour le développement).
  *
  * @param {Object} req - Objet de requête.
  * @param {Object} res - Objet de réponse.
  * @param {Function} next - Fonction pour passer à la suite.
  */
  // Autoriser toutes les origines (pour le développement)
  app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Headers', 'Origin,Authorization, X-Requested-With, Content-Type, Accept');
    next();
  });
  const storage = multer.diskStorage({
    destination: function (req, file, cb) {
      cb(null, 'uploads/');
    },
    filename: function (req, file, cb) {
      cb(null, Date.now() + '-' + file.originalname);
    }
  });
  const upload = multer({ storage: storage });
  //PERSONNELS SOCIETE DE GESTION

  function getDateToday() {
    const today = new Date();
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0'); // Ajoute un zéro devant si nécessaire
    const day = String(today.getDate()).padStart(2, '0'); // Ajoute un zéro devant si nécessaire

    // Concatène l'année, le mois et le jour avec des tirets pour obtenir le format "yyyy-mm-dd"
    const formattedDate = `${year}-${month}-${day}`;

    return formattedDate;
  }
  const parentPath1 = path.resolve(__dirname, '..');
  const parentPath = path.resolve(parentPath1, '..');
  const uploadDirectory = path.join(parentPath, 'uploads');
  const uploadDirectory1 = path.join(parentPath, 'fichiers');

  const magic = new Magic("sk_live_D5E6305B1B7DCF1A");

  app.get('/api/fill-template', async (req, res) => {
    try {
      // Vérifier si le fichier PDF existe
      if (!fs.existsSync("fichiers/template.pdf")) {
        return res.status(404).json({ error: 'Le fichier PDF n\'existe pas.' });
      }

      const users = await societe.findAll();

      // Charger le template PDF
      const existingPdfBytes = fs.readFileSync("fichiers/template.pdf");

      // Créer un nouveau document PDF à partir du template
      const pdfDoc = await PDFDocument.load(existingPdfBytes);

      const pages = pdfDoc.getPages();
      const firstPage = pages[0];

      // Remplir le template avec les données
      let yOffset = 700;
      users.forEach(user => {
        firstPage.drawText(`Name: ${user.nom}, Email: ${user.email}`, {  // Correction du champ email
          x: 50,
          y: yOffset,
          size: 12,
          color: rgb(0, 0, 0),
        });
        yOffset -= 20;
      });

      const pdfBytes = await pdfDoc.save();

      // Envoyer le PDF généré au client
      res.setHeader('Content-Disposition', 'attachment; filename="filled_template.pdf"');
      res.setHeader('Content-Type', 'application/pdf');
      res.send(pdfBytes);
    } catch (error) {
      console.error('Erreur lors du traitement du template PDF :', error);
      res.status(500).json({ error: 'Erreur lors du traitement du template PDF.' });
    }
  });

  app.post('/api/reset-password', async (req, res) => {
    const { tokenapp, newPassword } = req.body;
  
    try {
      // Vérifier le jeton
      const decoded = jwt.verify(tokenapp, process.env.JWT_SECRET);
      const user = await users.findOne({ where: { id: decoded.userId } });
  
      if (!user) {
        return res.status(404).send('Utilisateur non trouvé');
      }
  
      // Hacher le nouveau mot de passe
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      user.password = hashedPassword;
      await user.save();
  
      res.status(200).send('Mot de passe réinitialisé avec succès');
    } catch (error) {
      res.status(400).send('Jeton invalide ou expiré');
    }
  });

  process.env.JWT_SECRET = '88a865b9da673c6900322f74fb865b6abc76feb2b140d4d44d5bec3739a74bda57b9a626998c1def77a61ac4ca8b7be9b74b4fe5a65bbaf4e51701a467332f7';
  process.env.EMAIL_USER = 'kouassijauressigl@gmail.com';
  process.env.EMAIL_PASSWORD = 'itrn onhe lavz pxpn';
  process.env.FRONTEND_URL = urllsite;
  app.post('/api/forgot-password', async (req, res) => {
    const { email } = req.body;
  
    // Vérifiez si l'utilisateur existe
    const user = await users.findOne({ where: { email: email }  });
    if (!user) {
      return res.status(404).send('Utilisateur non trouvé');
    }
  
    // Créer un jeton de réinitialisation
    const resetToken = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, { expiresIn: '1h' });
  
    // Lien de réinitialisation
    const resetUrl = `${process.env.FRONTEND_URL}/societegestionpanel/login/reset-password?token=${resetToken}`;
  
    // Configurer nodemailer pour envoyer l'email
    const transporter = nodemailer.createTransport({
      service: 'Gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASSWORD,
      },
    });
  
    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: email,
      subject: 'Réinitialisation de mot de passe',
      html: `<p>Cliquez sur ce lien pour réinitialiser votre mot de passe :</p>
             <a href="${resetUrl}">Réinitialiser le mot de passe</a>`,
    };
  
    try {
      await transporter.sendMail(mailOptions);
      res.status(200).send('Email de réinitialisation envoyé');
    } catch (error) {
      res.status(500).send('Erreur lors de l\'envoi de l\'email');
    }
  });

  app.get('/api/telechargerword', async (req, res) => {
    try {
      // Charger les données des utilisateurs
      const user = await societe.findOne();

      // Charger le fichier template Word
      const content = fs.readFileSync('fichiers/template.docx');
      const zip = new PizZip(content);

      // Capture screenshots of the specific tables using Puppeteer
      const urls = [
        'https://funds.chainsolutions.fr/fundview/historique/1114',
        'https://funds.chainsolutions.fr/fundview/historique/1115',
        'https://funds.chainsolutions.fr/fundview/historique/1116'
      ];
      const screenshotPaths = [];
      const browser = await puppeteer.launch({ headless: true });

      for (let i = 0; i < urls.length; i++) {
        const page = await browser.newPage();
        await page.setViewport({ width: 1920, height: 1080 });
        await page.goto(urls[i]);

        // Attendre que la table contienne des lignes
        await page.waitForFunction(() => {
          const table = document.querySelector('#tabPerfGlissante');
          return table && table.querySelectorAll('tbody tr').length > 0;
        });

        // Scroll to the bottom of the table to ensure all rows are loaded
        await page.evaluate(() => {
          const table = document.querySelector('#tabPerfGlissante');
          table.scrollIntoView();
        });

        // Capture the entire table
        const table = await page.$('#tabPerfGlissante');
        const screenshotBuffer = await table.screenshot();

        // Sauvegarder l'image temporairement
        const screenshotPath = path.resolve(`fichiers/screenshot${i + 1}.png`);
        fs.writeFileSync(screenshotPath, screenshotBuffer);
        screenshotPaths.push(screenshotPath);

        await page.close();
      }
      await browser.close();

      // Préparer les données à insérer dans le template
      const data = {
        nom: user.nom,
        email: user.email,
        performances: [
          { date: '2022-01-01', performance: 0.5 },
          { date: '2022-02-01', performance: 0.6 },
          { date: '2022-03-01', performance: 0.7 }
        ],
        // Ajouter des placeholders pour les images dynamiques
        image1: 'fichiers/screenshot1.png',
        image2: 'fichiers/screenshot2.png',
        image3: 'fichiers/screenshot3.png'
      };

      // Manipuler le fichier DOCX pour ajouter les images
      const doc = new Docxtemplater(zip, {
        paragraphLoop: true,
        linebreaks: true
      });

      // Remplir le template avec les données
      doc.setData(data);
      doc.render();

      let buf = doc.getZip().generate({ type: 'nodebuffer' });

      // Ajouter les images dynamiques aux placeholders
      const zipWithImages = new PizZip(buf);

      // Liste des placeholders d'images dynamiques
      const imagePlaceholders = ['image1', 'image2', 'image3'];
      const files = zipWithImages.filter((relativePath) => relativePath.startsWith('word/media/'));

      // Remplacer les placeholders d'images dynamiques
      imagePlaceholders.forEach((placeholder, index) => {
        const filePath = data[placeholder];
        if (filePath && fs.existsSync(filePath)) {
          const imageFile = fs.readFileSync(filePath);
          // Ajouter ou remplacer uniquement les images dynamiques
          zipWithImages.file(`word/media/image${index + 1}.png`, imageFile);
        }
      });
      /*screenshotPaths.forEach((filePath, index) => {
        const imageFile = fs.readFileSync(filePath);
        // La clé doit correspondre aux placeholders dynamiques dans le template
        zipWithImages.file(`word/media/image${index + 1}.png`, imageFile);
      });*/

      // Créez un nouveau Docxtemplater avec les images ajoutées
      const updatedDoc = new Docxtemplater(zipWithImages);
      const finalBuf = updatedDoc.getZip().generate({ type: 'nodebuffer' });

      // Envoyer le fichier Word généré au client
      res.setHeader('Content-Disposition', 'attachment; filename="filled_template.docx"');
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
      res.send(finalBuf);

      // Supprimer les images temporaires
      screenshotPaths.forEach(filePath => fs.unlinkSync(filePath));
    } catch (error) {
      console.error('Erreur lors du traitement du template Word :', error);
      res.status(500).json({ error: 'Erreur lors du traitement du template Word.' });
    }
  });
// Fonction pour parcourir les fonds avec "dividende" à "oui" et mettre à jour les VL en fonction du cumul des dividendes.
app.get('/api/updatewithdividende', async (req, res) => {
  try {
    // Récupérer tous les fonds où "dividende" est défini à "oui"
    const fondsAvecDividende = await fond.findAll({
      where: { affectation: "Distribuant" },
      include: [{
        model: vl,
        order: [['date', 'ASC']] // Assurez-vous que les VL sont triées par date croissante
      }]
    });

    // Parcourir chaque fonds et mettre à jour la table VL en tenant compte du cumul des dividendes
    for (const fonds of fondsAvecDividende) {
      const vlRecords = fonds.valorisations; // Obtenir les VL associés au fonds
      let totalDividende = 0; // Initialiser le cumul des dividendes à zéro

      // Parcourir chaque VL du fonds, trié par date croissante
      for (const vl of vlRecords) {
        // Remplacer null par 0 pour éviter les erreurs de calcul
        const valeur = vl.valeur || 0;
        const dividende = vl.dividende || 0;
        const valeurEUR = vl.valeur_EUR || 0;
        const dividendeEUR = vl.dividende_EUR || 0;
        const valeurUSD = vl.valeur_USD || 0;
        const dividendeUSD = vl.dividende_USD || 0;

        // Ajouter le dividende courant au cumul total si un dividende est présent
        if (dividende > 0 ) {
          totalDividende += dividende; // Ajouter le dividende courant au cumul total
        }
        if(dividendeEUR > 0 ){
          totalDividende += dividendeEUR;// Ajouter le dividende courant au cumul total
        }
        if(dividendeUSD > 0 ){
          totalDividende += dividendeUSD;// Ajouter le dividende courant au cumul total
        }

        // Calculer les nouvelles valeurs en ajoutant le cumul des dividendes aux valeurs existantes
        const newValue = valeur + totalDividende;
        const newValueEUR = valeurEUR + totalDividende;
        const newValueUSD = valeurUSD + totalDividende;

        // Mettre à jour la table VL avec la nouvelle valeur cumulative
        await vl.update({ vl_ajuste: newValue, vl_ajuste_EUR: newValueEUR, vl_ajuste_USD: newValueUSD }, { where: { id: vl.id } });
      }
    }

    return res.status(200).json({ message: 'Mise à jour des VL avec cumul des dividendes réussie.' });
  } catch (error) {
    console.error('Erreur lors de la mise à jour des VL avec dividendes:', error);
    return res.status(500).json({ message: 'Erreur lors de la mise à jour des VL avec cumul des dividendes.' });
  }
});


  app.post('/api/reportingmensuelle', async (req, res) => {
    try {
      const { selectedOptions1, managerComments, selectedMonth, selectedYear } = req.body;

      // Charger les données des utilisateurs
      const user = await societe.findOne();

      // Charger le fichier template Word
      const content = fs.readFileSync('fichiers/template.docx');
      const zip = new PizZip(content);

      // Capture screenshots of the specific tables using Puppeteer
      const urls = [
        'https://funds.chainsolutions.fr/fundview/historique/1114',
        'https://funds.chainsolutions.fr/fundview/historique/1115',
        'https://funds.chainsolutions.fr/fundview/historique/1116'
      ];
      const screenshotPaths = [];
      const browser = await puppeteer.launch({ headless: true });

      for (let i = 0; i < urls.length; i++) {
        const page = await browser.newPage();
        await page.setViewport({ width: 1920, height: 1080 });
        await page.goto(urls[i]);

        // Attendre que la table contienne des lignes
        await page.waitForFunction(() => {
          const table = document.querySelector('#tabPerfGlissante');
          return table && table.querySelectorAll('tbody tr').length > 0;
        });

        // Scroll to the bottom of the table to ensure all rows are loaded
        await page.evaluate(() => {
          const table = document.querySelector('#tabPerfGlissante');
          table.scrollIntoView();
        });

        // Capture the entire table
        const table = await page.$('#tabPerfGlissante');
        const screenshotBuffer = await table.screenshot();

        // Sauvegarder l'image temporairement
        const screenshotPath = path.resolve(`fichiers/screenshot${i + 1}.png`);
        fs.writeFileSync(screenshotPath, screenshotBuffer);
        screenshotPaths.push(screenshotPath);

        await page.close();
      }
      await browser.close();

      // Préparer les données à insérer dans le template
      const data = {
        nom: user.nom,
        email: user.email,
        performances: [
          { date: '2022-01-01', performance: 0.5 },
          { date: '2022-02-01', performance: 0.6 },
          { date: '2022-03-01', performance: 0.7 }
        ],
        // Ajouter des placeholders pour les images dynamiques
        image1: 'fichiers/screenshot1.png',
        image2: 'fichiers/screenshot2.png',
        image3: 'fichiers/screenshot3.png'
      };

      // Manipuler le fichier DOCX pour ajouter les images
      const doc = new Docxtemplater(zip, {
        paragraphLoop: true,
        linebreaks: true
      });

      // Remplir le template avec les données
      doc.setData(data);
      doc.render();

      let buf = doc.getZip().generate({ type: 'nodebuffer' });

      // Ajouter les images dynamiques aux placeholders
      const zipWithImages = new PizZip(buf);

      // Liste des placeholders d'images dynamiques
      const imagePlaceholders = ['image1', 'image2', 'image3'];
      const files = zipWithImages.filter((relativePath) => relativePath.startsWith('word/media/'));

      // Remplacer les placeholders d'images dynamiques
      imagePlaceholders.forEach((placeholder, index) => {
        const filePath = data[placeholder];
        if (filePath && fs.existsSync(filePath)) {
          const imageFile = fs.readFileSync(filePath);
          // Ajouter ou remplacer uniquement les images dynamiques
          zipWithImages.file(`word/media/image${index + 1}.png`, imageFile);
        }
      });
      /*screenshotPaths.forEach((filePath, index) => {
        const imageFile = fs.readFileSync(filePath);
        // La clé doit correspondre aux placeholders dynamiques dans le template
        zipWithImages.file(`word/media/image${index + 1}.png`, imageFile);
      });*/

      // Créez un nouveau Docxtemplater avec les images ajoutées
      const updatedDoc = new Docxtemplater(zipWithImages);
      const finalBuf = updatedDoc.getZip().generate({ type: 'nodebuffer' });

      // Envoyer le fichier Word généré au client
      res.setHeader('Content-Disposition', 'attachment; filename="filled_template.docx"');
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
      res.send(finalBuf);

      // Supprimer les images temporaires
      screenshotPaths.forEach(filePath => fs.unlinkSync(filePath));
    } catch (error) {
      console.error('Erreur lors du traitement du template Word :', error);
      res.status(500).json({ error: 'Erreur lors du traitement du template Word.' });
    }
  });


  app.get('/api/fetch-currency-pairs', async (req, res) => {
    try {
      const apikey = "92f2058ef24f7fcdd129c260";
      const url = `https://v6.exchangerate-api.com/v6/${apikey}/latest/USD`;

      const response = await fetch(url);

      const data = await response.json();

      const pairs = Object.keys(data.conversion_rates).map(pair => ({
        paire: `USD/${pair}`,
        value: data.conversion_rates[pair],
        date: new Date()
      }));

      await devisedechanges.bulkCreate(pairs);

      res.status(200).json({ message: 'Les paires de devises ont été récupérées et enregistrées avec succès.' });
    } catch (error) {
      res.status(500).json({ error: 'Erreur lors de la récupération des paires de devises.' });
    }
  });

  app.get('/api/generate-excel-report', async (req, res) => {
    try {
      const societegestion = req.query.societegestion;

      // Appel des API pour obtenir les fonds avec anomalies
      const highVolatilityFundsVLManquante = await performences.findAll({
        attributes: ['fond_id'],
        where: { anomalie: 'VL MANQUANTE' },
        raw: true
      });

      /*  const highVolatilityFundsAutreAnomalie = await performences.findAll({
          attributes: ['fond_id'],
          where: {
            [Op.or]: [
              { volatility3an: { [Op.gt]: 50 } },
              { volatility1an: { [Op.gt]: 50 } },
              { volatility5an: { [Op.gt]: 50 } },
              { pertemax1an: { [Op.lt]: -50 } },
              { pertemax3an: { [Op.lt]: -50 } },
              { pertemax5an: { [Op.lt]: -50 } }
            ],
          },
          raw: true
        });*/

      const combinedData = [
        ...highVolatilityFundsVLManquante.map(fund => ({ id: fund.fond_id, anomalie: 'VL MANQUANTE' })),
        //  ...highVolatilityFundsAutreAnomalie.map(fund => ({ id: fund.fond_id, anomalie: 'ANOMALIE VL' }))
      ];

      const highVolatilityFundsData = [];

      for (const data of combinedData) {
        let fundData;
        if (societegestion) {
          fundData = await fond.findOne({ where: { id: data.id, societe_gestion: societegestion } });
        } else {
          fundData = await fond.findOne({ where: { id: data.id } });
        }
        if (fundData) {
          highVolatilityFundsData.push(fundData);
        }
      }

      const dataWithAnomalyType = [];
      const seenCombinations = new Set();
      const allMissingDates = new Set();

      for (const fund of highVolatilityFundsData) {
        const id = fund.id;
        const correspondingData = combinedData.filter(data => data.id === id);

        for (const data of correspondingData) {
          const combinationKey = `${fund.id}-${data.anomalie}`;

          if (!seenCombinations.has(combinationKey)) {
            seenCombinations.add(combinationKey);

            if (data.anomalie === 'VL MANQUANTE') {
              const missingDates = await getMissingDates(fund.id);
              //    missingDates.forEach(date => allMissingDates.add(date));

              dataWithAnomalyType.push({
                ...fund.toJSON(),
                type_anomalie: data.anomalie,
                anomalies: missingDates
              });
            }/* else {
              const anomalies = await getVLAnomalies(fund.id);
              dataWithAnomalyType.push({
                ...fund.toJSON(),
                type_anomalie: data.anomalie,
                anomalies: anomalies
              });
            }*/
          }
        }
      }
      // const uniqueMissingDates = Array.from(allMissingDates).sort();


      // Générer le rapport Excel
      const workbook = new exceljs.Workbook();
      const worksheet = workbook.addWorksheet('Anomalies Fonds');

      worksheet.columns = [
        { header: 'ID Fonds', key: 'id', width: 15 },
        { header: 'Nom Fonds', key: 'nom_fond', width: 30 },
        { header: 'Code ISIN', key: 'code_ISIN', width: 20 },
        { header: 'Type d\'Anomalie', key: 'periodicite', width: 20 },
        { header: 'Type d\'Anomalie', key: 'type_anomalie', width: 20 },
        { header: 'missing_date', key: 'missing_date', width: 50 }
      ];
      const datesWorksheet = workbook.addWorksheet('Dates Uniques');
      datesWorksheet.columns = [
        { header: 'Date', key: 'date', width: 15 }
      ];

      dataWithAnomalyType.forEach(fund => {
        fund.anomalies.forEach(date => {
          worksheet.addRow({
            id: fund.id,
            nom_fond: fund.nom_fond,
            code_ISIN: fund.code_ISIN,
            periodicite: fund.periodicite,
            type_anomalie: fund.type_anomalie,
            missing_date: date
          });
        });
      });

      /*  uniqueMissingDates.forEach(date => {
          datesWorksheet.addRow({ date });
        });*/

      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      res.setHeader('Content-Disposition', 'attachment; filename=rapport_anomalies.xlsx');

      await workbook.xlsx.write(res);
      res.end();
    } catch (error) {
      console.error('Error:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  });

  // Fonction pour obtenir les dates manquantes
  async function getMissingDates(fundId) {
    const fund = await fond.findOne({ where: { id: fundId } });
    const periodicite = fund.periodicite;
    const firstVlDate = await vl.min('date', {
      where: {
        fund_id: fundId,/* date: {
          [Sequelize.Op.lt]: "2024-03-31" // Utilise createdAt ou tout autre attribut de date
        },*/
      }
    });
    const increment = periodicite === 'Journaliere' ? 'days' : 'weeks';
    const missingDates = [];

    /* for (let date = moment(firstVlDate); date.isBefore(moment()); date.add(1, increment)) {
       if (isWeekend(date)) {
         continue;
       }
 
       const vlExists = await vl.findOne({ where: { fund_id: fundId, date: date.format('YYYY-MM-DD') } });
 
       if (!vlExists) {
         missingDates.push(date.format('YYYY-MM-DD'));
       }
     }*/
    if (periodicite === 'Journaliere') {
      for (let date = moment(firstVlDate); date.isBefore(moment()); date.add(1, increment)) {
        if (isWeekend(date)) {
          continue;
        }

        const vlExists = await vl.findOne({ where: { fund_id: fundId, date: date.format('YYYY-MM-DD') } });

        if (!vlExists) {
          missingDates.push(date.format('YYYY-MM-DD'));
        }
      }
    } else if (periodicite === 'Hebdomadaire') {
      for (let date = moment(firstVlDate); date.isBefore(moment()); date.add(1, increment)) {
        /* if (isWeekend(date)) {
           continue;
         }*/
        const startOfWeek = date.clone().startOf('isoWeek');
        const endOfWeek = date.clone().endOf('isoWeek');

        const weeklyVlDates = await vl.findAll({
          where: {
            fund_id: fundId,
            date: {
              [Sequelize.Op.between]: [startOfWeek.format('YYYY-MM-DD'), endOfWeek.format('YYYY-MM-DD')]
            }
          }
        });

        if (weeklyVlDates.length === 0) {
          missingDates.push({ week: startOfWeek.format('YYYY-MM-DD'), status: 'manquant' });
        } else if (weeklyVlDates.length > 1) {
          missingDates.push({ week: startOfWeek.format('YYYY-MM-DD'), status: 'double date' });
        }
      }
    }

    return missingDates;
  }

  // Fonction pour obtenir les anomalies VL
  async function getVLAnomalies(fundId) {
    const valorisations = await vl.findAll({
      where: { fund_id: fundId },
      order: [['date', 'ASC']]
    });

    const anomalies = [];

    for (let i = 1; i < valorisations.length - 1; i++) {
      const currentValue = valorisations[i].value;
      const prevValue = valorisations[i - 1].value;
      const nextValue = valorisations[i + 1].value;
      const dateprev = valorisations[i - 1].date;
      const datenext = valorisations[i + 1].date;
      const date = valorisations[i].date;

      if (prevValue <= currentValue * 0.9) {
        anomalies.push({
          now: currentValue,
          after: prevValue,
          nowdate: date,
          afterdate: dateprev
        });
      }
    }

    return anomalies;
  }

  app.get('/api/verifvlimport', async (req, res) => {
    try {
      checkAndUpdateData('fichiers/vl2.csv', res)
        .then(() => console.log('Data check and update completed.'))
        .catch((error) => console.error('Error during data check and update:', error));
    } catch (error) {
      console.error(error);
      res.status(500).send('Internal server error.');
    }
  });

  app.get('/api/insertfond', async (req, res) => {
    try {
      insertfondfile('fichiers/Updatefondsmaroc.csv')
        .then(() => console.log('Data check and update completed.'))
        .catch((error) => console.error('Error during data check and update:', error));
    } catch (error) {
      console.error(error);
      res.status(500).send('Internal server error.');
    }
  });

  //Taux sans risque
  app.get('/api/tsr/:year', async (req, res) => {
    // Récupérer la dernière valeur du mois précédent
    const lastValue = await tsrhisto.findOne({
      where: {
        date: {
          [Op.lt]: new Date(new Date().setDate(0))  // Dernier jour du mois précédent
        },
        annee: req.params.year
      },
      order: [['date', 'DESC']]
    });

    if (!lastValue) {
      throw new Error('No data found for the last month.');
    }

    const endDate = lastValue.date;
    const startDate = new Date(endDate);
    startDate.setFullYear(startDate.getFullYear() - 10);

    // Récupérer les valeurs sur les 10 dernières années
    const values = await tsrhisto.findAll({
      where: {
        date: {
          [Op.between]: [startDate, endDate]
        }, annee: req.params.year
      },
      order: [['date', 'ASC']]
    });
    const valueArray = values.map(record => record.value);
    const annualYield = math.mean(valueArray)
    //  const annualYield = calculateAnnualYield(valueArray);
    console.log(`Le taux sans risque à ${req.params.year} ans est de ${annualYield.toFixed(2)}%`);
    console.log(`Le taux sans risque à ${req.params.year} ans est de ${annualYield.toFixed(2)}%`);

  });

  app.get('/update-indRef/:idDebu/:idFin', async (req, res) => {
    try {
      const idDebu = req.params.idDebu;
      const idFin = req.params.idFin;

      const whereClause = {
        indRef: null
      };

      if (idDebu && idFin) {
        whereClause.fund_id = {
          [Sequelize.Op.between]: [idDebu, idFin]
        };
      }

      const valorisations = await vl.findAll({
        where: whereClause,
        order: [['id', 'ASC']]
      });

      for (let i = 0; i < valorisations.length; i++) {
        const currentValue = valorisations[i];
        const previousValue = await vl.findOne({
          where: {
            date: {
              [Sequelize.Op.lt]: currentValue.date // Utilise createdAt ou tout autre attribut de date
            },
            fund_id: currentValue.fund_id,
            indRef: {
              [Sequelize.Op.ne]: null
            }
          },
          order: [['date', 'DESC']]
        });

        if (previousValue) {
          await currentValue.update({ indRef: previousValue.indRef });
        }
      }

      res.status(200).send('Mise à jour terminée.');
    } catch (error) {
      console.error('Erreur lors de la mise à jour :', error);
      res.status(500).send('Erreur lors de la mise à jour.');
    }
  });
  app.get('/api/login', async (req, res) => {
    try {
      const didToken = req.headers.authorization?.substr(7);
      if (!didToken) {
        return res.status(401).json({ error: 'Missing authorization token' });
      }

      await magic.token.validate(didToken);
      res.status(200).json({ authenticated: true });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  const cors = require('cors');
  app.use(cors({
    origin: urllsite, // Remplacez par l'URL de votre frontend
  }));
  app.use('/fichiers', express.static(uploadDirectory1));
 

  app.post('/api/contact', async (req, res) => {
  const { name, email, description } = req.body;

  let transporter = nodemailer.createTransport({
    service: 'Gmail',
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASSWORD,
    },
  });

  let mailOptions = {
    from: email,
    to: process.env.EMAIL_USER,
    subject: `Nouveau message de ${name}`,
    text: description,
  };

  try {
    await transporter.sendMail(mailOptions);
    res.status(200).json({ success: true, message: 'Email envoyé avec succès' });
  } catch (error) {
    console.error('Erreur lors de l\'envoi de l\'email:', error);
    res.status(500).json({ success: false, message: 'Erreur lors de l\'envoi de l\'email' });
  }
});

// Route dynamique pour servir des fichiers
app.get('/:pays/:societe/:opcvm/:nomfichier/:id', async (req, res) => {
  const { id } = req.params;
  const document = await documentss.findOne({
    where: {
      id: id
    }
  });

  if (!document) {
    return res.status(404).json({ error: 'Le document n\'existe pas.' });
  }


  const filePath = path.resolve(__dirname, '../..', document.nom); // Utiliser path.resolve pour obtenir un chemin absolu

  res.sendFile(filePath, (err) => {
    if (err) {
      console.error('Erreur lors de l\'envoi du fichier:', err);
      res.status(err.status).end();
    }
  });
});
  // Définir une route statique pour servir les fichiers depuis le dossier upload
  app.get('/api/upload', async (req, res) => {
    const parentPath1 = path.resolve(__dirname, '..');
    const parentPath = path.resolve(parentPath1, '..');
    const uploadDirectory = path.join(parentPath, 'uploads');

    const path = uploadDirectory;
    // express.static(uploadDirectory); 
    res.status(200).json({ message: 'Document créé avec succès', path: uploadDirectory });

  });
  const dateToday = getDateToday();
  console.log(dateToday);
  // const upload = multer({ storage: storage });

  function constructNomFond({ date, mois, annee, objet, typedoc, fond_name }) {
    // Créer un tableau pour stocker les parties du nom du fond
    let parts = [];

    // Ajouter les parties existantes
    if (date) parts.push(date);
    if (mois) parts.push(mois);
    if (annee) parts.push(annee);
    if (objet) parts.push(objet);
    if (typedoc) parts.push(typedoc);
    if (fond_name) parts.push(fond_name);


    // Si le tableau est vide, retourner une chaîne vide
    if (parts.length === 0) return '';

    // Joindre les parties avec des underscores
    return parts.join('_');
  }
  app.get('/api/usersWithFunds', async (req, res) => {
    const query = `
   SELECT u.nom, u.prenoms, f.societe_gestion, GROUP_CONCAT(f.nom_fond SEPARATOR ', ') AS fonds_favoris
FROM users u
INNER JOIN favorisfonds fa ON u.id = fa.user_id
INNER JOIN fond_investissements f ON fa.fund_id = f.id
GROUP BY f.societe_gestion;
  `;
    try {
      const usersWithFunds = await sequelize.query(query, { type: sequelize.QueryTypes.SELECT });
      res.status(200).json(usersWithFunds);
    } catch (error) {
      console.error(error);
      res.status(500).json({ message: 'Erreur du serveur' });
    }
  });
  // API endpoint for uploading article
  app.post('/api/actualite', upload.single('fichier'), async (req, res) => {
    try {
      const { description, date, type, user_id, username } = req.body;
      const image = req.file;
      const user = await users.findOne({ where: { denomination: user_id } });
      const nouveauDocument = await actu.create({
        date: dateToday,
        user_id: user.id,
        username: username,
        description,
        type,
        image: image.filename
      });

      res.status(200).json({ message: 'Article uploaded successfully', document: nouveauDocument });
    } catch (error) {
      console.error(error);
      res.status(500).json({ message: 'Server Error' });
    }
  });
  app.get('/api/getactualite', async (req, res) => {
    try {
      // Récupérer toutes les actualités de la base de données
      const actualites = await actu.findAll({
        order: [['id', 'DESC']] // Triez par ordre décroissant sur la colonne 'id'
      });
      // Envoyer les actualités en tant que réponse
      res.status(200).json(actualites);
    } catch (error) {
      console.error(error);
      // Si une erreur survient, envoyer une réponse d'erreur au client
      res.status(500).json({ message: 'Erreur du serveur' });
    }
  });
  app.post('/api/doc', upload.single('fichier'), async (req, res) => {
    try {
      const { fond_id, date, objet, mois, annee, typedoc, societe } = req.body;
      const fichier = req.file; // Le fichier est accessible via req.file
      const dateToday = getDateToday();
      const dernierePartieFondId = fond_id.split(' ').pop();

      const existingfond = await fond.findOne({ where: { code_isin: dernierePartieFondId } });
      const fond_name = existingfond.nom_fond;
      const nomfile = fichier.filename;
      const nom = constructNomFond({ date, mois, annee, objet, typedoc, fond_name })+ path.extname(nomfile);

      
      // Créer le chemin du dossier
      const dossierPath = `documents/${existingfond.pays}/${societe}/${fond_name}/`;

      // Assurez-vous que le dossier existe (vous devrez peut-être utiliser fs pour créer le dossier)
      fs.mkdirSync(dossierPath, { recursive: true });
      // Déplacer le fichier vers le nouveau chemin
      const oldPath = fichier.path; // Chemin temporaire
      const newPath = path.join(dossierPath, nom);
      
      fs.renameSync(oldPath, newPath); // Déplacer le fichier

      const nouveauDocument = await documentss.create({
        date: date ? date : dateToday,
        nom: newPath,
        fond: fond_name,
        fond_id:existingfond.id,
        mois,
        annee,
        objet,
        type_fichier: typedoc,
        societe,
        fichier: nom
      });



      res.status(200).json({ message: 'Document créé avec succès', document: nouveauDocument });
    } catch (error) {
      console.error('Erreur lors de la création du document :', error);
      res.status(500).json({ message: 'Erreur lors de la création du document' });
    }
  });
  app.get('/api/documents/:societe', async (req, res) => {
    const { societe } = req.params;
    const query = `
    SELECT *
    FROM documents
    WHERE societe = :societe
  `;

    try {
      const documents = await sequelize.query(query, {
        replacements: { societe },
        type: sequelize.QueryTypes.SELECT,
      });

      // Retournez la liste des documents
      res.status(200).json(documents);
    } catch (error) {
      console.error('Erreur lors de la récupération des documents:', error);
      res.status(500).json({ message: 'Erreur lors de la récupération des documents' });
    }
  });

  app.get('/api/documentsfond/:fond', async (req, res) => {
    const { fond } = req.params; // Modifier de societe à fond
    const fondId = parseInt(fond); // Convertir fond en entier, si nécessaire
    const query = `
    SELECT *
    FROM documents
    WHERE fond_id = :fondId
  `;

    try {
      const documents = await sequelize.query(query, {
        replacements: { fondId },
        type: sequelize.QueryTypes.SELECT,
      });

      // Retournez la liste des documents
      res.status(200).json(documents);
    } catch (error) {
      console.error('Erreur lors de la récupération des documents:', error);
      res.status(500).json({ message: 'Erreur lors de la récupération des documents' });
    }
  });



  app.post('/api/personnelsociete', upload.single('photo'), async (req, res) => {
    try {
      const selectedValues = req.query.query;
      let valuesArray = [];
      if (selectedValues) {
        valuesArray = selectedValues.split(',');
      }

      const { nom, prenom, email, numero, fonction, societe, activite, photo } = req.body;

      if (valuesArray.length >= 1 && valuesArray[0] !== '') {
        const formattedValues = valuesArray.map(value => `'${value}'`).join(',');

        const query = `
             UPDATE fond_investissements
             SET nom_gerant = :nom
             WHERE id IN (${formattedValues})
           `;

        const fondsDansCategorie = await sequelize.query(query, {
          replacements: { nom },
          type: sequelize.QueryTypes.UPDATE
        });
      }

      const fonc = fonction.toString();
      const activiteString = JSON.stringify(activite);
      let photos = null; // Initialisation de la variable photo à null

      // Vérifie si une photo a été téléchargée
      if (req.file) {
        photos = req.file.filename; // Utilisation du nom de fichier pour la photo
      }
      /* const parentPath1 = path.resolve(__dirname, '..');
       const parentPath = path.resolve(parentPath1, '..');
 
 
       const destinationPath = path.join(parentPath, 'uploads'); // Changer 'uploads' par votre dossier de destination*/
      /*
            const newPath = path.join(destinationPath, photos.filename);
            await fs.promises.rename(photos.path, newPath);*/
      // Créer un nouveau document dans la base de données
      const newPersonnel = await personnel.create({
        nom,
        prenom,
        email,
        numero,
        societe,
        photo: photos,
        fonction: fonc,
        activite: activiteString
        //activite: JSON.parse(activite) // Parsez la chaîne JSON pour obtenir un tableau d'activités
      });

      res.status(200).json(newPersonnel);
    } catch (error) {
      res.status(500).json({ error: 'Erreur lors de la création de la personne.' });
    }
  });

  app.get('/api/personnel/:societe', async (req, res) => {
    const { societe } = req.params;
    const query = `
    SELECT *
    FROM 	personnel_sgs
    WHERE societe = :societe
  `;

    try {
      const documents = await sequelize.query(query, {
        replacements: { societe },
        type: sequelize.QueryTypes.SELECT,
      });

      // Retournez la liste des documents
      res.status(200).json(documents);
    } catch (error) {
      console.error('Erreur lors de la récupération des documents:', error);
      res.status(500).json({ message: 'Erreur lors de la récupération des documents' });
    }
  });
  app.get('/api/personnelsocietecharge/:id', async (req, res) => {
    try {
      const id = req.params.id;

      // Recherchez le personnel dans la base de données en fonction de son ID
      const existingPersonnel = await personnel.findOne({ where: { id } });

      if (!existingPersonnel) {
        return res.status(404).json({ error: "Personnel not found" });
      }

      // Envoyez les données du personnel trouvé
      res.status(200).json(existingPersonnel);
    } catch (error) {
      console.error("Error fetching personnel:", error);
      res.status(500).json({ error: 'An error occurred while fetching personnel data.' });
    }
  });
  // Route pour mettre à jour une personne
  app.post('/api/personnelsocietemodif', upload.single('photo'), async (req, res) => {
    try {
      const selectedValues = req.query.query;
      let valuesArray = [];
      if (selectedValues) {
        valuesArray = selectedValues.split(',');
      }

      const { id, nom, prenom, email, numero, fonction, activite, photo } = req.body;

      if (valuesArray.length >= 1 && valuesArray[0] !== '') {
        const formattedValues = valuesArray.map(value => `'${value}'`).join(',');

        const query = `
        UPDATE fond_investissements
        SET nom_gerant = :nom
        WHERE id IN (${formattedValues})
      `;

        const fondsDansCategorie = await sequelize.query(query, {
          replacements: { nom },
          type: sequelize.QueryTypes.UPDATE
        });
      }

      const fonc = fonction.toString();
      const activiteString = JSON.stringify(activite);
      let photos = null;

      // Vérifie si une nouvelle photo a été téléchargée
      if (req.file) {
        photos = req.file.filename;
      }

      // Obtenez le personnel existant à mettre à jour
      const existingPersonnel = await personnel.findOne({ where: { id: parseInt(id) } });

      if (!existingPersonnel) {
        return res.status(404).json({ error: "Personnel not found" });
      }

      // Mettez à jour les données existantes avec les nouvelles données
      existingPersonnel.nom = nom;
      existingPersonnel.prenom = prenom;
      existingPersonnel.email = email;
      existingPersonnel.numero = numero;
      existingPersonnel.fonction = fonc;
      existingPersonnel.activite = activiteString;

      if (photos) {
        existingPersonnel.photo = photos;
      }

      await existingPersonnel.save();

      res.status(200).json(existingPersonnel);
    } catch (error) {
      console.error("Error updating personnel:", error);
      res.status(500).json({ error: 'An error occurred while updating personnel.' });
    }
  });



  /**
  * Fonction asynchrone pour calculer le classement d'un fond dans une catégorie spécifique.
  *
  * @param {string} category - Catégorie du fond.
  * @param {number} fundId - ID du fond.
  * @returns {Object} - Résultat du calcul du classement.
  */
  async function calculateRank(category, fundId, datedebut) {
    try {
      const selectedFundId = fundId;
      const selectedFundCategory = category;
      const fundsWithPerformance = await sequelize.query(`
      SELECT 
        p1.fond_id, 
        p1.perfveille, 

        p1.perf3m, 
        p1.perf6m, 
        p1.perf1an, 
        p1.perf3ans, 
        p1.perf5ans, 
        p1.ytd,
        p1.perfveillem, 

        p1.perf3mm, 
        p1.perf6mm, 
        p1.perf1anm, 
        p1.perf3ansm, 
        p1.perf5ansm, 
        p1.ytdm,
        p1.volatility3an,
        p1.ratiosharpe3an,
        p1.pertemax3an,
        p1.sortino3an,
        p1.info3an,
        p1.calamar3an,
        p1.var953an,
        p1.betabaissier3an,
        p1.sortino3an,
        p1.omega3an,
        p1.dsr3an
        
      FROM performences p1
      
        WHERE date= :datedebut  and  categorie_nationale = :selectedFundCategory

        GROUP BY fond_id
   
    `, {
        replacements: { selectedFundCategory, datedebut },
        type: sequelize.QueryTypes.SELECT,
      });

      // Étape 2 : Trouver les performances du fond sélectionné
      const selectedFund = fundsWithPerformance.find((fund) => fund.fond_id === selectedFundId);

      if (!selectedFund) {
        return { error: 'Fond non trouvé.' };
      }

      // Étape 3 : Calculer les rangs pour chaque période de performance
      const calculateRankForPeriod = (period) => {
        // Filtrer les performances non valides pour le champ spécifique
        const validPerformances = fundsWithPerformance.filter((fund) =>
          fund[period] != null && fund[period] != "-"
        );

        // Si toutes les performances pour ce champ sont invalides, retourner null
        if (validPerformances.length === 0) {
          return null;
        }
        const rantotal = validPerformances.length;
        // Sinon, effectuer le classement
        // Vérifier si le champ est 'pertemax3an' pour déterminer l'ordre du tri
        if (period === 'pertemax3an' || period === "calamar3an") {
          // Pour 'pertemax3an', les valeurs plus proches de zéro sont meilleures
          validPerformances.sort((a, b) => a[period] - b[period]);
        } else {
          // Pour les autres champs, les valeurs plus élevées sont meilleures
          validPerformances.sort((a, b) => b[period] - a[period]);
        }
        const rank = validPerformances.findIndex((fund) => fund.fond_id === selectedFundId) + 1;
        return [rank, rantotal];
      };
      const rankveille = calculateRankForPeriod('perfveille');
      const rank3Mois = calculateRankForPeriod('perf3m');
      const rank6Mois = calculateRankForPeriod('perf6m');
      const rank1An = calculateRankForPeriod('perf1an');
      const rank3Ans = calculateRankForPeriod('perf3ans');
      const rank5Ans = calculateRankForPeriod('perf5ans');
      const rank1erJanvier = calculateRankForPeriod('ytd');
      const rankveillem = calculateRankForPeriod('perfveillem');
      const rank3Moism = calculateRankForPeriod('perf3mm');
      const rank6Moism = calculateRankForPeriod('perf6mm');
      const rank1Anm = calculateRankForPeriod('perf1anm');
      const rank3Ansm = calculateRankForPeriod('perf3ansm');
      const rank5Ansm = calculateRankForPeriod('perf5ansm');
      const rank1erJanvierm = calculateRankForPeriod('ytdm');
      const rankvolatilite = calculateRankForPeriod('volatility3an');
      const ranksharpe = calculateRankForPeriod('ratiosharpe3an');
      const rankdsr = calculateRankForPeriod('dsr3an');
      const rankomega = calculateRankForPeriod('omega3an');
      const ranksortino = calculateRankForPeriod('sortino3an');
      const rankbetabaissier = calculateRankForPeriod('betabaissier3an');
      const rankvar95 = calculateRankForPeriod('var953an');
      const rankcalamar = calculateRankForPeriod('calamar3an');
      const rankinfo = calculateRankForPeriod('info3an');
      const rankpertemax = calculateRankForPeriod('pertemax3an');

      // Étape 4 : Envoyer la réponse JSON
      return {
        code: 200,
        data: {
          rank3Mois: rank3Mois[0],
          rank6Mois: rank6Mois[0],
          rank1An: rank1An[0],
          rank3Ans: rank3Ans[0],
          rank5Ans: rank5Ans[0],
          rank1erJanvier: rank1erJanvier[0],
          rank3Moistotal: rank3Mois[1],
          rank6Moistotal: rank6Mois[1],
          rank1Antotal: rank1An[1],
          rank3Anstotal: rank3Ans[1],
          rank5Anstotal: rank5Ans[1],
          rank1erJanviertotal: rank1erJanvier[1],
          rank3Moism: rank3Moism[0],
          rank6Moism: rank6Moism[0],
          rank1Anm: rank1Anm[0],
          rank3Ansm: rank3Ansm[0],
          rank5Ansm: rank5Ansm[0],
          rank1erJanvierm: rank1erJanvierm[0],
          rank3Moistotalm: rank3Moism[1],
          rank6Moistotalm: rank6Moism[1],
          rank1Antotalm: rank1Anm[1],
          rank3Anstotalm: rank3Ansm[1],
          rank5Anstotalm: rank5Ansm[1],
          rank1erJanviertotalm: rank1erJanvierm[1],
          rankvolatilite: rankvolatilite[0],
          ranksharpe: ranksharpe[0],
          rankdsr: rankdsr[0],
          rankomega: rankomega[0],
          ranksortino: ranksortino[0],
          rankbetabaissier: rankbetabaissier[0],
          rankvar95: rankvar95[0],
          rankcalamar: rankcalamar[0],
          rankinfo: rankinfo[0],
          rankpertemax: rankpertemax[0],
          rankvolatilitetotal: rankvolatilite[1],
          ranksharpetotal: ranksharpe[1],
          rankdsrtotal: rankdsr[1],
          rankomegatotal: rankomega[1],
          ranksortinototal: ranksortino[1],
          rankbetabaissiertotal: rankbetabaissier[1],
          rankvar95total: rankvar95[1],
          rankcalamartotal: rankcalamar[1],
          rankinfototal: rankinfo[1],
          rankpertemaxtotal: rankpertemax[1],
          ranktotal: fundsWithPerformance.length,
          category: selectedFundCategory,
        },
      };
    } catch (error) {
      console.error('Erreur lors de la récupération des données :', error);
      return { error: 'Erreur lors de la récupération des données.' };
    }
  }

  async function calculateRankdev(category, fundId, devise) {
    try {
      const selectedFundId = fundId;
      const selectedFundCategory = category;
      let fundsWithPerformance;

      if (devise == "EUR") {
        // Étape 1 : Récupérer toutes les performances pour la catégorie spécifiée
        fundsWithPerformance = await performences_eurs.findAll({
          where: { categorie_nationale: selectedFundCategory },
          attributes: ['fond_id', 'perf3m', 'perf6m', 'perf1an', 'perf3ans', 'perf5ans', 'ytd'],
          order: [['fond_id', 'DESC']], // Choisissez la colonne de tri et l'ordre en fonction de vos besoins
        });
      } else {
        // Étape 1 : Récupérer toutes les performances pour la catégorie spécifiée
        fundsWithPerformance = await performences_usds.findAll({
          where: { categorie_nationale: selectedFundCategory },
          attributes: ['fond_id', 'perf3m', 'perf6m', 'perf1an', 'perf3ans', 'perf5ans', 'ytd'],
          order: [['fond_id', 'DESC']], // Choisissez la colonne de tri et l'ordre en fonction de vos besoins
        });
      }
      // Étape 2 : Trouver les performances du fond sélectionné
      const selectedFund = fundsWithPerformance.find((fund) => fund.fond_id === selectedFundId);

      if (!selectedFund) {
        return { error: 'Fond non trouvé.' };
      }

      // Étape 3 : Calculer les rangs pour chaque période de performance
      const calculateRankForPeriod = (period) => {
        // Filtrer les performances non valides pour le champ spécifique
        const validPerformances = fundsWithPerformance.filter((fund) =>
          fund[period] !== null && fund[period] != "-"
        );

        // Si toutes les performances pour ce champ sont invalides, retourner null
        if (validPerformances.length === 0) {
          return null;
        }
        const rantotal = validPerformances.length;
        // Sinon, effectuer le classement
        validPerformances.sort((a, b) => b[period] - a[period]);
        const rank = validPerformances.findIndex((fund) => fund.fond_id === selectedFundId) + 1;
        return [rank, rantotal];
      };

      const rank3Mois = calculateRankForPeriod('perf3m');
      const rank6Mois = calculateRankForPeriod('perf6m');
      const rank1An = calculateRankForPeriod('perf1an');
      const rank3Ans = calculateRankForPeriod('perf3ans');
      const rank5Ans = calculateRankForPeriod('perf5ans');
      const rank1erJanvier = calculateRankForPeriod('ytd');


      // Étape 4 : Envoyer la réponse JSON
      return {
        code: 200,
        data: {
          rank3Mois: rank3Mois[0],
          rank6Mois: rank6Mois[0],
          rank1An: rank1An[0],
          rank3Ans: rank3Ans[0],
          rank5Ans: rank5Ans[0],
          rank1erJanvier: rank1erJanvier[0],
          rank3Moistotal: rank3Mois[1],
          rank6Moistotal: rank6Mois[1],
          rank1Antotal: rank1An[1],
          rank3Anstotal: rank3Ans[1],
          rank5Anstotal: rank5Ans[1],
          rank1erJanviertotal: rank1erJanvier[1],
          ranktotal: fundsWithPerformance.length,
          category: selectedFundCategory,
        },
      };
    } catch (error) {
      console.error('Erreur lors de la récupération des données :', error);
      return { error: 'Erreur lors de la récupération des données.' };
    }
  }

  /**
  * Fonction asynchrone pour calculer le classement d'un fond dans une catégorie régionale spécifique.
  *
  * @param {string} category - Catégorie régionale du fond.
  * @param {number} fundId - ID du fond.
  * @returns {Object} - Résultat du calcul du classement régional.
  */
  async function calculateRankregional(category, fundId, datedebut) {
    try {
      const selectedFundId = fundId;
      const selectedFundCategory = category;

      const fundsWithPerformance = await sequelize.query(`
       SELECT 
        p1.fond_id, 
        p1.perf3m, 
        p1.perf6m, 
        p1.perf1an, 
        p1.perf3ans, 
        p1.perf5ans, 
        p1.ytd
      FROM performences p1
      
        WHERE date= :datedebut  and  categorie_regionale = :selectedFundCategory

        GROUP BY fond_id
    `, {
        replacements: { selectedFundCategory, datedebut },
        type: sequelize.QueryTypes.SELECT,
      });

      // Étape 2 : Trouver les performances du fond sélectionné
      const selectedFund = fundsWithPerformance.find((fund) => fund.fond_id === selectedFundId);

      if (!selectedFund) {
        return { error: 'Fond non trouvé.' };
      }

      // Étape 3 : Calculer les rangs pour chaque période de performance
      const calculateRankForPeriod = (period) => {
        // Filtrer les performances non valides pour le champ spécifique
        const validPerformances = fundsWithPerformance.filter((fund) =>
          fund[period] !== null && fund[period] != "-"
        );

        // Si toutes les performances pour ce champ sont invalides, retourner null
        if (validPerformances.length === 0) {
          return null;
        }
        const rantotal = validPerformances.length;
        // Sinon, effectuer le classement
        validPerformances.sort((a, b) => b[period] - a[period]);
        const rank = validPerformances.findIndex((fund) => fund.fond_id === selectedFundId) + 1;
        return [rank, rantotal];
      };

      const rank3Mois = calculateRankForPeriod('perf3m');
      const rank6Mois = calculateRankForPeriod('perf6m');
      const rank1An = calculateRankForPeriod('perf1an');
      const rank3Ans = calculateRankForPeriod('perf3ans');
      const rank5Ans = calculateRankForPeriod('perf5ans');
      const rank1erJanvier = calculateRankForPeriod('ytd');


      // Étape 4 : Envoyer la réponse JSON
      return {
        code: 200,
        data: {
          rank3Mois: rank3Mois[0],
          rank6Mois: rank6Mois[0],
          rank1An: rank1An[0],
          rank3Ans: rank3Ans[0],
          rank5Ans: rank5Ans[0],
          rank1erJanvier: rank1erJanvier[0],
          rank3Moistotal: rank3Mois[1],
          rank6Moistotal: rank6Mois[1],
          rank1Antotal: rank1An[1],
          rank3Anstotal: rank3Ans[1],
          rank5Anstotal: rank5Ans[1],
          rank1erJanviertotal: rank1erJanvier[1],
          ranktotal: fundsWithPerformance.length,
          category: selectedFundCategory,
        },
      };
    } catch (error) {
      console.error('Erreur lors de la récupération des données :', error);
      return { error: 'Erreur lors de la récupération des données.' };
    }
  }

  async function calculateRankregionaldev(category, fundId, devise) {
    try {
      const selectedFundId = fundId;
      const selectedFundCategory = category;
      let fundsWithPerformance;

      if (devise == "EUR") {
        // Étape 1 : Récupérer toutes les performances pour la catégorie spécifiée
        fundsWithPerformance = await performences_eurs.findAll({
          where: { categorie_regionale: selectedFundCategory },
          attributes: ['fond_id', 'perf3m', 'perf6m', 'perf1an', 'perf3ans', 'perf5ans', 'ytd'],
          order: [['fond_id', 'DESC']], // Choisissez la colonne de tri et l'ordre en fonction de vos besoins
        });
      } else {
        // Étape 1 : Récupérer toutes les performances pour la catégorie spécifiée
        fundsWithPerformance = await performences_usds.findAll({
          where: { categorie_nationale: selectedFundCategory },
          attributes: ['fond_id', 'perf3m', 'perf6m', 'perf1an', 'perf3ans', 'perf5ans', 'ytd'],
          order: [['fond_id', 'DESC']], // Choisissez la colonne de tri et l'ordre en fonction de vos besoins
        });
      }


      // Étape 2 : Trouver les performances du fond sélectionné
      const selectedFund = fundsWithPerformance.find((fund) => fund.fond_id === selectedFundId);

      if (!selectedFund) {
        return { error: 'Fond non trouvé.' };
      }

      // Étape 3 : Calculer les rangs pour chaque période de performance
      const calculateRankForPeriod = (period) => {
        // Filtrer les performances non valides pour le champ spécifique
        const validPerformances = fundsWithPerformance.filter((fund) =>
          fund[period] !== null && fund[period] != "-"
        );

        // Si toutes les performances pour ce champ sont invalides, retourner null
        if (validPerformances.length === 0) {
          return null;
        }
        const rantotal = validPerformances.length;
        // Sinon, effectuer le classement
        validPerformances.sort((a, b) => b[period] - a[period]);
        const rank = validPerformances.findIndex((fund) => fund.fond_id === selectedFundId) + 1;
        return [rank, rantotal];
      };

      const rank3Mois = calculateRankForPeriod('perf3m');
      const rank6Mois = calculateRankForPeriod('perf6m');
      const rank1An = calculateRankForPeriod('perf1an');
      const rank3Ans = calculateRankForPeriod('perf3ans');
      const rank5Ans = calculateRankForPeriod('perf5ans');
      const rank1erJanvier = calculateRankForPeriod('ytd');


      // Étape 4 : Envoyer la réponse JSON
      return {
        code: 200,
        data: {
          rank3Mois: rank3Mois[0],
          rank6Mois: rank6Mois[0],
          rank1An: rank1An[0],
          rank3Ans: rank3Ans[0],
          rank5Ans: rank5Ans[0],
          rank1erJanvier: rank1erJanvier[0],
          rank3Moistotal: rank3Mois[1],
          rank6Moistotal: rank6Mois[1],
          rank1Antotal: rank1An[1],
          rank3Anstotal: rank3Ans[1],
          rank5Anstotal: rank5Ans[1],
          rank1erJanviertotal: rank1erJanvier[1],
          ranktotal: fundsWithPerformance.length,
          category: selectedFundCategory,
        },
      };
    } catch (error) {
      console.error('Erreur lors de la récupération des données :', error);
      return { error: 'Erreur lors de la récupération des données.' };
    }
  }


  // Fonction pour obtenir la liste des fonds dans une catégorie donnée
  async function fetchFundsByCategory(category) {
    try {
      const query = `
    SELECT f.*
    FROM fond_investissements AS f
    WHERE  f.categorie_national = :category and f.id IN (SELECT v.fund_id FROM valorisations AS v )
  `;

      const fondsDansCategorie = await sequelize.query(query, {
        replacements: { category: category },
        type: sequelize.QueryTypes.SELECT,
      });

      // Retournez la liste des fonds
      return fondsDansCategorie;
    } catch (erreur) {
      console.error('Erreur lors de la récupération des fonds par catégorie :', erreur);
      throw erreur; // Propagez l'erreur pour qu'elle soit gérée ailleurs si nécessaire
    }
  }


  app.get('/api/classementquartile/:id', async (req, res) => {
    try {
      const fundId = req.params.id;

      // Assuming classementfond has a field called 'type' to distinguish between type 1 and type 2
      const classementType1 = await classementfonds.findOne({
        where: {
          fond_id: fundId,
          type_classement: 1,
        },
      });

      const classementType2 = await classementfonds.findOne({
        where: {
          fond_id: fundId,
          type_classement: 2,
        },
      });



      // Assuming you want to send both classements in the response
      res.json({
        code: 200, data: {
          classementType1: classementType1 ? classementType1.toJSON() : {},
          classementType2: classementType2 ? classementType2.toJSON() : {},
        },

      });
    } catch (error) {
      console.error('Erreur lors de la recherche du classement :', error);
      res.status(500).json({ error: 'Une erreur est survenue lors de la recherche du classement.' });
    }
  });

  app.get('/api/classementquartiledev/:id/:dev', async (req, res) => {
    try {
      const fundId = req.params.id;
      const devise = req.params.dev;
      let classementType1, classementType2;
      // Assuming classementfond has a field called 'type' to distinguish between type 1 and type 2
      if (devise == "EUR") {
        classementType1 = await classementfonds_eurs.findOne({
          where: {
            fond_id: fundId,
            type_classement: 1,
          },
        });

        classementType2 = await classementfonds_eurs.findOne({
          where: {
            fond_id: fundId,
            type_classement: 2,
          },
        });
      } else {
        classementType1 = await classementfonds_usds.findOne({
          where: {
            fond_id: fundId,
            type_classement: 1,
          },
        });

        classementType2 = await classementfonds_usds.findOne({
          where: {
            fond_id: fundId,
            type_classement: 2,
          },
        });
      }


      if (!classementType1 || !classementType2) {
        return res.status(404).json({ error: 'Classement not found for the specified fund ID.' });
      }

      // Assuming you want to send both classements in the response
      res.json({
        code: 200, data: {
          classementType1: classementType1.toJSON(),
          classementType2: classementType2.toJSON(),
        }

      });
    } catch (error) {
      console.error('Erreur lors de la recherche du classement :', error);
      res.status(500).json({ error: 'Une erreur est survenue lors de la recherche du classement.' });
    }
  });


  async function executeGetclassementAPI() {
    app.get('/api/classement', async (req, res) => {
      try {
        await classementfonds.destroy({

          truncate: true
        });
        const allFunds = await fetchFundsByValorisation([], 'undefined', 'undefined', 'undefined', '');
        for (const fund of allFunds) {
          const fundId = fund.id;
          const category = fund.categorie_national;
          const categorie_regionale = fund.categorie_regional;
          const categorie_libelle = fund.categorie_libelle;

          // Vérifiez si le fond existe dans la table classementfond
          const existingRanking = await classementfonds.findOne({
            where: { fond_id: fundId, type_classement: 1 },
          });

          const existingRankingregional = await classementfonds.findOne({
            where: { fond_id: fundId, type_classement: 2 },
          });

          // Calculez le classement en fonction de la catégorie
          const rankingData = await calculateRank(category, fundId);
          const rankingDataregional = await calculateRankregional(categorie_regionale, fundId);


          if (existingRanking) {
            // Le fond existe, mettez à jour son classement en fonction de la catégorie
            existingRanking.rank3Mois = rankingData.data.rank3Mois;
            existingRanking.rank6Mois = rankingData.data.rank6Mois;
            existingRanking.rank1An = rankingData.data.rank1An;
            existingRanking.rank3Ans = rankingData.data.rank3Ans;
            existingRanking.rank5Ans = rankingData.data.rank5Ans;
            existingRanking.rank1erJanvier = rankingData.data.rank1erJanvier;
            existingRanking.rank1erJanvier = rankingData.data.rank1erJanvier;
            existingRanking.rank3Moistotal = rankingData.data.rank3Moistotal;
            existingRanking.rank6Moistotal = rankingData.data.rank6Moistotal;
            existingRanking.rank1Antotal = rankingData.data.rank1Antotal;
            existingRanking.rank3Anstotal = rankingData.data.rank3Anstotal;
            existingRanking.rank5Anstotal = rankingData.data.rank5Anstotal;
            existingRanking.rank1erJanviertotal = rankingData.data.rank1erJanviertotal;
            existingRanking.type_classement = 1;
            await existingRanking.save();
          } else {
            // Le fond n'existe pas, créez une nouvelle entrée dans la table classementfond
            if (rankingData.code == 200)
              await classementfonds.create({
                fond_id: fundId,
                categorie_nationale: category,
                type_classement: 1,
                categorie_regionale: categorie_regionale,
                categorie: categorie_libelle,
                rank3Mois: rankingData.data.rank3Mois,
                rank6Mois: rankingData.data.rank6Mois,
                rank1An: rankingData.data.rank1An,
                rank3Ans: rankingData.data.rank3Ans,
                rank5Ans: rankingData.data.rank5Ans,
                rank1erJanvier: rankingData.data.rank1erJanvier,
                rank3Moistotal: rankingData.data.rank3Moistotal,
                rank6Moistotal: rankingData.data.rank6Moistotal,
                rank1Antotal: rankingData.data.rank1Antotal,
                rank3Anstotal: rankingData.data.rank3Anstotal,
                rank5Anstotal: rankingData.data.rank5Anstotal,
                rank1erJanviertotal: rankingData.data.rank1erJanviertotal,
              });
          }

          if (existingRankingregional) {
            // Le fond existe, mettez à jour son classement en fonction de la catégorie
            existingRankingregional.rank3Mois = rankingDataregional.data.rank3Mois;
            existingRankingregional.rank6Mois = rankingDataregional.data.rank6Mois;
            existingRankingregional.rank1An = rankingDataregional.data.rank1An;
            existingRankingregional.rank3Ans = rankingDataregional.data.rank3Ans;
            existingRankingregional.rank5Ans = rankingDataregional.data.rank5Ans;
            existingRankingregional.rank1erJanvier = rankingDataregional.data.rank1erJanvier;
            existingRankingregional.rank1erJanvier = rankingDataregional.data.rank1erJanvier;
            existingRankingregional.rank3Moistotal = rankingDataregional.data.rank3Moistotal;
            existingRankingregional.rank6Moistotal = rankingDataregional.data.rank6Moistotal;
            existingRankingregional.rank1Antotal = rankingDataregional.data.rank1Antotal;
            existingRankingregional.rank3Anstotal = rankingDataregional.data.rank3Anstotal;
            existingRankingregional.rank5Anstotal = rankingDataregional.data.rank5Anstotal;
            existingRankingregional.rank1erJanviertotal = rankingDataregional.data.rank1erJanviertotal;
            existingRankingregional.type_classement = 1;
            await existingRankingregional.save();
          } else {

            // Le fond n'existe pas, créez une nouvelle entrée dans la table classementfond
            if (rankingDataregional.code == 200)
              await classementfonds.create({
                fond_id: fundId,
                categorie_nationale: category,
                type_classement: 2,
                categorie_regionale: categorie_regionale,
                categorie: categorie_libelle,
                rank3Mois: rankingDataregional.data.rank3Mois,
                rank6Mois: rankingDataregional.data.rank6Mois,
                rank1An: rankingDataregional.data.rank1An,
                rank3Ans: rankingDataregional.data.rank3Ans,
                rank5Ans: rankingDataregional.data.rank5Ans,
                rank1erJanvier: rankingDataregional.data.rank1erJanvier,
                rank3Moistotal: rankingDataregional.data.rank3Moistotal,
                rank6Moistotal: rankingDataregional.data.rank6Moistotal,
                rank1Antotal: rankingDataregional.data.rank1Antotal,
                rank3Anstotal: rankingDataregional.data.rank3Anstotal,
                rank5Anstotal: rankingDataregional.data.rank5Anstotal,
                rank1erJanviertotal: rankingDataregional.data.rank1erJanviertotal,
              });
          }
        }
        console.log("finishrank");
        res.json("finishrank");
      } catch (error) {
        console.error('Une erreur s\'est produite :', error);
      }
    });
  }
  app.get('/api/classement1', async (req, res) => {
    try {
      await classementfonds.destroy({

        truncate: true
      });
      const allFunds = await fetchFundsByValorisation([], 'undefined', 'undefined', 'undefined', '');
      for (const fund of allFunds) {
        const fundId = fund.id;
        const category = fund.categorie_national;
        const categorie_regionale = fund.categorie_regional;
        const categorie_libelle = fund.categorie_libelle;
        const datemoispre = fund.datemoispre;
        const datejour = fund.datejour;

        // Vérifiez si le fond existe dans la table classementfond
        const existingRanking = await classementfonds.findOne({
          where: { fond_id: fundId, type_classement: 1 },
        });

        const existingRankingregional = await classementfonds.findOne({
          where: { fond_id: fundId, type_classement: 2 },
        });

        // Calculez le classement en fonction de la catégorie
        const rankingData = await calculateRank(category, fundId, datejour);
        const rankingDataregional = await calculateRankregional(categorie_regionale, fundId, datejour);


        if (existingRanking) {
          // Le fond existe, mettez à jour son classement en fonction de la catégorie
          existingRanking.rank3Mois = rankingData.data.rank3Mois;
          existingRanking.rank6Mois = rankingData.data.rank6Mois;
          existingRanking.rank1An = rankingData.data.rank1An;
          existingRanking.rank3Ans = rankingData.data.rank3Ans;
          existingRanking.rank5Ans = rankingData.data.rank5Ans;
          existingRanking.rank1erJanvier = rankingData.data.rank1erJanvier;
          existingRanking.rank3Moistotal = rankingData.data.rank3Moistotal;
          existingRanking.rank6Moistotal = rankingData.data.rank6Moistotal;
          existingRanking.rank1Antotal = rankingData.data.rank1Antotal;
          existingRanking.rank3Anstotal = rankingData.data.rank3Anstotal;
          existingRanking.rank5Anstotal = rankingData.data.rank5Anstotal;
          existingRanking.rank1erJanviertotal = rankingData.data.rank1erJanviertotal;

          existingRanking.rank3Moism = rankingData.data.rank3Moism;
          existingRanking.rank6Moism = rankingData.data.rank6Moism;
          existingRanking.rank1Anm = rankingData.data.rank1Anm;
          existingRanking.rank3Ansm = rankingData.data.rank3Ansm;
          existingRanking.rank5Ansm = rankingData.data.rank5Ansm;
          existingRanking.rank1erJanvierm = rankingData.data.rank1erJanvierm;
          existingRanking.rank3Moistotalm = rankingData.data.rank3Moistotalm;
          existingRanking.rank6Moistotalm = rankingData.data.rank6Moistotalm;
          existingRanking.rank1Antotalm = rankingData.data.rank1Antotalm;
          existingRanking.rank3Anstotalm = rankingData.data.rank3Anstotalm;
          existingRanking.rank5Anstotalm = rankingData.data.rank5Anstotalm;
          existingRanking.rank1erJanviertotalm = rankingData.data.rank1erJanviertotalm;

          existingRanking.rankvolatilite = rankingData.data.rankvolatilite;
          existingRanking.ranksharpe = rankingData.data.ranksharpe;
          existingRanking.rankcalamar = rankingData.data.rankcalamar;
          existingRanking.rankomega = rankingData.data.rankomega;
          existingRanking.rankdsr = rankingData.data.rankdsr;
          existingRanking.ranksortino = rankingData.data.ranksortino;
          existingRanking.rankvar95 = rankingData.data.rankvar95;
          existingRanking.rankbetabaissier = rankingData.data.rankbetabaissier;
          existingRanking.rankinfo = rankingData.data.rankinfo;
          existingRanking.rankpertemax = rankingData.data.rankpertemax;
          existingRanking.rankvolatilitetotal = rankingData.data.rankvolatilitetotal;
          existingRanking.ranksharpetotal = rankingData.data.ranksharpetotal;
          existingRanking.rankcalamartotal = rankingData.data.rankcalamartotal;
          existingRanking.rankomegatotal = rankingData.data.rankomegatotal;
          existingRanking.rankdsrtotal = rankingData.data.rankdsrtotal;
          existingRanking.ranksortinototal = rankingData.data.ranksortinototal;
          existingRanking.rankvar95total = rankingData.data.rankvar95total;
          existingRanking.rankbetabaissiertotal = rankingData.data.rankbetabaissiertotal;
          existingRanking.rankinfototal = rankingData.data.rankinfototal;
          existingRanking.rankpertemaxtotal = rankingData.data.rankpertemaxtotal;
          existingRanking.type_classement = 1;
          await existingRanking.save();
        } else {
          // Le fond n'existe pas, créez une nouvelle entrée dans la table classementfond
          if (rankingData && rankingData.code == 200)
            await classementfonds.create({
              fond_id: fundId,
              categorie_nationale: category,
              type_classement: 1,
              categorie_regionale: categorie_regionale,
              categorie: categorie_libelle,
              rank3Mois: rankingData.data.rank3Mois,
              rank6Mois: rankingData.data.rank6Mois,
              rank1An: rankingData.data.rank1An,
              rank3Ans: rankingData.data.rank3Ans,
              rank5Ans: rankingData.data.rank5Ans,
              rank1erJanvier: rankingData.data.rank1erJanvier,
              rank3Moistotal: rankingData.data.rank3Moistotal,
              rank6Moistotal: rankingData.data.rank6Moistotal,
              rank1Antotal: rankingData.data.rank1Antotal,
              rank3Anstotal: rankingData.data.rank3Anstotal,
              rank5Anstotal: rankingData.data.rank5Anstotal,
              rank1erJanviertotal: rankingData.data.rank1erJanviertotal,

              rank3Moism: rankingData.data.rank3Moism,
              rank6Moism: rankingData.data.rank6Moism,
              rank1Anm: rankingData.data.rank1Anm,
              rank3Ansm: rankingData.data.rank3Ansm,
              rank5Ansm: rankingData.data.rank5Ansm,
              rank1erJanvierm: rankingData.data.rank1erJanvierm,
              rank3Moistotalm: rankingData.data.rank3Moistotalm,
              rank6Moistotalm: rankingData.data.rank6Moistotalm,
              rank1Antotalm: rankingData.data.rank1Antotalm,
              rank3Anstotalm: rankingData.data.rank3Anstotalm,
              rank5Anstotalm: rankingData.data.rank5Anstotalm,
              rank1erJanviertotalm: rankingData.data.rank1erJanviertotalm,

              rankvolatilite: rankingData.data.rankvolatilite,
              ranksharpe: rankingData.data.ranksharpe,
              rankcalamar: rankingData.data.rankcalamar,
              rankomega: rankingData.data.rankomega,
              rankdsr: rankingData.data.rankdsr,
              ranksortino: rankingData.data.ranksortino,
              rankvar95: rankingData.data.rankvar95,
              rankbetabaissier: rankingData.data.rankbetabaissier,
              rankinfo: rankingData.data.rankinfo,
              rankpertemax: rankingData.data.rankpertemax,
              rankvolatilitetotal: rankingData.data.rankvolatilitetotal,
              ranksharpetotal: rankingData.data.ranksharpetotal,
              rankcalamartotal: rankingData.data.rankcalamartotal,
              rankomegatotal: rankingData.data.rankomegatotal,
              rankdsrtotal: rankingData.data.rankdsrtotal,
              ranksortinototal: rankingData.data.ranksortinototal,
              rankvar95total: rankingData.data.rankvar95total,
              rankbetabaissiertotal: rankingData.data.rankbetabaissiertotal,
              rankinfototal: rankingData.data.rankinfototal,
              rankpertemaxtotal: rankingData.data.rankpertemaxtotal
            });
        }

        if (existingRankingregional) {
          // Le fond existe, mettez à jour son classement en fonction de la catégorie
          existingRankingregional.rank3Mois = rankingDataregional.data.rank3Mois;
          existingRankingregional.rank6Mois = rankingDataregional.data.rank6Mois;
          existingRankingregional.rank1An = rankingDataregional.data.rank1An;
          existingRankingregional.rank3Ans = rankingDataregional.data.rank3Ans;
          existingRankingregional.rank5Ans = rankingDataregional.data.rank5Ans;
          existingRankingregional.rank1erJanvier = rankingDataregional.data.rank1erJanvier;
          existingRankingregional.rank1erJanvier = rankingDataregional.data.rank1erJanvier;
          existingRankingregional.rank3Moistotal = rankingDataregional.data.rank3Moistotal;
          existingRankingregional.rank6Moistotal = rankingDataregional.data.rank6Moistotal;
          existingRankingregional.rank1Antotal = rankingDataregional.data.rank1Antotal;
          existingRankingregional.rank3Anstotal = rankingDataregional.data.rank3Anstotal;
          existingRankingregional.rank5Anstotal = rankingDataregional.data.rank5Anstotal;
          existingRankingregional.rank1erJanviertotal = rankingDataregional.data.rank1erJanviertotal;
          existingRankingregional.type_classement = 1;
          await existingRankingregional.save();
        } else {

          // Le fond n'existe pas, créez une nouvelle entrée dans la table classementfond
          if (rankingDataregional.code == 200)
            await classementfonds.create({
              fond_id: fundId,
              categorie_nationale: category,
              type_classement: 2,
              categorie_regionale: categorie_regionale,
              categorie: categorie_libelle,
              rank3Mois: rankingDataregional.data.rank3Mois,
              rank6Mois: rankingDataregional.data.rank6Mois,
              rank1An: rankingDataregional.data.rank1An,
              rank3Ans: rankingDataregional.data.rank3Ans,
              rank5Ans: rankingDataregional.data.rank5Ans,
              rank1erJanvier: rankingDataregional.data.rank1erJanvier,
              rank3Moistotal: rankingDataregional.data.rank3Moistotal,
              rank6Moistotal: rankingDataregional.data.rank6Moistotal,
              rank1Antotal: rankingDataregional.data.rank1Antotal,
              rank3Anstotal: rankingDataregional.data.rank3Anstotal,
              rank5Anstotal: rankingDataregional.data.rank5Anstotal,
              rank1erJanviertotal: rankingDataregional.data.rank1erJanviertotal,
            });
        }
      }
      console.log("finishrank");
      res.json("finishrank");
    } catch (error) {
      console.error('Une erreur s\'est produite :', error);
    }
  });
  app.get('/api/classementeur', async (req, res) => {
    try {
      await classementfonds_eurs.destroy({

        truncate: true
      });
      const allFunds = await fetchFundsByValorisation([], 'undefined', 'undefined', 'undefined', '');
      for (const fund of allFunds) {
        const fundId = fund.id;
        const category = fund.categorie_national;
        const categorie_regionale = fund.categorie_regional;
        const categorie_libelle = fund.categorie_libelle;

        // Vérifiez si le fond existe dans la table classementfond
        const existingRanking = await classementfonds_eurs.findOne({
          where: { fond_id: fundId, type_classement: 1 },
        });

        const existingRankingregional = await classementfonds_eurs.findOne({
          where: { fond_id: fundId, type_classement: 2 },
        });

        // Calculez le classement en fonction de la catégorie
        const rankingData = await calculateRankdev(category, fundId, "EUR");
        const rankingDataregional = await calculateRankregionaldev(categorie_regionale, fundId, "EUR");


        if (existingRanking) {
          // Le fond existe, mettez à jour son classement en fonction de la catégorie
          existingRanking.rank3Mois = rankingData.data.rank3Mois;
          existingRanking.rank6Mois = rankingData.data.rank6Mois;
          existingRanking.rank1An = rankingData.data.rank1An;
          existingRanking.rank3Ans = rankingData.data.rank3Ans;
          existingRanking.rank5Ans = rankingData.data.rank5Ans;
          existingRanking.rank1erJanvier = rankingData.data.rank1erJanvier;
          existingRanking.rank1erJanvier = rankingData.data.rank1erJanvier;
          existingRanking.rank3Moistotal = rankingData.data.rank3Moistotal;
          existingRanking.rank6Moistotal = rankingData.data.rank6Moistotal;
          existingRanking.rank1Antotal = rankingData.data.rank1Antotal;
          existingRanking.rank3Anstotal = rankingData.data.rank3Anstotal;
          existingRanking.rank5Anstotal = rankingData.data.rank5Anstotal;
          existingRanking.rank1erJanviertotal = rankingData.data.rank1erJanviertotal;
          existingRanking.type_classement = 1;
          await existingRanking.save();
        } else {
          // Le fond n'existe pas, créez une nouvelle entrée dans la table classementfond
          if (rankingData.code == 200)
            await classementfonds.create({
              fond_id: fundId,
              categorie_nationale: category,
              type_classement: 1,
              categorie_regionale: categorie_regionale,
              categorie: categorie_libelle,
              rank3Mois: rankingData.data.rank3Mois,
              rank6Mois: rankingData.data.rank6Mois,
              rank1An: rankingData.data.rank1An,
              rank3Ans: rankingData.data.rank3Ans,
              rank5Ans: rankingData.data.rank5Ans,
              rank1erJanvier: rankingData.data.rank1erJanvier,
              rank3Moistotal: rankingData.data.rank3Moistotal,
              rank6Moistotal: rankingData.data.rank6Moistotal,
              rank1Antotal: rankingData.data.rank1Antotal,
              rank3Anstotal: rankingData.data.rank3Anstotal,
              rank5Anstotal: rankingData.data.rank5Anstotal,
              rank1erJanviertotal: rankingData.data.rank1erJanviertotal,
            });
        }

        if (existingRankingregional) {
          // Le fond existe, mettez à jour son classement en fonction de la catégorie
          existingRankingregional.rank3Mois = rankingDataregional.data.rank3Mois;
          existingRankingregional.rank6Mois = rankingDataregional.data.rank6Mois;
          existingRankingregional.rank1An = rankingDataregional.data.rank1An;
          existingRankingregional.rank3Ans = rankingDataregional.data.rank3Ans;
          existingRankingregional.rank5Ans = rankingDataregional.data.rank5Ans;
          existingRankingregional.rank1erJanvier = rankingDataregional.data.rank1erJanvier;
          existingRankingregional.rank1erJanvier = rankingDataregional.data.rank1erJanvier;
          existingRankingregional.rank3Moistotal = rankingDataregional.data.rank3Moistotal;
          existingRankingregional.rank6Moistotal = rankingDataregional.data.rank6Moistotal;
          existingRankingregional.rank1Antotal = rankingDataregional.data.rank1Antotal;
          existingRankingregional.rank3Anstotal = rankingDataregional.data.rank3Anstotal;
          existingRankingregional.rank5Anstotal = rankingDataregional.data.rank5Anstotal;
          existingRankingregional.rank1erJanviertotal = rankingDataregional.data.rank1erJanviertotal;
          existingRankingregional.type_classement = 1;
          await existingRankingregional.save();
        } else {

          // Le fond n'existe pas, créez une nouvelle entrée dans la table classementfond
          if (rankingDataregional.code == 200)
            await classementfonds.create({
              fond_id: fundId,
              categorie_nationale: category,
              type_classement: 2,
              categorie_regionale: categorie_regionale,
              categorie: categorie_libelle,
              rank3Mois: rankingDataregional.data.rank3Mois,
              rank6Mois: rankingDataregional.data.rank6Mois,
              rank1An: rankingDataregional.data.rank1An,
              rank3Ans: rankingDataregional.data.rank3Ans,
              rank5Ans: rankingDataregional.data.rank5Ans,
              rank1erJanvier: rankingDataregional.data.rank1erJanvier,
              rank3Moistotal: rankingDataregional.data.rank3Moistotal,
              rank6Moistotal: rankingDataregional.data.rank6Moistotal,
              rank1Antotal: rankingDataregional.data.rank1Antotal,
              rank3Anstotal: rankingDataregional.data.rank3Anstotal,
              rank5Anstotal: rankingDataregional.data.rank5Anstotal,
              rank1erJanviertotal: rankingDataregional.data.rank1erJanviertotal,
            });
        }
      }
      console.log("finishrank");
      res.json("finishrank");
    } catch (error) {
      console.error('Une erreur s\'est produite :', error);
    }
  });
  app.get('/api/classementusd', async (req, res) => {
    try {
      await classementfonds_usds.destroy({

        truncate: true
      });
      const allFunds = await fetchFundsByValorisation([], 'undefined', 'undefined', 'undefined', '');
      for (const fund of allFunds) {
        const fundId = fund.id;
        const category = fund.categorie_national;
        const categorie_regionale = fund.categorie_regional;
        const categorie_libelle = fund.categorie_libelle;

        // Vérifiez si le fond existe dans la table classementfond
        const existingRanking = await classementfonds_usds.findOne({
          where: { fond_id: fundId, type_classement: 1 },
        });

        const existingRankingregional = await classementfonds_usds.findOne({
          where: { fond_id: fundId, type_classement: 2 },
        });

        // Calculez le classement en fonction de la catégorie
        const rankingData = await calculateRankdev(category, fundId, "USD");
        const rankingDataregional = await calculateRankregionaldev(categorie_regionale, fundId, "USD");


        if (existingRanking) {
          // Le fond existe, mettez à jour son classement en fonction de la catégorie
          existingRanking.rank3Mois = rankingData.data.rank3Mois;
          existingRanking.rank6Mois = rankingData.data.rank6Mois;
          existingRanking.rank1An = rankingData.data.rank1An;
          existingRanking.rank3Ans = rankingData.data.rank3Ans;
          existingRanking.rank5Ans = rankingData.data.rank5Ans;
          existingRanking.rank1erJanvier = rankingData.data.rank1erJanvier;
          existingRanking.rank1erJanvier = rankingData.data.rank1erJanvier;
          existingRanking.rank3Moistotal = rankingData.data.rank3Moistotal;
          existingRanking.rank6Moistotal = rankingData.data.rank6Moistotal;
          existingRanking.rank1Antotal = rankingData.data.rank1Antotal;
          existingRanking.rank3Anstotal = rankingData.data.rank3Anstotal;
          existingRanking.rank5Anstotal = rankingData.data.rank5Anstotal;
          existingRanking.rank1erJanviertotal = rankingData.data.rank1erJanviertotal;
          existingRanking.type_classement = 1;
          await existingRanking.save();
        } else {
          // Le fond n'existe pas, créez une nouvelle entrée dans la table classementfond
          if (rankingData.code == 200)
            await classementfonds.create({
              fond_id: fundId,
              categorie_nationale: category,
              type_classement: 1,
              categorie_regionale: categorie_regionale,
              categorie: categorie_libelle,
              rank3Mois: rankingData.data.rank3Mois,
              rank6Mois: rankingData.data.rank6Mois,
              rank1An: rankingData.data.rank1An,
              rank3Ans: rankingData.data.rank3Ans,
              rank5Ans: rankingData.data.rank5Ans,
              rank1erJanvier: rankingData.data.rank1erJanvier,
              rank3Moistotal: rankingData.data.rank3Moistotal,
              rank6Moistotal: rankingData.data.rank6Moistotal,
              rank1Antotal: rankingData.data.rank1Antotal,
              rank3Anstotal: rankingData.data.rank3Anstotal,
              rank5Anstotal: rankingData.data.rank5Anstotal,
              rank1erJanviertotal: rankingData.data.rank1erJanviertotal,
            });
        }

        if (existingRankingregional) {
          // Le fond existe, mettez à jour son classement en fonction de la catégorie
          existingRankingregional.rank3Mois = rankingDataregional.data.rank3Mois;
          existingRankingregional.rank6Mois = rankingDataregional.data.rank6Mois;
          existingRankingregional.rank1An = rankingDataregional.data.rank1An;
          existingRankingregional.rank3Ans = rankingDataregional.data.rank3Ans;
          existingRankingregional.rank5Ans = rankingDataregional.data.rank5Ans;
          existingRankingregional.rank1erJanvier = rankingDataregional.data.rank1erJanvier;
          existingRankingregional.rank1erJanvier = rankingDataregional.data.rank1erJanvier;
          existingRankingregional.rank3Moistotal = rankingDataregional.data.rank3Moistotal;
          existingRankingregional.rank6Moistotal = rankingDataregional.data.rank6Moistotal;
          existingRankingregional.rank1Antotal = rankingDataregional.data.rank1Antotal;
          existingRankingregional.rank3Anstotal = rankingDataregional.data.rank3Anstotal;
          existingRankingregional.rank5Anstotal = rankingDataregional.data.rank5Anstotal;
          existingRankingregional.rank1erJanviertotal = rankingDataregional.data.rank1erJanviertotal;
          existingRankingregional.type_classement = 1;
          await existingRankingregional.save();
        } else {

          // Le fond n'existe pas, créez une nouvelle entrée dans la table classementfond
          if (rankingDataregional.code == 200)
            await classementfonds.create({
              fond_id: fundId,
              categorie_nationale: category,
              type_classement: 2,
              categorie_regionale: categorie_regionale,
              categorie: categorie_libelle,
              rank3Mois: rankingDataregional.data.rank3Mois,
              rank6Mois: rankingDataregional.data.rank6Mois,
              rank1An: rankingDataregional.data.rank1An,
              rank3Ans: rankingDataregional.data.rank3Ans,
              rank5Ans: rankingDataregional.data.rank5Ans,
              rank1erJanvier: rankingDataregional.data.rank1erJanvier,
              rank3Moistotal: rankingDataregional.data.rank3Moistotal,
              rank6Moistotal: rankingDataregional.data.rank6Moistotal,
              rank1Antotal: rankingDataregional.data.rank1Antotal,
              rank3Anstotal: rankingDataregional.data.rank3Anstotal,
              rank5Anstotal: rankingDataregional.data.rank5Anstotal,
              rank1erJanviertotal: rankingDataregional.data.rank1erJanviertotal,
            });
        }
      }
      console.log("finishrank");
      res.json("finishrank");
    } catch (error) {
      console.error('Une erreur s\'est produite :', error);
    }
  });


  app.get('/api/killlimiter', async (req, res) => {
    limiter.stop();
    // Vider la file d'attente des tâches en cours
    // Déconnecter Bottleneck (vide la file d'attente)
    limiter.disconnect();      // Redémarrer la planification des tâches
  });
  app.get('/api/startlimiter/:max/:min', async (req, res) => {
    limiter = new Bottleneck({
      maxConcurrent: parseInt(req.params.max),
      minTime: parseInt(req.params.min)
    });
  });
  app.get('/api/saveperfdate1/:fond1/:fond2', async (req, res) => {
    try {

      const allFunds = await fetchFundsByValorisation1([], 'undefined', 'undefined', 'undefined', 'undefined', parseInt(req.params.fond1), parseInt(req.params.fond2));

      // Sequential processing using for loop with await
      /*for (const fund of allFunds) {
        try {
          await processFund(fund);
        } catch (error) {
          console.error('Error processing fund:', fund, error);
        }
      }*/
      // Ajouter les fonds à la file d'attente pour traitement
      // Définissez le nombre de travailleurs à utiliser

      /*  for (const fund of allFunds) {
          await limiter.schedule(async () => {
            await processFund(fund);
          });
        }*/
      limiter.stop();
      // Vider la file d'attente des tâches en cours
      // Déconnecter Bottleneck (vide la file d'attente)
      limiter.disconnect();      // Redémarrer la planification des tâches
      // Réinitialiser Bottleneck avec les configurations initiales
      limiter = new Bottleneck({
        maxConcurrent: 3,
        minTime: 250
      });
      const promises = allFunds.map(async (fund) => {
        try {
          // Attendre que Bottleneck autorise la requête
          await limiter.schedule(async () => {
            await processFund(fund);
          });
        } catch (error) {
          console.error('Erreur lors du traitement du fond:', fund, error);
        }
      });
      // Attendre la fin de toutes les promesses
      await Promise.all(promises);



      res.json("Traitement des fonds terminé avec succès");
    } catch (error) {
      console.error('Une erreur s\'est produite :', error);
      res.status(500).json({ error: 'Une erreur s\'est produite lors du traitement.' });
    }
  });


  async function processFund(fund) {
    const fundId = fund.id;
    const code_ISIN = fund.code_ISIN;
    const categorie_nationale = fund.categorie_national;
    const categorie_regionale = fund.categorie_regional;

    const allVlDates = await vl.findAll({
      attributes: ['date'],
      where: {
        fund_id: fundId, date: {
          [Op.gt]: '2021-12-31' // Sélectionner les dates supérieures à '2021-12-31'
        }
      }, // Condition where pour filtrer par fund_id
      order: [['date', 'DESC']] // Trier les dates en ordre chronologique
    });

    const yearsSinceValorisation = await anneevalorisation(fundId);
    const years = yearsSinceValorisation[0].annee;

    for (let i = 0; i < allVlDates.length; i++) {
      const currentDate = allVlDates[i].date;

      try {
        const performanceResponse = await fetch(`${urll}/api/performanceswithdate/fond/${fundId}/${currentDate}`);
        if (performanceResponse.status === 200) {
          const performanceData = await performanceResponse.json();

          const ratioData = await fetchRatioData(fundId, currentDate, years);
          await upsertPerformance(fundId, code_ISIN, categorie_nationale, categorie_regionale, fund.dev_libelle, currentDate, performanceData.data, ratioData);
        } else {
          writeToLogFile(`Erreur lors de l'appel à l'API pour le fond avec l'ID ${fundId}`)
          console.error(`Erreur lors de l'appel à l'API pour le fond avec l'ID ${fundId}`);
        }
      } catch (error) {
        writeToLogFile(`Une erreur s'est produite lors du traitement du fond avec l'ID ${fundId} à la date ${currentDate}:`, error)
        console.error(`Une erreur s'est produite lors du traitement du fond avec l'ID ${fundId} à la date ${currentDate}:`, error);
        continue;
      }
    }

    writeToLogFile(`finish l'ID ${fundId}`);
  }

  async function fetchRatioData(fundId, currentDate, years) {
    const ratioData = {};

    if (years > 1) {
      const ratioResponse1an = await fetch(`${urll}/api/ratiosnewithdate/1/${fundId}/${currentDate}`);
      ratioData.data1an = await ratioResponse1an.json();
    }

    if (years > 3) {
      const ratioResponse3ans = await fetch(`${urll}/api/ratiosnewithdate/3/${fundId}/${currentDate}`);
      ratioData.data3an = await ratioResponse3ans.json();
    }

    if (years > 5) {
      const ratioResponse5ans = await fetch(`${urll}/api/ratiosnewithdate/5/${fundId}/${currentDate}`);
      ratioData.data5an = await ratioResponse5ans.json();
    }

    return ratioData;
  }

  async function upsertPerformance(fundId, code_ISIN, categorie_nationale, categorie_regionale, devise, currentDate, performanceData, ratioData) {
    const existingperf = await performences.findOne({ where: { fond_id: fundId, date: currentDate } });

    if (existingperf) {
      Object.assign(existingperf, {
        ytd: performanceData.perf1erJanvier,
        perfveille: performanceData.perfVeille,
        perf1an: performanceData.perf1An,
        perf3ans: performanceData.perf3Ans,
        perf5ans: performanceData.perf5Ans,
        perf8ans: performanceData.perf8Ans,
        perf10ans: performanceData.perf10Ans,
        perf4s: performanceData.perf4Semaines,
        perf3m: performanceData.perf3Mois,
        perf6m: performanceData.perf6Mois,
        ytdm: performanceData.perf1erJanvierm,
        perfveillem: performanceData.perfVeillem,
        perf1anm: performanceData.perf1Anm,
        perf3ansm: performanceData.perf3Ansm,
        perf5ansm: performanceData.perf5Ansm,
        perf8ansm: performanceData.perf8Ansm,
        perf10ansm: performanceData.perf10Ansm,
        perf4sm: performanceData.perf4Semainesm,
        perf3mm: performanceData.perf3Moism,
        perf6mm: performanceData.perf6Moism,
        lastdatepreviousmonth: performanceData.lastdatepreviousmonth,
        ...getRatioDataFields(ratioData, '1an'),
        ...getRatioDataFields(ratioData, '3an'),
        ...getRatioDataFields(ratioData, '5an')
      });
      await existingperf.save();
    } else {
      await performences.create({
        date: currentDate,
        fond_id: fundId,
        code_ISIN,
        categorie: performanceData.category,
        categorie_nationale,
        categorie_regionale,
        devise,
        lastdatepreviousmonth: performanceData.lastdatepreviousmonth,
        ytd: performanceData.perf1erJanvier,
        perfveille: performanceData.perfVeille,
        perf1an: performanceData.perf1An,
        perf3ans: performanceData.perf3Ans,
        perf5ans: performanceData.perf5Ans,
        perf8ans: performanceData.perf8Ans,
        perf10ans: performanceData.perf10Ans,
        perf4s: performanceData.perf4Semaines,
        perf3m: performanceData.perf3Mois,
        perf6m: performanceData.perf6Mois,
        ...getRatioDataFields(ratioData, '1an'),
        ...getRatioDataFields(ratioData, '3an'),
        ...getRatioDataFields(ratioData, '5an')
      });
    }
  }

  function getRatioDataFields(ratioData, period) {
    const fields = ['perfannu', 'volatility', 'ratiosharpe', 'pertemax', 'sortino', 'info', 'calamar', 'var99', 'var95', 'trackingerror', 'betahaussier', 'betabaissier', 'beta', 'omega', 'dsr', 'downcapture', 'upcapture', 'skewness', 'kurtosis'];
    const result = {};

    fields.forEach(field => {
      result[`${field}${period}`] = ratioData[`data${period}`] ? ratioData[`data${period}`].data[field] : '-';
    });

    return result;
  }


  app.get('/api/saveperfdateeur/:fond1/:fond2', async (req, res) => {
    try {
      /*  await performences_eurs.destroy({
  
          truncate: true
        });*/
      a = 'undefined';
      b = 'undefined'
      const allFunds = await fetchFundsByValorisation1([], 'undefined', 'undefined', 'undefined', 'undefined', parseInt(req.params.fond1), parseInt(req.params.fond2));

      //const allFunds = await fond.findAll();

      for (const fund of allFunds) {
        //  if(fund.id==576 || fund.id==580 || fund.id==581 || fund.id==1131 ){
        let anomalie = "";
        const periodicite = fund.periodicite;

        const fundId = fund.id;
        const code_ISIN = fund.code_ISIN;
        const categorie_nationale = fund.categorie_national;
        const categorie_regionale = fund.categorie_regional;

        const firstVlDate = await vl.min('date', { where: { fund_id: fundId } });
        const increment = periodicite === 'journaliere' ? 'days' : 'weeks';
        for (let date = moment(firstVlDate); date.isBefore(moment()); date.add(1, increment)) {
          // Si la périodicité est journalière et la date est un week-end, passer à la prochaine date
          if (periodicite === 'journaliere' && isWeekend(date)) {
            continue;
          }

          // Vérifier si la VL est manquante pour cette date
          const vlExists = await vl.findOne({ where: { fund_id: fundId, date: date.format('YYYY-MM-DD') } });

          // Si la VL n'existe pas, ajouter l'anomalie VL manquante
          if (!vlExists) {
            anomalie = "VL MANQUANTE"
            break; // Arrêter la boucle après avoir trouvé une anomalie de VL manquante
            //anomalies.push({ fond_id: id, date: date.format('YYYY-MM-DD'), type_anomalie: 'VL manquant' });
          }
        }
        const maxVlDate = await vl.max('date', { where: { fund_id: fundId } });
        for (let date = moment(firstVlDate); date.isSameOrBefore(maxVlDate); date.add(1, 'day')) {

          if (date.day() === 0 || date.day() === 6) {
            continue; // Passer à la prochaine itération de la boucle
          }

          const currentDate = date.format('YYYY-MM-DD');

          const devise = "EUR"
          // Appeler l'API externe pour obtenir les données de performance du fond
          const performanceResponse = await fetch(`${urll}/api/performancesdevwithdate/fond/${fundId}/${devise}/${currentDate}`);
          if (performanceResponse.status === 200) {
            const performanceData = await performanceResponse.json();

            // Déterminer la durée de la valorisation en années
            const yearsSinceValorisation = await anneevalorisation(fundId);
            console.log(yearsSinceValorisation[0].annee);

            // Appeler l'API des ratios en fonction de la durée de la valorisation
            let ratioApiUrl;
            let ratioApiUrl1an;

            let ratioApiUrl5ans;

            let ratioApiUrl3ans;

            if (yearsSinceValorisation[0].annee >= 5) {
              ratioApiUrl5ans = `${urll}/api/ratiosnewdevwithdate/5/${fundId}/${devise}/${currentDate}`;
            }
            if (yearsSinceValorisation[0].annee >= 3) {
              ratioApiUrl3ans = `${urll}/api/ratiosnewdevwithdate/3/${fundId}/${devise}/${currentDate}`;
            }
            if (yearsSinceValorisation[0].annee > 1) {
              ratioApiUrl1an = `${urll}/api/ratiosnewdevwithdate/1/${fundId}/${devise}/${currentDate}`;
            } else {
              // Si la valorisation est inférieure à 1 an, mettre les champs à '-'
              // ou définir une valeur par défaut selon vos besoins.
              ratioApiUrl = null; // Ou une autre valeur selon vos besoins
            }
            let ratioResponse1an;
            let ratioResponse3ans;
            let ratioResponse5ans;
            let ratioData3ans;
            let ratioData1an;
            let ratioData5ans;
            //   const ratioResponse = await fetch(ratioApiUrl1an);
            if (yearsSinceValorisation[0].annee > 1) {
              ratioResponse1an = await fetch(ratioApiUrl1an);
              ratioData1an = await ratioResponse1an.json();

            }
            if (yearsSinceValorisation[0].annee > 3) {
              ratioResponse3ans = await fetch(ratioApiUrl3ans);
              ratioData3ans = await ratioResponse3ans.json();
            }
            if (yearsSinceValorisation[0].annee > 5) {
              ratioResponse5ans = await fetch(ratioApiUrl5ans);

              ratioData5ans = await ratioResponse5ans.json();
            }

            const existingperf = await performences_eurs.findOne({
              where: { fond_id: fundId },
            });

            // Calculez le classement en fonction de la catégorie

            if (existingperf) {
              // Le fond existe, mettez à jour son classement en fonction de la catégorie
              existingperf.ytd = performanceData.data.perf1erJanvier;
              existingperf.anomalie = anomalie;
              existingperf.perfveille = performanceData.data.perfVeille;
              existingperf.perf1an = performanceData.data.perf1An;
              existingperf.perf3ans = performanceData.data.perf3Ans;
              existingperf.perf5ans = performanceData.data.perf5Ans;
              existingperf.perf8ans = performanceData.data.perf8Ans;
              existingperf.perf10ans = performanceData.data.perf10Ans;

              existingperf.perf4s = performanceData.data.perf4Semaines;
              existingperf.perf3m = performanceData.data.perf3Mois;
              existingperf.perf6m = performanceData.data.perf6Mois;
              existingperf.lastdatepreviousmonth = performanceData.data.lastdatepreviousmonth;

              existingperf.perfannu1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.perfAnnualisee : '-';
              existingperf.volatility1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.volatility : '-';
              existingperf.ratiosharpe1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.ratioSharpe : '-';
              existingperf.pertemax1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.maxDrawdown : '-';
              existingperf.sortino1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.sortino : '-';
              existingperf.info1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.info : '-';
              existingperf.calamar1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.calmar : '-';
              existingperf.var991an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.VAR99 : '-';
              existingperf.var951an = yearsSinceValorisation[0].annee > 3 ? ratioData1an.data.VAR95 : '-';
              existingperf.trackingerror1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.trackingError : '-';
              existingperf.betahaussier1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.betaHaussier : '-';
              existingperf.betabaissier1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.betaBaiss : '-';
              existingperf.beta1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.beta : '-';
              existingperf.sortino1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.sortino : '-';
              existingperf.omega1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.omega : '-';
              existingperf.dsr1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.dsr : '-';
              existingperf.downcapture1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.DownCaptureRatio : '-';
              existingperf.upcapture1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.UpCaptureRatio : '-';
              existingperf.skewness1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.skewness : '-';
              existingperf.kurtosis1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.kurtosis : '-';



              existingperf.perfannu3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.perfAnnualisee : '-';
              existingperf.volatility3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.volatility : '-';
              existingperf.ratiosharpe3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.ratioSharpe : '-';
              existingperf.pertemax3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.maxDrawdown : '-';
              existingperf.sortino3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.sortino : '-';
              existingperf.info3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.info : '-';
              existingperf.calamar3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.calmar : '-';
              existingperf.var993an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.VAR99 : '-';
              existingperf.var953an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.VAR95 : '-';
              existingperf.trackingerror3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.trackingError : '-';
              existingperf.betahaussier3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.betaHaussier : '-';
              existingperf.betabaissier3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.betaBaiss : '-';
              existingperf.beta3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.beta : '-';
              existingperf.sortino3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.sortino : '-';
              existingperf.omega3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.omega : '-';
              existingperf.dsr3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.dsr : '-';
              existingperf.downcapture3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.DownCaptureRatio : '-';
              existingperf.upcapture3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.UpCaptureRatio : '-';
              existingperf.skewness3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.skewness : '-';
              existingperf.kurtosis3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.kurtosis : '-';


              existingperf.perfannu5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.perfAnnualisee : '-';
              existingperf.volatility5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.volatility : '-';
              existingperf.ratiosharpe5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.ratioSharpe : '-';
              existingperf.pertemax5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.maxDrawdown : '-';
              existingperf.sortino5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.sortino : '-';
              existingperf.info5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.info : '-';
              existingperf.calamar5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.calmar : '-';
              existingperf.var995an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.VAR99 : '-';
              existingperf.var955an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.VAR95 : '-';
              existingperf.trackingerror5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.trackingError : '-';
              existingperf.betahaussier5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.betaHaussier : '-';
              existingperf.betabaissier5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.betaBaiss : '-';
              existingperf.beta5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.beta : '-';
              existingperf.sortino5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.sortino : '-';
              existingperf.omega5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.omega : '-';
              existingperf.dsr5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.dsr : '-';
              existingperf.downcapture5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.DownCaptureRatio : '-';
              existingperf.upcapture5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.UpCaptureRatio : '-';
              existingperf.skewness5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.skewness : '-';
              existingperf.kurtosis5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.kurtosis : '-';

              await existingperf.save();
            } else {

              // Insérer les données de performance et de ratio dans la table `performances`
              await performences_eurs.create({
                date: currentDate,
                fond_id: fundId,
                anomalie: anomalie,
                code_ISIN: code_ISIN,
                categorie: performanceData.data.category,
                categorie_nationale: categorie_nationale,
                categorie_regionale: categorie_regionale,
                devise: fund.dev_libelle,
                lastdatepreviousmonth: performanceData.data.lastdatepreviousmonth,
                ytd: performanceData.data.perf1erJanvier,
                perfveille: performanceData.data.perfVeille,
                perf1an: performanceData.data.perf1An,
                perf3ans: performanceData.data.perf3Ans,
                perf5ans: performanceData.data.perf5Ans,
                perf8ans: performanceData.data.perf8Ans,
                perf10ans: performanceData.data.perf10Ans,
                perf4s: performanceData.data.perf4Semaines,
                perf3m: performanceData.data.perf3Mois,
                perf6m: performanceData.data.perf6Mois,

                perfannu1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.perfAnnualisee : '-',
                volatility1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.volatility : '-',
                ratiosharpe1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.ratioSharpe : '-',
                pertemax1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.maxDrawdown : '-',
                sortino1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.sortino : '-',
                info1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.info : '-',
                calamar1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.calmar : '-',
                var991an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.VAR99 : '-',
                var951an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.VAR95 : '-',
                trackingerror1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.trackingError : '-',
                betahaussier1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.betaHaussier : '-',
                betabaissier1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.betaBaiss : '-',
                beta1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.beta : '-',
                sortino1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.sortino : '-',
                omega1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.omega : '-',
                dsr1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.dsr : '-',
                downcapture1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.DownCaptureRatio : '-',
                upcapture1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.UpCaptureRatio : '-',
                skewness1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.skewness : '-',
                kurtosis1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.kurtosis : '-',



                perfannu3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.perfAnnualisee : '-',
                volatility3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.volatility : '-',
                ratiosharpe3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.ratioSharpe : '-',
                pertemax3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.maxDrawdown : '-',
                sortino3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.sortino : '-',
                info3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.info : '-',
                calamar3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.calmar : '-',
                var993an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.VAR99 : '-',
                var953an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.VAR95 : '-',
                trackingerror3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.trackingError : '-',
                betahaussier3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.betaHaussier : '-',
                betabaissier3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.betaBaiss : '-',
                beta3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.beta : '-',
                sortino3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.sortino : '-',
                omega3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.omega : '-',
                dsr3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.dsr : '-',
                downcapture3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.DownCaptureRatio : '-',
                upcapture3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.UpCaptureRatio : '-',
                skewness3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.skewness : '-',
                kurtosis3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.kurtosis : '-',

                perfannu5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.perfAnnualisee : '-',
                volatility5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.volatility : '-',
                ratiosharpe5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.ratioSharpe : '-',
                pertemax5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.maxDrawdown : '-',
                sortino5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.sortino : '-',
                info5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.info : '-',
                calamar5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.calmar : '-',
                var995an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.VAR99 : '-',
                var955an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.VAR95 : '-',
                trackingerror5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.trackingError : '-',
                betahaussier5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.betaHaussier : '-',
                betabaissier5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.betaBaiss : '-',
                beta5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.beta : '-',
                sortino5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.sortino : '-',
                omega5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.omega : '-',
                dsr5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.dsr : '-',
                downcapture5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.DownCaptureRatio : '-',
                upcapture5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.UpCaptureRatio : '-',
                skewness5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.skewness : '-',
                kurtosis5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.kurtosis : '-',

              });
            }

          } else {
            console.error(`Erreur lors de l'appel à l'API pour le fond avec l'ID ${fundId}`);
            //  }


          }
        }
      }
      console.log("finish");
      res.json("finish");
    } catch (error) {
      console.error('Une erreur s\'est produite :', error);
    }
  });
  app.get('/api/saveperfdateusd/:fond1/:fond2', async (req, res) => {
    try {
      /* await performences_usds.destroy({
 
         truncate: true
       });*/
      a = 'undefined';
      b = 'undefined'
      const allFunds = await fetchFundsByValorisation1([], 'undefined', 'undefined', 'undefined', 'undefined', parseInt(req.params.fond1), parseInt(req.params.fond2));

      //const allFunds = await fond.findAll();

      for (const fund of allFunds) {
        //  if(fund.id==576 || fund.id==580 || fund.id==581 || fund.id==1131 ){
        let anomalie = "";
        const periodicite = fund.periodicite;

        const fundId = fund.id;
        const code_ISIN = fund.code_ISIN;
        const categorie_nationale = fund.categorie_national;
        const categorie_regionale = fund.categorie_regional;

        const firstVlDate = await vl.min('date', { where: { fund_id: fundId } });
        const increment = periodicite === 'journaliere' ? 'days' : 'weeks';
        for (let date = moment(firstVlDate); date.isBefore(moment()); date.add(1, increment)) {
          // Si la périodicité est journalière et la date est un week-end, passer à la prochaine date
          if (periodicite === 'journaliere' && isWeekend(date)) {
            continue;
          }

          // Vérifier si la VL est manquante pour cette date
          const vlExists = await vl.findOne({ where: { fund_id: fundId, date: date.format('YYYY-MM-DD') } });

          // Si la VL n'existe pas, ajouter l'anomalie VL manquante
          if (!vlExists) {
            anomalie = "VL MANQUANTE"
            break; // Arrêter la boucle après avoir trouvé une anomalie de VL manquante
            //anomalies.push({ fond_id: id, date: date.format('YYYY-MM-DD'), type_anomalie: 'VL manquant' });
          }
        }
        const maxVlDate = await vl.max('date', { where: { fund_id: fundId } });
        for (let date = moment(firstVlDate); date.isSameOrBefore(maxVlDate); date.add(1, 'day')) {

          if (date.day() === 0 || date.day() === 6) {
            continue; // Passer à la prochaine itération de la boucle
          }

          const currentDate = date.format('YYYY-MM-DD');

          const devise = "USD"
          // Appeler l'API externe pour obtenir les données de performance du fond
          const performanceResponse = await fetch(`${urll}/api/performancesdevwithdate/fond/${fundId}/${devise}/${currentDate}`);
          if (performanceResponse.status === 200) {
            const performanceData = await performanceResponse.json();

            // Déterminer la durée de la valorisation en années
            const yearsSinceValorisation = await anneevalorisation(fundId);
            console.log(yearsSinceValorisation[0].annee);

            // Appeler l'API des ratios en fonction de la durée de la valorisation
            let ratioApiUrl;
            let ratioApiUrl1an;

            let ratioApiUrl5ans;

            let ratioApiUrl3ans;

            if (yearsSinceValorisation[0].annee >= 5) {
              ratioApiUrl5ans = `${urll}/api/ratiosnewdevwithdate/5/${fundId}/${devise}/${currentDate}`;
            }
            if (yearsSinceValorisation[0].annee >= 3) {
              ratioApiUrl3ans = `${urll}/api/ratiosnewdevwithdate/3/${fundId}/${devise}/${currentDate}`;
            }
            if (yearsSinceValorisation[0].annee > 1) {
              ratioApiUrl1an = `${urll}/api/ratiosnewdevwithdate/1/${fundId}/${devise}/${currentDate}`;
            } else {
              // Si la valorisation est inférieure à 1 an, mettre les champs à '-'
              // ou définir une valeur par défaut selon vos besoins.
              ratioApiUrl = null; // Ou une autre valeur selon vos besoins
            }
            let ratioResponse1an;
            let ratioResponse3ans;
            let ratioResponse5ans;
            let ratioData3ans;
            let ratioData1an;
            let ratioData5ans;
            //   const ratioResponse = await fetch(ratioApiUrl1an);
            if (yearsSinceValorisation[0].annee > 1) {
              ratioResponse1an = await fetch(ratioApiUrl1an);
              ratioData1an = await ratioResponse1an.json();

            }
            if (yearsSinceValorisation[0].annee > 3) {
              ratioResponse3ans = await fetch(ratioApiUrl3ans);
              ratioData3ans = await ratioResponse3ans.json();
            }
            if (yearsSinceValorisation[0].annee > 5) {
              ratioResponse5ans = await fetch(ratioApiUrl5ans);

              ratioData5ans = await ratioResponse5ans.json();
            }

            const existingperf = await performences_usds.findOne({
              where: { fond_id: fundId },
            });

            // Calculez le classement en fonction de la catégorie

            if (existingperf) {
              // Le fond existe, mettez à jour son classement en fonction de la catégorie
              existingperf.ytd = performanceData.data.perf1erJanvier;
              existingperf.anomalie = anomalie;
              existingperf.perfveille = performanceData.data.perfVeille;
              existingperf.perf1an = performanceData.data.perf1An;
              existingperf.perf3ans = performanceData.data.perf3Ans;
              existingperf.perf5ans = performanceData.data.perf5Ans;
              existingperf.perf8ans = performanceData.data.perf8Ans;
              existingperf.perf10ans = performanceData.data.perf10Ans;

              existingperf.perf4s = performanceData.data.perf4Semaines;
              existingperf.perf3m = performanceData.data.perf3Mois;
              existingperf.perf6m = performanceData.data.perf6Mois;
              existingperf.lastdatepreviousmonth = performanceData.data.lastdatepreviousmonth;

              existingperf.perfannu1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.perfAnnualisee : '-';
              existingperf.volatility1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.volatility : '-';
              existingperf.ratiosharpe1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.ratioSharpe : '-';
              existingperf.pertemax1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.maxDrawdown : '-';
              existingperf.sortino1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.sortino : '-';
              existingperf.info1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.info : '-';
              existingperf.calamar1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.calmar : '-';
              existingperf.var991an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.VAR99 : '-';
              existingperf.var951an = yearsSinceValorisation[0].annee > 3 ? ratioData1an.data.VAR95 : '-';
              existingperf.trackingerror1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.trackingError : '-';
              existingperf.betahaussier1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.betaHaussier : '-';
              existingperf.betabaissier1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.betaBaiss : '-';
              existingperf.beta1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.beta : '-';
              existingperf.sortino1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.sortino : '-';
              existingperf.omega1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.omega : '-';
              existingperf.dsr1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.dsr : '-';
              existingperf.downcapture1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.DownCaptureRatio : '-';
              existingperf.upcapture1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.UpCaptureRatio : '-';
              existingperf.skewness1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.skewness : '-';
              existingperf.kurtosis1an = yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.kurtosis : '-';



              existingperf.perfannu3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.perfAnnualisee : '-';
              existingperf.volatility3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.volatility : '-';
              existingperf.ratiosharpe3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.ratioSharpe : '-';
              existingperf.pertemax3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.maxDrawdown : '-';
              existingperf.sortino3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.sortino : '-';
              existingperf.info3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.info : '-';
              existingperf.calamar3an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.calmar : '-';
              existingperf.var993an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.VAR99 : '-';
              existingperf.var953an = yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.VAR95 : '-';
              existingperf.trackingerror3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.trackingError : '-';
              existingperf.betahaussier3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.betaHaussier : '-';
              existingperf.betabaissier3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.betaBaiss : '-';
              existingperf.beta3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.beta : '-';
              existingperf.sortino3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.sortino : '-';
              existingperf.omega3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.omega : '-';
              existingperf.dsr3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.dsr : '-';
              existingperf.downcapture3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.DownCaptureRatio : '-';
              existingperf.upcapture3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.UpCaptureRatio : '-';
              existingperf.skewness3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.skewness : '-';
              existingperf.kurtosis3an = yearsSinceValorisation[0].annee > 1 ? ratioData3ans.data.kurtosis : '-';


              existingperf.perfannu5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.perfAnnualisee : '-';
              existingperf.volatility5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.volatility : '-';
              existingperf.ratiosharpe5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.ratioSharpe : '-';
              existingperf.pertemax5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.maxDrawdown : '-';
              existingperf.sortino5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.sortino : '-';
              existingperf.info5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.info : '-';
              existingperf.calamar5an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.calmar : '-';
              existingperf.var995an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.VAR99 : '-';
              existingperf.var955an = yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.VAR95 : '-';
              existingperf.trackingerror5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.trackingError : '-';
              existingperf.betahaussier5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.betaHaussier : '-';
              existingperf.betabaissier5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.betaBaiss : '-';
              existingperf.beta5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.beta : '-';
              existingperf.sortino5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.sortino : '-';
              existingperf.omega5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.omega : '-';
              existingperf.dsr5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.dsr : '-';
              existingperf.downcapture5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.DownCaptureRatio : '-';
              existingperf.upcapture5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.UpCaptureRatio : '-';
              existingperf.skewness5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.skewness : '-';
              existingperf.kurtosis5an = yearsSinceValorisation[0].annee > 1 ? ratioData5ans.data.kurtosis : '-';

              await existingperf.save();
            } else {

              // Insérer les données de performance et de ratio dans la table `performances`
              await performences_usds.create({
                date: currentDate,
                fond_id: fundId,
                anomalie: anomalie,
                code_ISIN: code_ISIN,
                categorie: performanceData.data.category,
                categorie_nationale: categorie_nationale,
                categorie_regionale: categorie_regionale,
                devise: fund.dev_libelle,
                lastdatepreviousmonth: performanceData.data.lastdatepreviousmonth,
                ytd: performanceData.data.perf1erJanvier,
                perfveille: performanceData.data.perfVeille,
                perf1an: performanceData.data.perf1An,
                perf3ans: performanceData.data.perf3Ans,
                perf5ans: performanceData.data.perf5Ans,
                perf8ans: performanceData.data.perf8Ans,
                perf10ans: performanceData.data.perf10Ans,
                perf4s: performanceData.data.perf4Semaines,
                perf3m: performanceData.data.perf3Mois,
                perf6m: performanceData.data.perf6Mois,

                perfannu1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.perfAnnualisee : '-',
                volatility1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.volatility : '-',
                ratiosharpe1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.ratioSharpe : '-',
                pertemax1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.maxDrawdown : '-',
                sortino1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.sortino : '-',
                info1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.info : '-',
                calamar1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.calmar : '-',
                var991an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.VAR99 : '-',
                var951an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.VAR95 : '-',
                trackingerror1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.trackingError : '-',
                betahaussier1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.betaHaussier : '-',
                betabaissier1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.betaBaiss : '-',
                beta1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.beta : '-',
                sortino1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.sortino : '-',
                omega1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.omega : '-',
                dsr1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.dsr : '-',
                downcapture1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.DownCaptureRatio : '-',
                upcapture1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.UpCaptureRatio : '-',
                skewness1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.skewness : '-',
                kurtosis1an: yearsSinceValorisation[0].annee > 1 ? ratioData1an.data.kurtosis : '-',



                perfannu3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.perfAnnualisee : '-',
                volatility3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.volatility : '-',
                ratiosharpe3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.ratioSharpe : '-',
                pertemax3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.maxDrawdown : '-',
                sortino3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.sortino : '-',
                info3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.info : '-',
                calamar3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.calmar : '-',
                var993an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.VAR99 : '-',
                var953an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.VAR95 : '-',
                trackingerror3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.trackingError : '-',
                betahaussier3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.betaHaussier : '-',
                betabaissier3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.betaBaiss : '-',
                beta3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.beta : '-',
                sortino3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.sortino : '-',
                omega3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.omega : '-',
                dsr3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.dsr : '-',
                downcapture3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.DownCaptureRatio : '-',
                upcapture3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.UpCaptureRatio : '-',
                skewness3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.skewness : '-',
                kurtosis3an: yearsSinceValorisation[0].annee > 3 ? ratioData3ans.data.kurtosis : '-',

                perfannu5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.perfAnnualisee : '-',
                volatility5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.volatility : '-',
                ratiosharpe5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.ratioSharpe : '-',
                pertemax5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.maxDrawdown : '-',
                sortino5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.sortino : '-',
                info5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.info : '-',
                calamar5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.calmar : '-',
                var995an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.VAR99 : '-',
                var955an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.VAR95 : '-',
                trackingerror5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.trackingError : '-',
                betahaussier5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.betaHaussier : '-',
                betabaissier5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.betaBaiss : '-',
                beta5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.beta : '-',
                sortino5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.sortino : '-',
                omega5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.omega : '-',
                dsr5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.dsr : '-',
                downcapture5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.DownCaptureRatio : '-',
                upcapture5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.UpCaptureRatio : '-',
                skewness5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.skewness : '-',
                kurtosis5an: yearsSinceValorisation[0].annee > 5 ? ratioData5ans.data.kurtosis : '-',

              });
            }

          } else {
            console.error(`Erreur lors de l'appel à l'API pour le fond avec l'ID ${fundId}`);
            //  }


          }
        }
      }
      console.log("finish");
      res.json("finish");
    } catch (error) {
      console.error('Une erreur s\'est produite :', error);
    }
  });

  //fonction avoir date vl manquante
  app.get('/dates-manquantes/:fundId', async (req, res) => {
    const fundId = req.params.fundId;
    const fund = await fond.findOne({ where: { id: fundId } });
    const periodicite = fund.periodicite; // Récupérer la périodicité depuis la requête si nécessaire

    try {
      const firstVlDate = await vl.min('date', { where: { fund_id: fundId } });
      const increment = periodicite === 'journaliere' ? 'days' : 'weeks';
      const missingDates = [];

      for (let date = moment(firstVlDate); date.isBefore(moment()); date.add(1, increment)) {
        // Si la périodicité est journalière et la date est un week-end, passer à la prochaine date
        if (periodicite === 'journaliere' && isWeekend(date)) {
          continue;
        }

        // Vérifier si la VL est manquante pour cette date
        const vlExists = await vl.findOne({ where: { fund_id: fundId, date: date.format('YYYY-MM-DD') } });

        // Si la VL n'existe pas, ajouter la date à la liste des dates manquantes
        if (!vlExists) {
          missingDates.push(date.format('YYYY-MM-DD'));
        }
      }

      res.json({ fundId: fundId, missingDates: missingDates });
    } catch (error) {
      console.error('Erreur lors de la récupération des dates manquantes :', error);
      res.status(500).json({ error: 'Erreur lors de la récupération des dates manquantes' });
    }
  });

  app.get('/dates-indRef-null/:fundId', async (req, res) => {
    const fundId = req.params.fundId;

    try {
      // Recherche du fond par ID
      const fund = await fond.findOne({ where: { id: fundId } });

      // Vérification si le fond existe
      if (!fund) {
        return res.status(404).json({ error: "Fond non trouvé" });
      }

      // Récupération des dates avec indRef null pour le fond donné
      const datesWithIndRefNull = await vl.findAll({
        where: {
          fund_id: fundId,
          indRef: null
        },
        attributes: ['date'], // Sélectionner uniquement la colonne 'date'
        raw: true // Retourner les résultats en tant qu'objets JavaScript
      });

      // Extraction des dates à partir des résultats
      const dates = datesWithIndRefNull.map(entry => entry.date);

      res.json({ fundId: fundId, datesWithIndRefNull: dates });
    } catch (error) {
      console.error('Erreur lors de la récupération des dates avec indRef null :', error);
      res.status(500).json({ error: 'Erreur lors de la récupération des dates avec indRef null' });
    }
  });

  // Fonction pour mettre à jour les performances
  async function executeGetperformenceAPI() {
    const fond1 = 637;
    const fond2 = 1600;

    // const apiUrl = 'http://exemple.com'; // Remplacez "exemple.com" par votre nom de domaine ou votre adresse IP

    try {
      // Effectuez une requête HTTP vers votre API en utilisant fetch
      const response = await fetch(`${urll}/api/saveperfdate1/${fond1}/${fond2}`);

      // Vérifiez si la requête a réussi (statut HTTP 200)
      if (response.ok) {
        // Convertissez la réponse en JSON
        const data = await response.json();
        console.log(data);
      } else {
        // Si la réponse n'est pas OK, lancez une erreur
        throw new Error('Erreur lors de la requête');
      }
    } catch (error) {
      console.error(error);
    }
  }



  // Utilisation de cron pour planifier l'exécution des fonctions
  cron.schedule('40 05 * * *', async () => {
    console.log('API /api/getportefeuille/ exécutée à 2h du matin');

    //  await executeGetperformenceAPI();
    // await executeGetclassementAPI();

    console.log('API /api/getportefeuille/ fin exécutée à 2h du matin');
  });
  app.use(bodyParser.json());
  app.post('/api/login', async (req, res) => {
    try {
      const didToken = req.headers.authorization?.substr(7);

      if (!didToken) {
        res.status(401).json({ error: 'Unauthorized' });
        return;
      }

      await magic.token.validate(didToken);
      res.status(200).json({ authenticated: true });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app.get('/api/getdateavailable/:id', async (req, res) => {
    try {
      const vldatas = await vl.findAll({
        where: {
          fund_id: req.params.id,
        },
        attributes: ['date'], // Specify the columns you want to retrieve
      });

      // Extracting the 'date' values from the result
      const dates = vldatas.map(vldata => vldata.date);
      res.json({ code: 200, data: dates });
    } catch (error) {
      res.status(500).send('Erreur lors de la récupération des dates');
    }
  });
  app.post('/api/managecash', async (req, res) => {

    try {
      const { portefeuilleselect, montant, type, date } = req.body[0];

      // Recherche de la transaction existante
      const existingTransaction = await portefeuille.findOne({
        where: {
          id: portefeuilleselect,
        },
      });
      let updatedTransaction;
      const currentCash = parseInt(existingTransaction.cash, 10) || 0;


      if (existingTransaction) {

        // Convert montant to an integer
        const montantValue = parseInt(montant, 10) || 0;

        if (type === 'ajoutcash') {
          updatedTransaction = await existingTransaction.update({
            cash: (currentCash + montantValue).toString(),
          });
          const createdcashdb = await cashdb.create({
            portefeuille_id: portefeuilleselect,
            montant: montantValue,
            date,
          });
        } else {
          updatedTransaction = await existingTransaction.update({
            cash: (currentCash - montantValue).toString(),
          });
          const createdcashdb = await cashdb.create({
            portefeuille_id: portefeuilleselect,
            montant: -montantValue,
            date,
          });
        }
      }

      const transactionsData = [{
        portefeuilleselect,
        type,
        montant,
        date,
      }];

      // Remplacez l'URL et le port par les valeurs correctes de votre environnement
      const baseUrl = urll; // Remplacez par votre URL de base

      const createTransactionsUrl = `${baseUrl}/api/createtransactions`;

      const response = await fetch(createTransactionsUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(transactionsData),
      });



      // Parse the response JSON
      const responseData = await response.json();

      // Utilisez la réponse comme nécessaire (peut-être ajoutez-la à votre réponse JSON)
      const { code, data } = responseData;

      return res.json({ code: 200, data: updatedTransaction, createTransactionsResponse: { code, data } });

    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Erreur lors de la création des transactions' });
    }
  });
  app.get('/api/vlpardate', async (req, res) => {
    const { fund_id, date } = req.query;

    try {
      const dateObject = new Date(date); // Assuming 'date' is a string representation of a date
      const isoDateString = dateObject.toISOString().substring(0, 10);
      const exchangeRates = await vl.findOne({
        where: {
          date: isoDateString,
          fund_id: parseInt(fund_id),

        },
      });

      if (!exchangeRates) {
        return res.status(404).json({ message: 'Exchange rates not found for the given date' });
      }

      res.json(exchangeRates);
    } catch (error) {
      console.error('Error fetching exchange rates from the database', error);
      res.status(500).json({ message: 'Internal Server Error' });
    }
  });

  app.get('/api/changedevise', async (req, res) => {
    const { paire, date } = req.query;

    try {
      const dateObject = new Date(date); // Assuming 'date' is a string representation of a date
      const isoDateString = dateObject.toISOString().substring(0, 10);
      const exchangeRates = await devisedechanges.findOne({
        where: {
          date: { [Op.lte]: isoDateString }, // Chercher la date la plus proche inférieure ou égale

          //date: isoDateString,
          paire: paire,

        },
      });

      if (!exchangeRates) {
        return res.status(404).json({ message: 'Exchange rates not found for the given date' });
      }

      res.json(exchangeRates.value);
    } catch (error) {
      console.error('Error fetching exchange rates from the database', error);
      res.status(500).json({ message: 'Internal Server Error' });
    }
  });
  app.post('/api/createtransactions', async (req, res) => {
    const transactionsData = req.body;

    try {
      const transactions = [];

      for (const transactionData of transactionsData) {
        const { portefeuilleselect, type, montant, date, fondId, quantiteachat } = transactionData;
        //   populatePortefeuilleVls(portefeuilleselect);
        let prixparunite;
        let existingTransaction;

        const portefeuilledata = await portefeuille.findOne({
          where: {
            id: portefeuilleselect,
          },
        });

        const fraisdata = await frais.findOne({
          where: {
            id: 1,
          },
        });



        if (type === 'achat' || type === 'vente') {
          const existingTransactions = await transaction.findAll({
            where: {
              type: 'achat',
              fond_ids: parseInt(fondId),
              date: {
                [Op.lte]: new Date(date)
              }
            }
          });

          // Calculate average purchase price
          let totalAmount = 0;
          let totalQuantity = 0;

          for (const existingTransaction of existingTransactions) {
            totalAmount += existingTransaction.prixparunite * existingTransaction.quantite;
            totalQuantity += existingTransaction.quantite;
          }

          const averagePurchasePrice = totalQuantity ? totalAmount / totalQuantity : 0;

          const vldata = await vl.findOne({
            where: {
              fund_id: fondId,
              date: date
            },
          });
          if (portefeuilledata.devise == "EUR") {
            prixparunite = vldata.value_EUR;
          } else {
            prixparunite = vldata.value_USD;

          }

          let quantiteachata;

          if (type === 'achat') {
            quantiteachata = (montant - (parseFloat(((montant * (fraisdata.frais_achat)) / 100)) + parseFloat(fraisdata.frais_transa_achat))) / prixparunite;

          }





          const currentCash = parseInt(portefeuilledata.cash, 10) || 0;
          // const montantValue = type=="achat"?(parseFloat(montant, 10) || 0)-(parseFloat(((montant*(fraisdata.frais_achat))/100))+parseFloat(fraisdata.frais_transa_achat)):(parseFloat(montant, 10) || 0)-(parseFloat(((prixparunite*quantiteachat*(fraisdata.frais_vente))/100)+parseFloat(fraisdata.frais_transa_vente)));
          const montantValue = type == "achat" ? (parseFloat(montant, 10) || 0) : parseFloat(averagePurchasePrice * quantiteachat);

          // Si la transaction existe, mettre à jour la quantité
          let updatedTransaction;
          if (type === 'achat') {

            portefeuilledata.update({ cash: (currentCash - montantValue).toString() });
            const createdcashdb = await cashdb.create({
              portefeuille_id: portefeuilleselect,
              montant: -montantValue,
              date,
            });
          } else if (type === 'vente') {
            /* updatedTransaction = await existingTransaction.update({
              quantite: existingTransaction.quantite - quantiteachat,
          });*/
            portefeuilledata.update({ cash: (currentCash + montantValue).toString() });
            const createdcashdb = await cashdb.create({
              portefeuille_id: portefeuilleselect,
              montant: montantValue,
              date,
            });
          }


          const funddata = await fond.findOne({
            where: {
              id: fondId,
            },
          });

          // Si la transaction n'existe pas, créer une nouvelle transaction
          const createdTransaction = await transaction.create({
            portefeuille_id: portefeuilleselect,
            type,
            montant: type == "achat" ? montant : prixparunite * quantiteachat,
            date,
            fond_ids: parseInt(fondId, 10),
            prixparunite,
            devise: funddata.dev_libelle,
            quantite: type == "achat" ? quantiteachata : quantiteachat,
            frais_entree: type == "achat" ? parseFloat(((montant * (fraisdata.frais_achat)) / 100)) : 0,
            frais_sortie: type == "vente" ? parseFloat(((prixparunite * quantiteachat * (fraisdata.frais_vente)) / 100)) : 0,
            frais_transaction: type == "achat" ? parseFloat(fraisdata.frais_transa_achat) : parseFloat(fraisdata.frais_transa_vente),
            frais: type == "achat" ? parseFloat(((montant * (fraisdata.frais_achat)) / 100)) + parseFloat(fraisdata.frais_transa_achat) : parseFloat(((prixparunite * quantiteachat * (fraisdata.frais_vente)) / 100) + parseFloat(fraisdata.frais_transa_vente)),
            average: averagePurchasePrice,
            invest: type == "vente" ? averagePurchasePrice * quantiteachat : 0,
            plus_moins_value: type == "vente" ? (parseFloat(prixparunite * quantiteachat) - parseFloat(((prixparunite * quantiteachat * (fraisdata.frais_vente)) / 100) + parseFloat(fraisdata.frais_transa_vente))) - (averagePurchasePrice * quantiteachat) : 0
          });

          transactions.push(createdTransaction);
          await valorisePortefeuilleVls(portefeuilleselect, createdTransaction)
          //  }
        } else if (type === 'ajoutcash' || type === 'retraitcash') {
          const createdTransaction = await transaction.create({
            portefeuille_id: portefeuilleselect,
            type,
            montant,
            date,
            // fond_ids: parseInt(fondId, 10),
            //  prixparunite,
            //   quantite: quantiteachat,
          });

          transactions.push(createdTransaction);
        }
      }

      return res.json({ code: 200, data: transactions });
    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Erreur lors de la création des transactions' });
    }
  });


  app.get('/api/gettransactions/:id', async (req, res) => {
    try {
      const response = await transaction.findAll({
        where: {
          portefeuille_id: req.params.id,
          // ...
        },
        include: [{
          model: fond,
          attributes: ['nom_fond'], // Sélectionner seulement le nom du fond, vous pouvez ajouter d'autres attributs si nécessaire
        },
        {
          model: portefeuille,
          attributes: ['devise'], // Sélectionner seulement le nom du fond, vous pouvez ajouter d'autres attributs si nécessaire
        },

        ],
        order: [['date', 'ASC']]
      });
      const transactions = await Promise.all(response.map(async (data) => {
        const paire = `${data.portefeuille.devise}/${data.devise}`;

        const tauxChange = await devisedechanges.findOne({
          where: {
            date: {
              [Sequelize.Op.lte]: data.date // Cherche la date la plus proche ou égale
            },
            paire: paire
          },
          order: [['date', 'DESC']], // Trie par date décroissante pour obtenir le dernier
          attributes: ['value']
        });

        return {
          id: data.id,
          type: data.type,
          date: data.date,
          montant: data.montant,
          fond_ids: data.fond_ids,
          prixparunite: data.prixparunite,
          portefeuille_id: data.portefeuille_id,
          quantite: data.quantite,
          frais: data.frais,
          frais_transaction: data.frais_transaction,
          frais_sortie: data.frais_sortie,
          frais_entree: data.frais_entree,
          plus_moins_value: data.plus_moins_value,
          average:data.average,
          devise: data.devise,
          nom_fond: data.fond_investissement ? data.fond_investissement.nom_fond : null, // Vérifie si fond existe
          taux: tauxChange ? tauxChange.value : null // Vérifie si tauxChange existe
        };
      }));


      res.json({
        code: 200,
        data: {
          transactions,
        }
      });
    } catch (error) {
      console.error("Une erreur s'est produite :", error);
      res.status(500).json({ message: 'Erreur interne du serveur' });
    }
  });
  app.post('/api/valoriserportefeuille/:id', async (req, res) => {
    try {
      const portefeuill = await portefeuille.findOne({
        where: {
          id: parseInt(req.params.id),
        },
      });


      const valos = await portefeuille_vl.findAll({
        where: {
          portefeuille_id: parseInt(req.params.id),
        },
        order: [['date', 'ASC']], // Order transactions by date ascending
      });
      await cumulvl(valos, req.params.id)
      await portefeuille.update({ maj: 1 }, {
        where: {
          id: parseInt(req.params.id),
        },
      });
      return res.json({ code: 200, data: "succes" });

    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Erreur lors de la création des transactions' });
    }
  });
  app.get('/api/exportToExcel', async (req, res) => {
    try {
      const id = req.query.id;
      const formattedDate = req.query.formattedDate; // Corrected variable name
      const formattedDate1 = req.query.formattedDate1; // Corrected variable name

      // Fetch data from the database for the past 1 year
      // const startDate = new Date();
      // startDate.setFullYear(startDate.getFullYear() - 1);

      const exportedData = await vl.findAll({
        where: {
          fund_id: parseInt(id),
          date: {
            //   [Sequelize.Op.gte]: Sequelize.literal('DATE_SUB((SELECT MAX(date) FROM valorisations WHERE fund_id = :fundId), INTERVAL 1 YEAR)'),
            [Sequelize.Op.between]: [formattedDate, formattedDate1],

          },
        },
        replacements: { fundId: req.params.id },
      });

      // Convert the data to Excel format
      const excelData = exportedData.map((item) => ({
        Date: item.date,
        Value: item.value,
      }));

      // Send the Excel data as JSON
      res.json(excelData);
    } catch (error) {
      console.error('Error exporting data:', error);
      res.status(500).json({ error: 'Internal Server Error' });
    }
  });
  app.get('/api/favoritesdataall/:id', async (req, res) => {
    try {

      const favoritesData = await favorisfonds.findAll({

        where: {
          // fond_ididids: { [Sequelize.Op.not]: null }, // Filter out transactions where fundid is null
          // user_id: parseInt(req.params.id),
          user_id: parseInt(req.params.id),

          // date: { [Sequelize.Op.lte]: Sequelize.literal('CURRENT_DATE') }, // Transactions on or before today
        },

      });
      if (favoritesData.length > 0) {
        res.json({ success: true, data: favoritesData });

      } else {
        res.json(null);

      }
    } catch (error) {
      res.status(500).json({ success: false, error: error.message });
    }
  });
  app.get('/api/favoritesdata/:id', async (req, res) => {
    try {

      const favoritesData = await favorisfonds.findAll({

        where: {
          // fond_ididids: { [Sequelize.Op.not]: null }, // Filter out transactions where fundid is null
          // user_id: parseInt(req.params.id),
          fund_id: parseInt(req.params.id),

          // date: { [Sequelize.Op.lte]: Sequelize.literal('CURRENT_DATE') }, // Transactions on or before today
        },

      });
      if (favoritesData.length > 0) {
        res.json({ success: true, data: favoritesData });

      } else {
        res.json({ success: false, data: null });

      }
    } catch (error) {
      res.status(500).json({ success: false, error: error.message });
    }
  });
  app.post('/api/favorites/add', async (req, res) => {
    try {
      const { fund_id, user_id } = req.body;

      favorisfonds.create({
        fund_id: parseInt(fund_id),
        user_id: parseInt(user_id),

      });
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ success: false, error: error.message });
    }
  });

  // Endpoint pour supprimer un fond des favoris
  app.get('/api/favorites/remove/:fundId/:userId', async (req, res) => {
    try {
      const { fundId, userId } = req.params;

      await favorisfonds.destroy({
        where: {
          fund_id: parseInt(fundId), user_id: parseInt(userId)

        }, truncate: false
      });
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ success: false, error: error.message });
    }
  });

  app.get('/api/portefeuillebase100/:id', async (req, res) => {
    try {
      const portefeuilleDatas = await getportefeuilleData(parseInt(req.params.id));
      const investissement = portefeuilleDatas[portefeuilleDatas.length - 1].investissement
      const plusmoinsvalue = portefeuilleDatas[portefeuilleDatas.length - 1].plus_moins_value
      const valeur = portefeuilleDatas[portefeuilleDatas.length - 1].valeur_portefeuille
      const date = portefeuilleDatas[portefeuilleDatas.length - 1].date
      const id = portefeuilleDatas[portefeuilleDatas.length - 1].id


      return res.json({ code: 200, data: { portefeuilleDatas, investissement, plusmoinsvalue, valeur, date, id } });

    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Erreur lors de la création des transactions' });
    }
  });
  app.get('/api/portefeuillebase100dev/:id/:dev', async (req, res) => {
    try {
      const portefeuilleDatas = await getportefeuilleData(parseInt(req.params.id));
      const investissement = req.params.dev === 'EUR' ? portefeuilleDatas[portefeuilleDatas.length - 1].investissement_EUR : portefeuilleDatas[portefeuilleDatas.length - 1].investissement_USD;
      //const investissement=portefeuilleDatas[portefeuilleDatas.length-1].investissement
      const plusmoinsvalue = req.params.dev === 'EUR' ? portefeuilleDatas[portefeuilleDatas.length - 1].plus_moins_value_EUR : portefeuilleDatas[portefeuilleDatas.length - 1].plus_moins_value_USD
      const valeur = req.params.dev === 'EUR' ? portefeuilleDatas[portefeuilleDatas.length - 1].valeur_portefeuille_EUR : portefeuilleDatas[portefeuilleDatas.length - 1].valeur_portefeuille_USD
      const date = portefeuilleDatas[portefeuilleDatas.length - 1].date
      const id = portefeuilleDatas[portefeuilleDatas.length - 1].id
      const cash = req.params.dev === 'EUR' ? portefeuilleDatas[portefeuilleDatas.length - 1].cash_EUR : portefeuilleDatas[portefeuilleDatas.length - 1].cash_USD;


      return res.json({ code: 200, data: { portefeuilleDatas, investissement, cash, plusmoinsvalue, valeur, date, id } });

    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Erreur lors de la création des transactions' });
    }
  });
  app.get('/api/portefeuillebase100s', async (req, res) => {
    try {
      const portefeuilleDatas = await getportefeuilleDatas();


      return res.json({ code: 200, data: { portefeuilleDatas } });

    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Erreur lors de la création des transactions' });
    }
  });

  /*
  async function calculerPerformanceTotale(portfolioId) {
  const transactions = await Transaction.findAll({ where: { portfolioId } });
  // Logique pour calculer la performance totale basée sur les transactions
  }*/



  function getDatesInRange(startDate, endDate) {
    const start = new Date(startDate);
    const end = new Date(endDate);

    const workingDatesInRange = [];

    // Boucle pour générer les dates dans l'intervalle
    for (let currentDate = start; currentDate <= end; currentDate.setDate(currentDate.getDate() + 1)) {
      // Vérifier si le jour actuel n'est pas un weekend (lundi à vendredi)
      if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6) {
        const formattedDate = currentDate.toISOString().split('T')[0];
        workingDatesInRange.push(formattedDate);
      }
    }

    return workingDatesInRange;
  }
  function obtenirDerniereVL(fundVLs, date) {
    // Si la VL pour la date est disponible, on la retourne


    // Sinon, on cherche la VL la plus récente avant cette date
    const datesDisponibles = fundVLs.filter(d => d.date <= date);
    const derniereDate = datesDisponibles.sort().reverse()[0];
    return fundVLs.find(fund => fund.id === derniereDate.id);
  }

  async function getportefeuilleData(portefeuilleId) {
    try {
      const transactions = await portefeuille_vl_cumul.findAll({
        where: {
          portefeuille_id: portefeuilleId
        },
        order: [
          ['date', 'ASC']
        ]
      });
      return transactions;
    } catch (error) {
      throw new Error("Erreur lors de la récupération des transactions : " + error.message);
    }
  }
  async function getportefeuilleDatas() {
    try {
      const transactions = await portefeuille_vl_cumul.findAll({

        order: [
          ['portefeuille_id', 'ASC'],
          ['date', 'ASC']
        ]
      });
      return transactions;
    } catch (error) {
      throw new Error("Erreur lors de la récupération des transactions : " + error.message);
    }
  }


  // Function to valorize and populate the portfolio_vls table
  async function valorisePortefeuilleVls(portefeuilleId, transactionp) {
    try {
      /* await portefeuille_vl.destroy({ where: {portefeuille_id: parseInt(portefeuilleId),
   
       }, truncate: true });*/


      const valorisations = [];
      // Fetch transactions for the given portfolio
      const portfolioTransactions = await transaction.findAll({
        where: {
          fond_ids: { [Sequelize.Op.not]: null }, // Filter out transactions where fundid is null
          portefeuille_id: parseInt(portefeuilleId),
        },
        order: [['date', 'ASC']], // Order transactions by date ascending
      });

      const portefeuilleselect = await portefeuille.findOne({
        where: {
          // fond_ididids: { [Sequelize.Op.not]: null }, // Filter out transactions where fundid is null
          id: parseInt(portefeuilleId),
          // date: { [Sequelize.Op.lte]: Sequelize.literal('CURRENT_DATE') }, // Transactions on or before today
        },
        //order: [['date', 'ASC']], // Order transactions by date ascending
      });

      // Calculate and populate the portfolio_vls table for each transaction
      const valuesToInsert = {};
      // let quantiteCumulee;
      const mostRecentDatesandfund = []; // Assurez-vous que mostRecentDatesandfund est défini comme un tableau

      //Recherche de la date de Vl la plus recente
      const distinctFundIds = parseInt(transactionp.fond_ids);

      // Fetch the most recent VL for each fund in a single query
      const mostRecentVLs = await vl.findAll({
        attributes: ['fund_id', [Sequelize.fn('MAX', Sequelize.col('date')), 'mostRecentDate']],
        where: {
          fund_id: distinctFundIds,
        },
        group: ['fund_id'],
        order: [[Sequelize.literal('mostRecentDate ASC')]], // Order by mostRecentDate in descending order
        limit: 1, // Limit to get only the most recent VL for each fund
        raw: true, // This ensures that the result is plain JSON objects, not Sequelize model instances
      });
      if (mostRecentVLs.length > 0) {
        mostRecentDatesandfund.push({
          date: mostRecentVLs[0].mostRecentDate,
          fund_id: mostRecentVLs[0].fund_id,
        });
      }
      // Create an array to store promises for each transaction
      //const portfolioPromises = portfolioTransactions.map(async (transaction, index) => {
      const currentDate = transactionp.date;



      let totalValue;
      let quantiteCumulee = transactionp.quantite;

      const startDate = transactionp.date;

      const fundVLs = await vl.findAll({
        where: {
          fund_id: parseInt(transactionp.fond_ids),
        },
        order: [['date', 'ASC']], // Order VLs by date ascending
        distinct: true,
      });

      const fundVLsvente = await vl.findOne({
        where: {
          fund_id: parseInt(transactionp.fond_ids),
          date: transactionp.date
        },
        order: [['date', 'ASC']], // Order VLs by date ascending
        distinct: true,
      });
      const distinctFundIdss = portefeuilleselect.fundids.replace(/[^0-9A-Za-z\s,]+/g, '').split(',')
      const distinctFundIdsParsed = distinctFundIdss.map(id => parseInt(id));

      const commonDates = await vl.findAll({
        attributes: ['date'],
        where: {
          fund_id: distinctFundIdsParsed
        },
        group: ['date'],
        having: Sequelize.literal(`COUNT(DISTINCT fund_id) = ${distinctFundIdss.length}`),
        order: [['date', 'DESC']],
        limit: 1,
        raw: true
      });

      const existingTransactions = await transaction.findAll({
        where: {
          type: 'achat',
          fond_ids: parseInt(transactionp.fond_ids),
          date: {
            [Op.lte]: new Date(transactionp.date)
          }
        }
      });

      // Calculate average purchase price
      let totalAmount = 0;
      let totalQuantity = 0;

      for (const existingTransaction of existingTransactions) {
        totalAmount += existingTransaction.prixparunite * existingTransaction.quantite;
        totalQuantity += existingTransaction.quantite;
      }

      const averagePurchasePrice = totalQuantity ? totalAmount / totalQuantity : 0;

      //  const dates = getDatesInRange(startDate, new Date());
      const dates = commonDates.length ? getDatesInRange(startDate, commonDates[0].date) : getDatesInRange(startDate, new Date());
      for (const date of dates) {
        const fundVL = obtenirDerniereVL(fundVLs, date)
        if (fundVL) {
          // Assuming transactionps is an array of transactionps



          if (transactionp.type === 'achat') {
            if (portefeuilleselect.devise == "EUR") {
              totalValue = transactionp.quantite * fundVL.value_ajuste_EUR; //todo

            } else {
              totalValue = transactionp.quantite * fundVL.value_ajuste_USD; //todo

            }
          } else if (transactionp.type === 'vente') {
            if (portefeuilleselect.devise == "EUR") {
              totalValue = -transactionp.quantite * fundVL.value_ajuste_EUR; //todo

            } else {
              totalValue = -transactionp.quantite * fundVL.value_ajuste_USD; //todo

            }
            // averagePrice = calculateAveragePrice(portfolioTransactions, transactionp.date);

            // totalValue = -transactionp.quantite * averagePrice;


          }

          const result1 = await cashdb.findAll({
            attributes: [
              'portefeuille_id',
              [Sequelize.fn('SUM', Sequelize.col('montant')), 'totalMontant'],
            ],
            where: {
              date: { [Sequelize.Op.lte]: date },
              portefeuille_id: parseInt(portefeuilleId),
            },
            group: ['portefeuille_id'],
            raw: true,
          });

          const totalMontant = result1.length > 0 ? result1[0].totalMontant : 0;
          const cashhhh = parseFloat(totalMontant) + parseFloat(totalValue);
          let exchangeRates = await devisedechanges.findOne({
            where: {
              date: { [Op.lte]: date }, // Chercher la date la plus proche inférieure ou égale
              //date: date,
              paire: 'EUR/USD',
            },
            order: [['date', 'DESC']] // Tri par date descendant
          });

          // Si aucune entrée n'est trouvée pour la date spécifiée et la paire de devises 'EUR/USD'
          if (!exchangeRates) {
            // Recherche de la dernière entrée dans la base de données
            exchangeRates = await devisedechanges.findOne({
              where: {
                paire: 'EUR/USD',
              },
              order: [['date', 'DESC']] // Tri par date descendant
            });
          }

          const montantdepense = transactionp.quantite * transactionp.prixparunite + transactionp.frais;
          valorisations.push({
            date: date,
            //     value: transactionp.type === 'achat' ? cashhhh : totalValue,
            valeur_jour: totalValue,
            valeur_jour_EUR: portefeuilleselect.devise == 'EUR' ? totalValue : totalValue / exchangeRates.value,
            valeur_jour_USD: portefeuilleselect.devise == 'USD' ? totalValue : totalValue * exchangeRates.value,
            cash: totalMontant,
            cash_EUR: portefeuilleselect.devise == 'EUR' ? totalMontant : totalMontant / exchangeRates.value,
            cash_USD: portefeuilleselect.devise == 'USD' ? totalMontant : totalMontant * exchangeRates.value,
            montantdepense: transactionp.type === 'achat' ? montantdepense : 0,
            frais: transactionp.type === 'achat' ? -transactionp.frais : -transactionp.frais,
            investissement: transactionp.type === 'achat' ? transactionp.quantite * transactionp.prixparunite : -transactionp.quantite * averagePurchasePrice,
            investissement_EUR: portefeuilleselect.devise == 'EUR' ? (transactionp.quantite * transactionp.prixparunite) : (transactionp.quantite * averagePurchasePrice) / exchangeRates.value,
            investissement_USD: portefeuilleselect.devise == 'USD' ? (transactionp.quantite * transactionp.prixparunite) : (transactionp.quantite * averagePurchasePrice) * exchangeRates.value,
            vl: portefeuilleselect.devise == 'EUR' ? fundVL.value_EUR : fundVLsvente.value_USD,
            quantite: transactionp.type === 'achat' ? transactionp.quantite : -transactionp.quantite,
            fund_id: transactionp.fond_ids,
            prix_moyen: averagePurchasePrice,
            portefeuille_id: parseInt(portefeuilleId),
          });
        }
      }

      //  });

      // Wait for all promises to complete before proceeding
      // await Promise.all(portfolioPromises);

      await portefeuille_vl.bulkCreate(valorisations);





      console.log('Portefeuille_vls table populated successfully.');
    } catch (error) {
      console.error('Error populating portfolio_vls table:', error);
      throw error;
    }
  }

  //Prix moyen a la vente
  function calculateAveragePrice(transactions, saleDate) {
    let totalCost = 0;
    let totalQuantity = 0;

    // Filtrer les transactions d'achat jusqu'à la date de vente
    const purchases = transactions.filter(transaction =>
      transaction.type === 'achat' && new Date(transaction.date) <= new Date(saleDate)
    );

    // Calculer le coût total et la quantité totale des achats
    for (const purchase of purchases) {
      totalCost += purchase.prixparunite * purchase.quantite;
      totalQuantity += purchase.quantite;
    }

    // Calculer le prix moyen pondéré
    const averagePrice = totalQuantity ? (totalCost / totalQuantity) : 0;

    return averagePrice;
  }


  async function cumulvl(valorisations, portefeuilleId) {
    await portefeuille_vl_cumul.destroy({ where: { portefeuille_id: parseInt(portefeuilleId), }, truncate: false });
    await portefeuille_base100.destroy({ where: { portefeuille_id: parseInt(portefeuilleId), }, truncate: false });

    // Continue with the rest of the code
    let aggregateValues = {};
    valorisations.forEach((valo) => {
      const date = valo.date;

      if (aggregateValues[date]) {
        aggregateValues[date].valeur_jour = parseFloat(aggregateValues[date].valeur_jour) + parseFloat(valo.valeur_jour);
        aggregateValues[date].investissement = parseFloat(aggregateValues[date].investissement) + parseFloat(valo.investissement);
        aggregateValues[date].valeur_jour_EUR = parseFloat(aggregateValues[date].valeur_jour_EUR) + parseFloat(valo.valeur_jour_EUR);
        aggregateValues[date].investissement_EUR = parseFloat(aggregateValues[date].investissement_EUR) + parseFloat(valo.investissement_EUR);
        aggregateValues[date].valeur_jour_USD = parseFloat(aggregateValues[date].valeur_jour_USD) + parseFloat(valo.valeur_jour_USD);
        aggregateValues[date].investissement_USD = parseFloat(aggregateValues[date].investissement_USD) + parseFloat(valo.investissement_USD);
        aggregateValues[date].quantite = parseFloat(aggregateValues[date].quantite) + parseFloat(valo.quantite);

      } else {
        aggregateValues[date] = {
          date: valo.date,
          valeur_jour: valo.valeur_jour,
          valeur_jour_EUR: valo.valeur_jour_EUR,
          valeur_jour_USD: valo.valeur_jour_USD,
          quantite: valo.quantite,
          //  fund_id: valo.fund_id,
          portefeuille_id: valo.portefeuille_id,
          cash: valo.cash,
          cash_EUR: valo.cash_EUR,
          cash_USD: valo.cash_USD,

          //   montantdepense:valo.montantdepense,
          //   frais:valo.frais,
          investissement: valo.investissement,
          investissement_EUR: valo.investissement_EUR,
          investissement_USD: valo.investissement_USD,

          //   plus_moins_value:valo.valeur_jour-parseFloat(valo.investissement),
          //   vl:valo.vl,
          //   quantite:valo.quantite,
        };
      }
    });

    // Continue with the rest of your code after the portfolio-related queries are completed


    // Convertir 'aggregateValues' en tableau
    const aggregatedArray = Object.values(aggregateValues);


    for (const valo of aggregatedArray) {
      const date = valo.date;

      const result2 = await cashdb.findAll({
        attributes: [
          'portefeuille_id',
          [Sequelize.fn('SUM', Sequelize.col('montant')), 'totalMontant'],
        ],
        where: {
          date: { [Sequelize.Op.lte]: date },
          portefeuille_id: parseInt(portefeuilleId),
        },
        group: ['portefeuille_id'],
        raw: true,
      });
      const portefeuilleselect = await portefeuille.findOne({
        where: {
          // fond_ididids: { [Sequelize.Op.not]: null }, // Filter out transactions where fundid is null
          id: parseInt(portefeuilleId),
          // date: { [Sequelize.Op.lte]: Sequelize.literal('CURRENT_DATE') }, // Transactions on or before today
        },
        //order: [['date', 'ASC']], // Order transactions by date ascending
      });

      let exchangeRates = await devisedechanges.findOne({
        where: {
          date: { [Op.lte]: date }, // Chercher la date la plus proche inférieure ou égale

          //  date: date,
          paire: 'EUR/USD',
        },
        order: [['date', 'DESC']] // Tri par date descendant
      });

      // Si aucune entrée n'est trouvée pour la date spécifiée et la paire de devises 'EUR/USD'
      if (!exchangeRates) {
        // Recherche de la dernière entrée dans la base de données
        exchangeRates = await devisedechanges.findOne({
          where: {
            paire: 'EUR/USD',
          },
          order: [['date', 'DESC']] // Tri par date descendant
        });
      }
      const totalMontant = result2.length > 0 ? result2[0].totalMontant : 0;
      let totalMontant_EUR;
      let totalMontant_USD;

      if (portefeuilleselect.devise == 'EUR') {
        totalMontant_EUR = totalMontant;
        totalMontant_USD = totalMontant_EUR * exchangeRates.value;
      } else {
        totalMontant_USD = totalMontant;
        totalMontant_EUR = totalMontant_USD / exchangeRates.value
      }

      // Modify the 'cash' property of the current object in aggregatedArray
      valo.valeur_portefeuille = valo.valeur_jour + totalMontant;
      valo.valeur_portefeuille_EUR = valo.valeur_jour_EUR + totalMontant_EUR;
      valo.valeur_portefeuille_USD = valo.valeur_jour_USD + totalMontant_USD;

      valo.plus_moins_value = valo.valeur_jour - valo.investissement;
      valo.plus_moins_value_EUR = valo.valeur_jour_EUR - valo.investissement_EUR;
      valo.plus_moins_value_USD = valo.valeur_jour_USD - valo.investissement_USD;

      // Do something with cashhhh or perform other operations...
    }



    await portefeuille_vl_cumul.bulkCreate(aggregatedArray)
    const transactionDatas = await getTransactionData(parseInt(portefeuilleId));
    const portefeuilleDatas = await getportefeuilleData(parseInt(portefeuilleId));


    let lastValuep = portefeuilleDatas[0].valeur_portefeuille; // Dernière valeur

    const base100Datas = portefeuilleDatas.map((item) => ({
      dates: item.date,
      base_100: (item.valeur_portefeuille / lastValuep) * 100,
      portefeuille_id: parseInt(portefeuilleId),
      //  valeur_portefeuille:item.valeur_portefeuille
    }));


    for (let index = 0; index < transactionDatas.length; index++) {
      const transaction = transactionDatas[index];
      console.log("rffffff");

      if (index !== 0) {
        if (transaction.type === 'ajoutcash') {

          lastValuep += parseFloat(transaction.montant);
          console.log("lastValue");

          console.log(lastValuep);

        }
        if (transaction.type === 'retraitcash') {
          lastValuep -= transaction.montant

        }


        const indexe = portefeuilleDatas.findIndex((item) => item.date === transaction.date);
        console.log("datasgraph[indexe]")
        console.log(indexe)

        for (let i = indexe; i < base100Datas.length; i++) {
          base100Datas[i].base_100 = (portefeuilleDatas[i].valeur_portefeuille / lastValuep) * 100;
        }
      }


    };


    for (let i = 0; i < base100Datas.length; i++) {
      const exchangeRates = await devisedechanges.findOne({
        where: {
          date: { [Op.lte]: base100Datas[i].dates }, // Chercher la date la plus proche inférieure ou égale

          //  date: base100Datas[i].dates,
          paire: 'EUR/MAD',

        },
      });
      const exchangeRates1 = await devisedechanges.findOne({
        where: {
          date: { [Op.lte]: base100Datas[i].dates }, // Chercher la date la plus proche inférieure ou égale

          //  date: base100Datas[i].dates,
          paire: 'USD/MAD',

        },
      });
      await portefeuille_vl_cumul.update(
        {
          base_100: base100Datas[i].base_100, base_100_bis: (portefeuilleDatas[i].valeur_jour / parseFloat(portefeuilleDatas[i].investissement)) * 100,
          base_100_bis_2: (portefeuilleDatas[i].valeur_portefeuille / parseFloat(portefeuilleDatas[i].investissement)) * 100,
          base_100_bis_EUR: (portefeuilleDatas[i].valeur_jour_EUR / parseFloat(portefeuilleDatas[i].investissement_EUR)) * 100,
          base_100_bis_USD: (portefeuilleDatas[i].valeur_jour_USD / parseFloat(portefeuilleDatas[i].investissement_USD)) * 100
        },
        {
          where: {
            date: base100Datas[i].dates,
            portefeuille_id: base100Datas[i].portefeuille_id,
          },
        }
      );
    }

  }

  //Fonction de calcule de la performance du portefeuille
  function calculateTotalPerformance(portfolioTransactions) {
    let totalInvestment = 0;
    let currentPortfolioValue = 0;

    portfolioTransactions.forEach(transaction => {
      if (transaction.type === 'achat') {
        totalInvestment += transaction.amount;
        currentPortfolioValue += transaction.currentValue; // Supposons que chaque transaction a une propriété 'currentValue'
      } else if (transaction.type === 'vente') {
        totalInvestment -= transaction.amount;
        currentPortfolioValue -= transaction.currentValue;
      }
    });

    return {
      totalInvestment,
      currentPortfolioValue,
      performance: ((currentPortfolioValue - totalInvestment) / totalInvestment) * 100
    };
  }
  //fonction de calcul de la plus ou moins value
  const calculatePortfolioPerformance = async (portfolioId) => {
    const portfolio = await Portfolio.findByPk(portfolioId);
    const transactions = await portfolio.getTransactions();
    let performance = 0;

    transactions.forEach((transaction) => {
      if (transaction.type === 'vente') {
        performance += transaction.montant - transaction.prixUnitaire * transaction.quantite;
      }
    });

    return performance;
  };
  //gestion des achats et ventes
  const handleOPCVMTransactions = async (transactionData) => {
    const { portfolioId, type, opcvmId, quantite, prixUnitaire, frais } = transactionData;
    const portfolio = await Portfolio.findByPk(portfolioId);
    const opcvm = await OPCVMNavData.findByPk(opcvmId);

    if (type === 'achat') {
      // Logique pour gérer l'achat d'OPCVM
      const montantTotal = quantite * prixUnitaire + frais;
      await Transaction.create({ portfolioId, type, opcvmId, quantite, prixUnitaire, montant: montantTotal });
      // Mise à jour du portefeuille
    } else if (type === 'vente') {
      // Logique pour gérer la vente d'OPCVM
      const montantTotal = quantite * prixUnitaire - frais;
      await Transaction.create({ portfolioId, type, opcvmId, quantite, prixUnitaire, montant: montantTotal });
      // Mise à jour du portefeuille
    }

    // Mise à jour des investissements
  };
  ///////gestion de la valorisation
  //Calcul de la Valeur Totale du Portefeuille
  async function calculatePortfolioValue(portfolioId, date) {
    const investments = await Investment.findAll({
      where: { portfolioId: portfolioId, date: { [Sequelize.Op.lte]: date } },
      include: [{ model: OPCVM, as: 'opcvms' }]
    });

    let totalValue = 0;
    investments.forEach(investment => {
      const nav = investment.opcvms.find(opcvm => opcvm.navDate === date)?.navValue || 0;
      totalValue += investment.quantity * nav;
    });

    return totalValue;
  }

  //Calcul de la Plus-Value par Titre
  async function calculateInvestmentGain(investmentId, date) {
    const investment = await Investment.findByPk(investmentId, {
      include: [{ model: OPCVM, as: 'opcvms' }]
    });

    const purchaseNav = investment.purchasePrice;
    const currentNav = investment.opcvms.find(opcvm => opcvm.navDate === date)?.navValue || 0;
    const gain = (currentNav - purchaseNav) * investment.quantity;

    return gain;
  }

  //Calcul de la Plus-Value Globale
  async function calculateTotalGain(portfolioId, date) {
    const investments = await Investment.findAll({
      where: { portfolioId: portfolioId },
      include: [{ model: OPCVM, as: 'opcvms' }]
    });

    let totalGain = 0;
    for (const investment of investments) {
      const gain = await calculateInvestmentGain(investment.id, date);
      totalGain += gain;
    }

    return totalGain;
  }

  /////////
  //fonction de calcul du rendement
  function calculateTotalYield(portfolioTransactions) {
    let initialInvestment = portfolioTransactions[0].amount;
    let currentPortfolioValue = portfolioTransactions[portfolioTransactions.length - 1].currentValue;

    return ((currentPortfolioValue - initialInvestment) / initialInvestment) * 100;
  }

  //fonction de valorisation du portefeuille
  function valorizePortfolio(portfolioTransactions) {
    return portfolioTransactions.map(transaction => {
      // Supposons que 'transactionValue' est la valeur de la transaction à la date de transaction
      let transactionValue = transaction.amount * transaction.price;
      return {
        date: transaction.date,
        value: transactionValue
      };
    });
  }
  //fonction de gestion des cashs
  function manageCashFlows(portfolioTransactions) {
    let cashFlow = 0;

    portfolioTransactions.forEach(transaction => {
      if (transaction.type === 'ajout_cash') {
        cashFlow += transaction.amount;
      } else if (transaction.type === 'retrait_cash') {
        cashFlow -= transaction.amount;
      }
    });

    return cashFlow;
  }

  //fonction pour deduire les frais du portefeuille
  async function deduireFraisDuPortefeuille(portfolioId, montantFrais) {
    const portfolio = await Portfolio.findByPk(portfolioId);
    portfolio.balance -= montantFrais;
    await portfolio.save();
  }


  //fonction valorsation
  async function valorisationportefeuille(portfolioId, montantFrais) {
    const valorisations = [];
    let montantInvestissement = 0;
    for (const entry of req.body) {
      const { date, montantInvesti, fondId, portefeuilleselect } = entry;
      montantInvestissement += montantInvesti
      // Rechercher la valeur du fond pour la date spécifiée
      let vls = await vl.findAll({
        where: {
          fund_id: fondId, date: {
            [Op.gte]: date // Remplacez 'votreDate' par la date que vous souhaitez comparer.
          }
        }
      });
      const quantite = montantInvesti / vls[0].value;

      for (const dateRow of vls) {

        const valorisation = quantite * dateRow.value;
        valorisations.push({ date: dateRow.date, value: valorisation, fund_id: fondId, portefeuille_id: portefeuilleselect });

      }
      // Insérer les nouvelles valorisations dans la table vl_portefeuille
      await portefeuille_vl.bulkCreate(valorisations);
    }

    const updatedData = {
      montant_invest: montantInvestissement
    };

    // Assuming 'portefeuille' is your model for updating data in your database
    await portefeuille.update(updatedData, {
      where: { id: portefeuille },
    });
    return null;
  }


  //valorisation reconstitution
  async function valoriserPortefeuillereconstitution(portefeuille_id) {
    const valorisations = [];
    let montantInvestissement = 0;
    for (const entry of req.body) {
      const { date, montantInvesti, fondId, portefeuilleselect } = entry;
      montantInvestissement += montantInvesti
      // Rechercher la valeur du fond pour la date spécifiée
      let vls = await vl.findAll({
        where: {
          fund_id: fondId, date: {
            [Op.gte]: date // Remplacez 'votreDate' par la date que vous souhaitez comparer.
          }
        }
      });
      const quantite = montantInvesti / vls[0].value;

      for (const dateRow of vls) {

        const valorisation = quantite * dateRow.value;
        valorisations.push({ date: dateRow.date, value: valorisation, fund_id: fondId, portefeuille_id: portefeuilleselect });

      }
      // Insérer les nouvelles valorisations dans la table vl_portefeuille
      await portefeuille_vl.bulkCreate(valorisations);
    }

    const updatedData = {
      montant_invest: montantInvestissement
    };

    // Assuming 'portefeuille' is your model for updating data in your database
    await portefeuille.update(updatedData, {
      where: { id: portefeuille },
    });

    return res.json({ code: 200, data: "succes" });
  }


  //autre fonction +/- value
  async function calculerPlusMoinsValueParTitre(opcvmId) {
    const transactions = await Transaction.findAll({ where: { opcvmId } });
    let valeurAchat = 0, valeurActuelle = 0;

    for (const transaction of transactions) {
      if (transaction.type === 'achat') {
        valeurAchat += transaction.quantite * transaction.vlTransaction;
      } else {
        valeurActuelle += transaction.quantite * transaction.vlTransaction;
      }
    }

    return valeurActuelle - valeurAchat;
  }
  //autre fonction +/- value globale
  async function calculerPlusMoinsValueGlobale() {
    const opcvmIds = (await OPCVM.findAll()).map(opcvm => opcvm.id);
    let plusMoinsValueGlobale = 0;

    for (const id of opcvmIds) {
      plusMoinsValueGlobale += await calculerPlusMoinsValueParTitre(id);
    }

    return plusMoinsValueGlobale;
  }



  app.post('/api/saveValuationData', (req, res) => {
    const valuationData = req.body; // Assuming the request body contains valuation data
    // Save valuation data to the database or file system
    // Respond with a success message or saved data
  });
  /*
    app.post('/api/uploadFile', upload.single('file'), (req, res) => {
      // Process the uploaded file here and save it
      // You can save the file path or content to a database or file system
      // Respond with a success message or the saved file details
    });
    */
  app.post('/api/postuserportefeuille', async (req, res) => {
    try {
      const {
        email,
        password,
        nom,
        prenoms,
        denomination,
        pays,
        typeusers,
        typeusers_id


        // Ajoutez d'autres champs ici
      } = req.body;
      /* const fundsData = req.body.funds;
   
       const fundsArray = fundsData.split(', ');
       const fundsidData = req.body.fundids;
   
       const fundsidArray = fundsidData.split(', ');*/

      const newUser = await users.create({
        email: email,
        password: bcrypt.hashSync(password, 10),
        nom: nom,
        prenoms: prenoms,
        denomination: denomination,
        pays: pays,
        typeusers: typeusers,
        typeusers_id: typeusers_id,
        active:typeusers_id!=1?0:1
      });

      // Retrieve additional data if needed
      // For example, you can retrieve the user ID after creation
      const userId = newUser;

      // Respond with a success message and additional data
      res.json({
        code: 200,
        data: {
          userId: userId
        }
      });
    } catch (error) {
      // Gérez les erreurs ici
      console.error('Erreur lors de l\'insertion en base de données :', error);
      res.status(500).json({ message: 'Erreur lors de l\'insertion en base de données' });
    }
  });
  app.get('/api/userexist', async (req, res) => {
    try {
      const userEmail = req.query.email;

      if (!userEmail) {
        return res.status(400).json({ code: 400, message: 'Email parameter is missing' });
      }

      const user = await users.findOne({
        where: {
          email: userEmail
        }
      });

      if (user) {
        // L'utilisateur existe
        return res.json({
          code: 200,
          data: {
            userExists: true,
            user: user
          }
        });
      } else {
        // L'utilisateur n'existe pas
        return res.json({
          code: 400,
          data: {
            userExists: false
          }
        });
      }
    } catch (error) {
      console.error("Error in /api/userexist:", error);
      return res.status(500).json({ code: 500, message: 'Internal Server Error' });
    }
  });

  app.get('/api/userlogin', async (req, res) => {
    try {
      const userEmail = req.query.email;
      const password = req.query.password;


      if (!userEmail) {
        return res.status(400).json({ code: 400, message: 'Email parameter is missing' });
      }

      const user = await users.findOne({
        where: {
          email: userEmail
        }
      });

      if (user) {
        if (await bcrypt.compare(password, user.password)) {
          return res.json({
            code: 200,
            data: {
              userExists: user
            }
          });
        } else {
          // L'utilisateur n'existe pas
          return res.json({
            code: 400,
            data: {
              userExists: false
            }
          });
        }
        // L'utilisateur existe

      } else {
        // L'utilisateur n'existe pas
        return res.json({
          code: 400,
          data: {
            userExists: false
          }
        });
      }
    } catch (error) {
      console.error("Error in /api/userexist:", error);
      return res.status(500).json({ code: 500, message: 'Internal Server Error' });
    }
  });

  function isWeekend(date) {
    const dayOfWeek = date.day();
    return dayOfWeek === 0 || dayOfWeek === 6; // 0 pour dimanche, 6 pour samedi
  }

  //Process2
  app.get('/api/savevlmanquante', async (req, res) => {
    const allFunds = await fetchFundsByValorisation([], 'undefined', 'undefined', 'undefined', 'undefined');

    //const allFunds = await fond.findAll();

    for (const fund of allFunds) {
      let anomalie = "";
      const fundId = fund.id;
      const periodicite = fund.periodicite;
      const firstVlDate = await vl.min('date', { where: { fund_id: fundId } });
      const increment = periodicite === 'journaliere' ? 'days' : 'weeks';
      for (let date = moment(firstVlDate); date.isBefore(moment()); date.add(1, increment)) {
        // Si la périodicité est journalière et la date est un week-end, passer à la prochaine date
        if (periodicite === 'journaliere' && isWeekend(date)) {
          continue;
        }

        // Vérifier si la VL est manquante pour cette date
        const vlExists = await vl.findOne({ where: { fund_id: fundId, date: date.format('YYYY-MM-DD') } });

        // Si la VL n'existe pas, ajouter l'anomalie VL manquante
        if (!vlExists) {
          anomalie = "VL MANQUANTE"
          break; // Arrêter la boucle après avoir trouvé une anomalie de VL manquante
          //anomalies.push({ fond_id: id, date: date.format('YYYY-MM-DD'), type_anomalie: 'VL manquant' });
        }
      }
      const existingperf = await performences.findOne({
        where: { fond_id: fundId },
        order: [['date', 'DESC']], // Trie par date décroissante
      });
      if (existingperf) {
        // Le fond existe, mettez à jour son classement en fonction de la catégorie
        existingperf.anomalie = anomalie;
        await existingperf.save();
      }

    }
    res.json({
      code: 200,
      data: "OK"
    });
  });

  app.get('/api/getallfondsanomalie', async (req, res) => {
    const societegestion = req.query.societegestion;
    const pays = req.query.pays;


    // Requête pour récupérer les fonds avec une anomalie de type "VL MANQUANTE"
    const highVolatilityFundsVLManquante = await performences.findAll({
      attributes: ['fond_id'], // Sélectionnez uniquement la colonne fond_id
      where: {

        anomalie: 'VL MANQUANTE'
      },
      raw: true // Assurez-vous de récupérer les résultats sous forme de tableau brut
    });

    // Requête pour récupérer les fonds avec une autre anomalie que "VL MANQUANTE"
    const highVolatilityFundsAutreAnomalie = await performences.findAll({
      attributes: ['fond_id'], // Sélectionnez uniquement la colonne fond_id
      where: {
        [Sequelize.Op.or]: [
          { volatility3an: { [Op.gt]: 50 } },
          { volatility1an: { [Op.gt]: 50 } },
          { volatility5an: { [Op.gt]: 50 } },
          { pertemax1an: { [Op.lt]: -50 } },
          { pertemax3an: { [Op.lt]: -50 } },
          { pertemax5an: { [Op.lt]: -50 } }
        ],
      },
      raw: true // Assurez-vous de récupérer les résultats sous forme de tableau brut
    });

    const dataWithAnomalyTypeVLManquante = highVolatilityFundsVLManquante.map(fundId => ({
      id: fundId.fond_id,
      anomalie: 'VL MANQUANTE'
    }));

    // Parcourir fundIdsAutreAnomalie et ajouter les fonds avec l'anomalie "fff"
    const dataWithAnomalyTypeAutreAnomalie = highVolatilityFundsAutreAnomalie.map(fundId => ({
      id: fundId.fond_id,
      anomalie: 'ANOMALIE VL'
    }));

    // Combiner les deux ensembles
    const combinedData = [...dataWithAnomalyTypeVLManquante, ...dataWithAnomalyTypeAutreAnomalie];

    // Récupérer les données des fonds à partir des IDs combinés
    const highVolatilityFundsData = [];

    for (const data of combinedData) {
      let fundData;
      if (societegestion) {
        fundData = await fond.findOne({ where: { id: data.id, societe_gestion: societegestion } });
      } else if (pays) {
        fundData = await fond.findOne({ where: { id: data.id, pays: pays } });
      }

      else {
        fundData = await fond.findOne({ where: { id: data.id } });
      }
      if (fundData) {
        highVolatilityFundsData.push(fundData);
      }
    }


    // Associer les données récupérées avec le type d'anomalie correspondant
    const dataWithAnomalyType = [];
    const idCounts = {};
    const seenCombinations = new Set();

    for (const fund of highVolatilityFundsData) {
      const id = fund.id;
      /* let anomalyType = 'VL MANQUANTE';
   
       if (idCounts[id]) {
         idCounts[id]++;
         anomalyType = `ANOMALIE VL`;
       } else {
         idCounts[id] = 1;
       }*/

      const correspondingData = combinedData.filter(data => data.id === id);
      /*correspondingData.forEach(data => {
        dataWithAnomalyType.push({
          ...fund.toJSON(),
          type_anomalie: data.anomalie,
          // Vous pouvez également ajouter les autres propriétés de data si nécessaire
        });
      });*/

      correspondingData.forEach(data => {
        const combinationKey = `${fund.id}-${data.anomalie}`; // Assurez-vous que fund.id est une propriété unique pour chaque fund

        if (!seenCombinations.has(combinationKey)) {
          seenCombinations.add(combinationKey);
          dataWithAnomalyType.push({
            ...fund.toJSON(),
            type_anomalie: data.anomalie,
            // Ajoutez les autres propriétés de data si nécessaire
          });
        }
      });
    }
    console.log(dataWithAnomalyType)
    res.json({
      code: 200,
      data: dataWithAnomalyType
    });
  });
  app.get('/api/vlspresui/:id/:value/:date', async (req, res) => {
    try {
      const { id, value, date } = req.params;
      // Récupérer les valeurs précédentes et suivantes pour le fonds spécifié
      const previousValues = await vl.findAll({
        where: {
          fund_id: parseInt(id), // ID du fonds
          date: { [Sequelize.Op.lt]: date }, // Date antérieure à la date donnée
          //  value: { [Sequelize.Op.lt]: value } // Valeur antérieure à la valeur donnée
        },
        order: [['date', 'DESC'],], // Trier par date et valeur en ordre décroissant
        limit: 5 // Limiter les résultats à 5 enregistrements
      });
      const nextValues = await vl.findAll({
        where: {
          fund_id: parseInt(id), // ID du fonds
          date: { [Sequelize.Op.gt]: date }, // Date postérieure à la date donnée
          //  value: { [Sequelize.Op.gte]: value } // Valeur postérieure ou égale à la valeur donnée
        },
        order: [['date', 'ASC']], // Trier par date et valeur en ordre croissant
        limit: 5 // Limiter les résultats à 5 enregistrements
      });
      previousValues.reverse();

      res.json({
        code: 200,
        data: { previousValues, nextValues }
      });
    } catch (error) {
      console.error('Error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });
  app.post('/api/updateValues/:id', async (req, res) => {
    try {
      const nupdatedDataList = req.body.nextValues; // Récupérez la liste de données mises à jour envoyées depuis le front-end
      const pupdatedDataList = req.body.previousValues; // Récupérez la liste de données mises à jour envoyées depuis le front-end

      // Parcourez la liste et mettez à jour chaque entrée de valorisation
      for (const updatedData of nupdatedDataList) {
        const { id, date, value } = updatedData;
        let fonds = await fond.findOne({
          where: {
            id: parseInt(id)
          },

        });
        const paireEUR = "EUR" + "/" + fonds.dev_libelle;
        const paireUSD = "USD" + "/" + fonds.dev_libelle;
        const val = parseFloat(value)
        let exchangeRatesEUR = await devisedechanges.findOne({
          where: {
            date: { [Op.lte]: date }, // Chercher la date la plus proche inférieure ou égale
            paire: paireEUR,
          },
          order: [['date', 'DESC']], // Tri par date descendant pour obtenir la date la plus proche
        });
        let exchangeRatesUSD = await devisedechanges.findOne({
          where: {
            date: { [Op.lte]: date }, // Chercher la date la plus proche inférieure ou égale
            paire: paireUSD,
          },
          order: [['date', 'DESC']] // Tri par date descendant
        });
        await vl.update({
          date: date,
          value: parseFloat(val),
          value_EUR: exchangeRatesEUR ? parseFloat(val) * exchangeRatesEUR.value : null,
          value_USD: exchangeRatesUSD ? parseFloat(val) * exchangeRatesUSD.value : null
        }, { where: { fund_id: parseInt(req.params.id), date: date } });
      }

      for (const updatedData of pupdatedDataList) {
        const { id, date, value } = updatedData;
        const val = parseFloat(value)
        await vl.update({
          date: date,
          value: parseFloat(val),
          value_EUR: exchangeRatesEUR ? parseFloat(val) * exchangeRatesEUR.value : null,
          value_USD: exchangeRatesUSD ? parseFloat(val) * exchangeRatesUSD.value : null
        }, { where: { fund_id: parseInt(req.params.id), date: date } });
      }

      res.status(200).json({ message: 'Valorisations updated successfully' });
    } catch (error) {
      console.error('Error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });
  app.get('/api/getfondsanomalie/:id', async (req, res) => {
    try {
      const valorisations = await vl.findAll({
        where: {
          fund_id: parseInt(req.params.id)
        },
        order: [['date', 'ASC']]
      });
      const highVolatilityFundsData = await fond.findAll({
        where: {
          id: parseInt(req.params.id)
        }
      });
      const fondsWithAnomalies = [];

      for (let i = 1; i < valorisations.length - 1; i++) {
        const currentValue = valorisations[i].value;
        const prevValue = valorisations[i - 1].value;
        const nextValue = valorisations[i + 1].value;
        const dateprev = valorisations[i - 1].date;
        const datenext = valorisations[i + 1].date;
        const date = valorisations[i].date;

        const percentChangePrev = Math.abs((currentValue - prevValue) / prevValue) * 100;
        const percentChangeNext = Math.abs((nextValue - currentValue) / currentValue) * 100;

        //   if (percentChangePrev <= 10 && percentChangeNext <= 10) {
        if (prevValue <= currentValue * 0.9) {
          fondsWithAnomalies.push({
            id: parseInt(req.params.id),
            nom: highVolatilityFundsData[0].nom_fond,
            code: highVolatilityFundsData[0].code_ISIN,
            now: currentValue,
            after: prevValue,
            //  nextValue,
            nowdate: date,
            afterdate: dateprev

            //  datenext
          });
        }/*else if(nextValue>=currentValue*1.1){
              fondsWithAnomalies.push({
                id:highVolatilityFundsData[0].id,
                nom:highVolatilityFundsData[0].nom_fond,
                code:highVolatilityFundsData[0].code_ISIN,

            now:    currentValue,
               // prevValue,
             after:   nextValue,
              //  dateprev,
            nowdate:  date,
             afterdate:   datenext

            });
            }*/
      }

      res.json({
        code: 200,
        data: fondsWithAnomalies
      });
    } catch (error) {
      console.error('Error:', error);
      res.status(500).json({
        code: 500,
        message: 'Internal server error'
      });
    }
  });

  app.get('/api/getportefeuillebyuser/:id', async (req, res) => {
    portefeuille.findAll({
      where: {
        user_id: req.params.id

      },
      order: [
        ['id', 'ASC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const portefeuille = response.map(data => ({
          nom_portefeuille: data.nom_portefeuille.toString(), // Remplacez avec la propriété correcte de l'objet
          description: data.description,
          funds: data.funds,
          fundids: data.fundids,
          id: data.id,
          montant_invest: data.montant_invest,
          poids: data.poidsportefeuille,
          portefeuilletype: data.portefeuilletype,
          horizon: data.horizon,
          categorie: data.categorie,
          univers: data.univers,
          universsous: data.universsous,

        }));
        res.json({
          code: 200,
          data: {
            portefeuille,
            //  valorisation

          }
        })

      })
  })
  app.get('/api/getportefeuille/:id', async (req, res) => {
    const resultat = await portefeuille_vl_cumul.findAll({
      attributes: ['date', 'valeur_portefeuille'],
      where: {
        portefeuille_id: req.params.id,
      },
      order: [
        ['date', 'ASC']
      ]
    });
    let valorisation;
    if (resultat) {
      valorisation = resultat;
      // Utilisez valorisation ici
    }

    const resultat1 = await portefeuilles_proposes_vls.findAll({
      attributes: ['date', 'value'],
      where: {
        portefeuille_id: req.params.id,
      },
      order: [
        ['date', 'ASC']
      ]
    });
    let valorisation_robo;
    if (resultat1) {
      valorisation_robo = resultat1;
      // Utilisez valorisation ici
    }

    const portefeuilleResult = await portefeuille.findAll({
      where: {
        id: req.params.id
        /* id: {
           //  [Sequelize.Op.like]: `%${searchTerm}%`
         }*/
      },
      order: [
        ['id', 'ASC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const portefeuille = {
          nom_portefeuille: response[0].nom_portefeuille.toString(), // Remplacez avec la propriété correcte de l'objet
          description: response[0].description,
          funds: response[0].funds,
          fundids: response[0].fundids,
          id: response[0].id,
          montant_invest: response[0].montant_invest,
          cash: response[0].cash,
          devise: response[0].devise,
          poids: response[0].poidsportefeuille,
          portefeuilletype: response[0].portefeuilletype,
          horizon: response[0].horizon,
          categorie: response[0].categorie,
          univers: response[0].univers,
          maj: response[0].maj,
          universsous: response[0].universsous,
        };
        res.json({
          code: 200,
          data: {
            portefeuille,
            valorisation,
            valorisation_robo

          }
        })

      })
  })
  app.post('/api/postportefeuille', async (req, res) => {
    try {
      const {
        nomDuportefeuille,
        Description,
        horizon,
        portefeuilletype,
        universInvestissement,
        universInvestissementsous,
        classeActifs,
        userid,
        devise

        // Ajoutez d'autres champs ici
      } = req.body;
      /* const fundsData = req.body.funds;
   
       const fundsArray = fundsData.split(', ');
       const fundsidData = req.body.fundids;
   
       const fundsidArray = fundsidData.split(', ');*/

      portefeuille.create({
        nom_portefeuille: nomDuportefeuille,
        description: Description,
        portefeuilletype: portefeuilletype,
        horizon: horizon,
        univers: universInvestissement,
        universsous: universInvestissementsous,
        categorie: classeActifs,
        user_id: userid,
        devise: devise,
        //  funds:fundsArray,
        // fundids:fundsidArray
        // Ajoutez d'autres champs ici
      })



      // Répondez avec un message de succès ou autre réponse appropriée
      res.status(200).json({ message: 'Données insérées avec succès' });
    } catch (error) {
      // Gérez les erreurs ici
      console.error('Erreur lors de l\'insertion en base de données :', error);
      res.status(500).json({ message: 'Erreur lors de l\'insertion en base de données' });
    }
  });
  app.post('/api/updateportefeuille', async (req, res) => {
    try {
      const {
        selectedportfeuille,
        selectedValue,
        selectedValuename,
        Fond,
        Fondname

        // funds,
        // Ajoutez d'autres champs ici
      } = req.body;
      let fundsArraypost;
      let fundsnameArraypost;

      let fundsArray = null; // Change const to let to allow reassignment
      let fundsnameArray = null; // Change const to let to allow reassignment

      const fundsData = selectedValue; // Use the correct variable name
      const fundsDataname = selectedValuename; // Use the correct variable name



      if (fundsData != null) {
        fundsArray = fundsData.split(',');
        fundsnameArray = fundsDataname.split(',');
        fundsArraypost = fundsArray;
        fundsnameArraypost = fundsnameArray;

      }

      // Define the 'updatedData' object that you want to use in the 'portefeuille.update' method
      const updatedData = {
        fundids: fundsArraypost, funds: fundsnameArraypost
      };

      // Assuming 'portefeuille' is your model for updating data in your database
      await portefeuille.update(updatedData, {
        where: { id: selectedportfeuille },
      });
      // Répondez avec un message de succès ou autre réponse appropriée
      res.status(200).json({ message: 'Données insérées avec succès' });
    } catch (error) {
      // Gérez les erreurs ici
      console.error('Erreur lors de l\'insertion en base de données :', error);
      res.status(500).json({ message: 'Erreur lors de l\'insertion en base de données' });
    }
  });




  app.post('/api/reconstitution', async (req, res) => {
    try {
      // const { entries } = req.body;

      const valorisations = [];
      let montantInvestissement = 0;
      for (const entry of req.body) {
        const { date, montantInvesti, fondId, portefeuilleselect } = entry;
        montantInvestissement += montantInvesti
        // Rechercher la valeur du fond pour la date spécifiée
        let vls = await vl.findAll({
          where: {
            fund_id: fondId, date: {
              [Op.gte]: date // Remplacez 'votreDate' par la date que vous souhaitez comparer.
            }
          }
        });
        const quantite = montantInvesti / vls[0].value;

        for (const dateRow of vls) {

          const valorisation = quantite * dateRow.value;
          valorisations.push({ date: dateRow.date, value: valorisation, fund_id: fondId, portefeuille_id: portefeuilleselect });

        }
        // Insérer les nouvelles valorisations dans la table vl_portefeuille
        await portefeuille_vl.bulkCreate(valorisations);
      }

      const updatedData = {
        montant_invest: montantInvestissement
      };

      // Assuming 'portefeuille' is your model for updating data in your database
      await portefeuille.update(updatedData, {
        where: { id: portefeuille },
      });

      return res.json({ code: 200, data: "succes" });
    } catch (error) {
      console.error(error);
      res.status(500).json({ error: "Erreur lors du calcul de la valorisation" });
    }
  });

  // Étape 1 : Récupérez les données des fonds depuis l'API Node.js


  // Fonction pour obtenir les performances de tous les fonds de la catégorie


  async function fetchFundsByValorisationfirst(selectedValues, selectedcategorie, selectedsociete, selectedDevise, frequence, selectedcategorieregionale, selectedcategorienationale) {
    try {
      let query;
      if (selectedValues.length >= 1 && selectedValues[0] != '') {

        query = `
      SELECT f.*
      FROM fond_investissements AS f
      WHERE  f.id in (${selectedValues.map(cat => cat).join(',')}) and  f.id IN (SELECT v.fund_id FROM valorisations AS v )
    `;
      } else {

        query = `
        SELECT f.*
        FROM fond_investissements AS f
        WHERE   f.id IN (SELECT v.fund_id FROM valorisations AS v )
 `;
      }

      if (selectedcategorie != 'undefined') {
        query += `
   
        AND f.categorie_globale = :selectedcategorie
    
  `;
      }

      if (selectedDevise != 'undefined') {
        query += `
   
        AND f.dev_libelle = :selectedDevise
    
  `;
      }

      if (frequence != 'undefined' && frequence.length >= 1) {
        query += `
   
        AND f.periodicite = :frequence
    
  `;
      }

      if (selectedsociete != 'undefined') {
        query += `
   
        AND f.societe_gestion = :selectedsociete
    
  `;
      }

      if (selectedcategorienationale != 'undefined') {
        query += `
   
        AND f.categorie_national = :selectedcategorienationale
    
  `;
      }
      if (selectedcategorieregionale != 'undefined') {
        query += `
   
        AND f.categorie_regional = :selectedcategorieregionale
    
  `;
      }

      const fondsDansCategorie = await sequelize.query(query, {
        replacements: { selectedsociete, selectedcategorie, selectedDevise, frequence, selectedcategorieregionale, selectedcategorienationale },

        type: sequelize.QueryTypes.SELECT,
      });

      // Retournez la liste des fonds
      return fondsDansCategorie;
    } catch (erreur) {
      console.error('Erreur lors de la récupération des fonds par catégorie :', erreur);
      throw erreur; // Propagez l'erreur pour qu'elle soit gérée ailleurs si nécessaire
    }
  }

  async function fetchFundsByValorisation(selectedValues, selectedcategorie, selectedsociete, selectedDevise, frequence) {
    try {
      let query;
      if (selectedValues.length >= 1 && selectedValues[0] != '') {

        query = `
      SELECT f.*
      FROM fond_investissements AS f
      WHERE  f.id in (${selectedValues.map(cat => cat).join(',')}) and  f.id IN (SELECT v.fund_id FROM valorisations AS v )
    `;
      } else {

        query = `
        SELECT f.*
        FROM fond_investissements AS f
        WHERE   f.id IN (SELECT v.fund_id FROM valorisations AS v )
 `;
      }

      if (selectedcategorie != 'undefined') {
        query += `
   
        AND f.categorie_globale = :selectedcategorie
    
  `;
      }

      if (selectedDevise != 'undefined') {
        query += `
   
        AND f.dev_libelle = :selectedDevise
    
  `;
      }

      if (frequence != 'undefined' && frequence.length >= 1) {
        query += `
   
        AND f.periodicite = :frequence
    
  `;
      }

      if (selectedsociete != 'undefined') {
        query += `
   
        AND f.societe_gestion = :selectedsociete
    
  `;
      }

      const fondsDansCategorie = await sequelize.query(query, {
        replacements: { selectedsociete, selectedcategorie, selectedDevise, frequence },

        type: sequelize.QueryTypes.SELECT,
      });

      // Retournez la liste des fonds
      return fondsDansCategorie;
    } catch (erreur) {
      console.error('Erreur lors de la récupération des fonds par catégorie :', erreur);
      throw erreur; // Propagez l'erreur pour qu'elle soit gérée ailleurs si nécessaire
    }
  }

  async function fetchFundsByValorisation1(selectedValues, selectedcategorie, selectedsociete, selectedDevise, frequence, fund1, fund2) {
    try {
      let query;
      if (selectedValues.length >= 1 && selectedValues[0] != '') {

        query = `
      SELECT f.*
      FROM fond_investissements AS f
      WHERE  f.id in (${selectedValues.map(cat => cat).join(',')}) and  f.id IN (SELECT v.fund_id FROM valorisations AS v ) and f.id>=${fund1} and  f.id<=${fund2} 
    `;
      } else {

        query = `
        SELECT f.*
        FROM fond_investissements AS f
        WHERE   f.id IN (SELECT v.fund_id FROM valorisations AS v ) and f.id>=${fund1} and  f.id<=${fund2} 
 `;
      }

      if (selectedcategorie != 'undefined') {
        query += `
   
        AND f.categorie_globale = :selectedcategorie
    
  `;
      }

      if (selectedDevise != 'undefined') {
        query += `
   
        AND f.dev_libelle = :selectedDevise
    
  `;
      }

      if (frequence != 'undefined' && frequence.length >= 1) {
        query += `
   
        AND f.periodicite = :frequence
    
  `;
      }

      if (selectedsociete != 'undefined') {
        query += `
   
        AND f.societe_gestion = :selectedsociete
    
  `;
      }

      const fondsDansCategorie = await sequelize.query(query, {
        replacements: { selectedsociete, selectedcategorie, selectedDevise, frequence },

        type: sequelize.QueryTypes.SELECT,
      });

      // Retournez la liste des fonds
      return fondsDansCategorie;
    } catch (erreur) {
      console.error('Erreur lors de la récupération des fonds par catégorie :', erreur);
      throw erreur; // Propagez l'erreur pour qu'elle soit gérée ailleurs si nécessaire
    }
  }

  async function anneevalorisation(fundid) {
    try {
      let query;
      // MAX(YEAR(v.date))-MIN(YEAR(v.date)) as annee


      query = `
        SELECT
        f.*,
        MIN(YEAR(v.date)) AS first_valorisation_year,
        MAX(YEAR(v.date)) AS last_valorisation_year,
       
        DATEDIFF(MAX(v.date), MIN(v.date))/365 AS annee
      FROM
        fond_investissements AS f
      JOIN
        valorisations AS v ON f.id = v.fund_id
      WHERE
        f.id = :fundid AND
        f.id IN (
          SELECT v.fund_id
          FROM valorisations AS v
          WHERE v.fund_id = :fundid
          GROUP BY v.fund_id
          
        )
      GROUP BY
        f.id
 `;






      const fondsDansCategorie = await sequelize.query(query, {
        replacements: { fundid, },

        type: sequelize.QueryTypes.SELECT,
      });

      // Retournez la liste des fonds
      return fondsDansCategorie;
    } catch (erreur) {
      console.error('Erreur lors de la récupération des fonds par catégorie :', erreur);
      throw erreur; // Propagez l'erreur pour qu'elle soit gérée ailleurs si nécessaire
    }
  }
  app.post('/api/rechercheravance-fonds', async (req, res) => {
    const formData = req.body.formData;
    const selectedValues = req.query.query;
    const selectedcategorieregionale = req.query.selectedcategorieregionale;
    const selectedcategorienationale = req.query.selectedcategorienationale;
    const selectedCategorie = req.query.selectedcategorie; // Corrected variable name
    const selectedDevise = req.query.selecteddevise; // Corrected variable name
    const selectedSociete = req.query.selectedsociete; // Corrected variable name
    const frequence = req.query.frequence; // Corrected variable name

    console.log(frequence.length);
    const valuesArray = selectedValues.split(',');

    // Fetch funds based on criteria
    const funds = await fetchFundsByValorisationfirst(valuesArray, selectedCategorie, selectedSociete, selectedDevise, frequence, selectedcategorieregionale, selectedcategorienationale);

    if (!funds.length) {
      res.status(404).json({ error: 'No funds found.' });
      return;
    }

    // Use batch processing to fetch fund data and performance data
    const fundIds = funds.map(fund => fund.id);

    try {
      // Fetch all fund data in one batch
      const fundDataResults = await fond.findAll({
        where: { id: fundIds }
      });

      // Fetch all performance data in one batch
      const performanceResults = await performences.findAll({
        where: {
          fond_id: fundIds
        },
        order: [['date', 'DESC']]
      });

      // Create a map for performance data for quick lookup
      const performanceMap = performanceResults.reduce((acc, performance) => {
        if (!acc[performance.fond_id]) {
          acc[performance.fond_id] = performance;
        }
        return acc;
      }, {});

      // Combine data
      const fundsWithAllData = fundDataResults.map(fundData => {
        const performanceData = performanceMap[fundData.id] || null;
        return {
          id: fundData.id,
          fundData: fundData.toJSON(),
          performanceData: performanceData ? performanceData.toJSON() : null
        };
      });

      let resultats = fundsWithAllData;
      if (Object.keys(formData).length > 0) {
        // Filtrez les fonds en fonction des critères
        resultats = fundsWithAllData.filter((fonds) => {
          let correspondances = 0;

          // Parcourez les critères du formulaire (formData) et comparez-les aux caractéristiques des fonds
          for (const typeCritere in formData) {
            const critere = formData[typeCritere];

            // Parcourez les critères spécifiques (perf_annu, sharpe, volatilite)
            const operation = critere["operation"];
            const value = critere["value"]

            // Construisez la clé de la propriété correspondante dans le fonds
            // Évaluez la condition par annee
            if (typeof critere["periode"] !== 'undefined') {
              periode = critere["periode"]
              if (periode === "1a") {

                if (typeCritere === "Ratioinf" && fonds.performanceData) {
                  const Ratioinf = fonds.performanceData.info1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Ratioinf !== '-' && Ratioinf !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Ratioinf} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Ratioinf} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Var95" && fonds.performanceData) {
                  const Var95 = fonds.performanceData.var951an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Var95 !== '-' && Var95 !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Var95} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Var95} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Var99" && fonds.performanceData) {
                  const Var99 = fonds.performanceData.var991an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Var99 !== '-' && Var99 !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Var99} < ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Var99} > ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Calamar" && fonds.performanceData) {
                  const Calamar = fonds.performanceData.calamar1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Calamar !== '-' && Calamar !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Calamar} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Calamar} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "PerfAnnu" && fonds.performanceData) {
                  const PerfAnnu = fonds.performanceData.perfannu1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (PerfAnnu !== '-' && PerfAnnu !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${PerfAnnu} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfAnnu} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Sharpe" && fonds.performanceData) {
                  const Sharpe = fonds.performanceData.ratiosharpe1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Sharpe !== '-' && Sharpe !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Sharpe} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Sharpe} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Pertemax" && fonds.performanceData) {
                  const Pertemax = fonds.performanceData.pertemax1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Pertemax !== '-' && Pertemax !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Pertemax} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Pertemax} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Volatilite" && fonds.performanceData) {
                  const Volatilite = fonds.performanceData.volatility1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Volatilite !== '-' && Volatilite !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Volatilite} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Volatilite} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Trakingerror" && fonds.performanceData) {
                  const Trakingerror = fonds.performanceData.trackingerror1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Trakingerror !== '-' && Trakingerror !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Trakingerror} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Trakingerror} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Sortino" && fonds.performanceData) {
                  const Sortino = fonds.performanceData.sortino1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Sortino !== '-' && Sortino !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Sortino} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Sortino} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Omega" && fonds.performanceData) {
                  const Omega = fonds.performanceData.omega1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Omega !== '-' && Omega !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Omega} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Omega} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Dsr" && fonds.performanceData) {
                  const Dsr = fonds.performanceData.dsr1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Dsr !== '-' && Dsr !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Dsr} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Dsr} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Betahaussier" && fonds.performanceData) {
                  const Betahaussier = fonds.performanceData.betahaussier1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Betahaussier !== '-' && Betahaussier !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Betahaussier} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Betahaussier} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Betabaissier" && fonds.performanceData) {
                  const Betabaissier = fonds.performanceData.betabaissier1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Betabaissier !== '-' && Betabaissier !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Betabaissier} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Betabaissier} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Downcapture" && fonds.performanceData) {
                  const Downcapture = fonds.performanceData.downcapture1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Downcapture !== '-' && Downcapture !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Downcapture} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Downcapture} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Upcapture" && fonds.performanceData) {
                  const Upcapture = fonds.performanceData.upcapture1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Upcapture !== '-' && Upcapture !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Upcapture} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Upcapture} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Skewness" && fonds.performanceData) {
                  const Skewness = fonds.performanceData.skewness1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Skewness !== '-' && Skewness !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Skewness} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Skewness} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Kurtosis" && fonds.performanceData) {
                  const Kurtosis = fonds.performanceData.kurtosis1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Kurtosis !== '-' && Kurtosis !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Kurtosis} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Kurtosis} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Beta" && fonds.performanceData) {
                  const Beta = fonds.performanceData.beta1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Beta !== '-' && Beta !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Beta} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Beta} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
              } else if (periode === "3a") {
                if (typeCritere === "Ratioinf" && fonds.performanceData) {
                  const Ratioinf = fonds.performanceData.info3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Ratioinf !== '-' && Ratioinf !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Ratioinf} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Ratioinf} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Var95" && fonds.performanceData) {
                  const Var95 = fonds.performanceData.var953an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Var95 !== '-' && Var95 !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Var95} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Var95} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Var99" && fonds.performanceData) {
                  const Var99 = fonds.performanceData.var993an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Var99 !== '-' && Var99 !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Var99} < ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Var99} > ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Calamar" && fonds.performanceData) {
                  const Calamar = fonds.performanceData.calamar3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Calamar !== '-' && Calamar !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Calamar} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Calamar} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "PerfAnnu" && fonds.performanceData) {
                  const PerfAnnu = fonds.performanceData.perfannu3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (PerfAnnu !== '-' && PerfAnnu !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${PerfAnnu} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfAnnu} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Sharpe" && fonds.performanceData) {
                  const Sharpe = fonds.performanceData.ratiosharpe3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Sharpe !== '-' && Sharpe !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Sharpe} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Sharpe} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Pertemax" && fonds.performanceData) {
                  const Pertemax = fonds.performanceData.pertemax3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Pertemax !== '-' && Pertemax !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Pertemax} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Pertemax} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Volatilite" && fonds.performanceData) {
                  const Volatilite = fonds.performanceData.volatility3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Volatilite !== '-' && Volatilite !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Volatilite} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Volatilite} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Trakingerror" && fonds.performanceData) {
                  const Trakingerror = fonds.performanceData.trackingerror3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Trakingerror !== '-' && Trakingerror !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Trakingerror} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Trakingerror} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Sortino" && fonds.performanceData) {
                  const Sortino = fonds.performanceData.sortino3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Sortino !== '-' && Sortino !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Sortino} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Sortino} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Omega" && fonds.performanceData) {
                  const Omega = fonds.performanceData.omega3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Omega !== '-' && Omega !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Omega} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Omega} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Dsr" && fonds.performanceData) {
                  const Dsr = fonds.performanceData.dsr3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Dsr !== '-' && Dsr !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Dsr} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Dsr} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Betahaussier" && fonds.performanceData) {
                  const Betahaussier = fonds.performanceData.betahaussier3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Betahaussier !== '-' && Betahaussier !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Betahaussier} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Betahaussier} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Betabaissier" && fonds.performanceData) {
                  const Betabaissier = fonds.performanceData.betabaissier3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Betabaissier !== '-' && Betabaissier !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Betabaissier} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Betabaissier} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Downcapture" && fonds.performanceData) {
                  const Downcapture = fonds.performanceData.downcapture3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Downcapture !== '-' && Downcapture !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Downcapture} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Downcapture} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Upcapture" && fonds.performanceData) {
                  const Upcapture = fonds.performanceData.upcapture3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Upcapture !== '-' && Upcapture !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Upcapture} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Upcapture} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Skewness" && fonds.performanceData) {
                  const Skewness = fonds.performanceData.skewness3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Skewness !== '-' && Skewness !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Skewness} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Skewness} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Kurtosis" && fonds.performanceData) {
                  const Kurtosis = fonds.performanceData.kurtosis3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Kurtosis !== '-' && Kurtosis !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Kurtosis} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Kurtosis} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Beta" && fonds.performanceData) {
                  const Beta = fonds.performanceData.beta3an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Beta !== '-' && Beta !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Beta} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Beta} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
              } else if (periode === "5a") {
                if (typeCritere === "Ratioinf" && fonds.performanceData) {
                  const Ratioinf = fonds.performanceData.info5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Ratioinf !== '-' && Ratioinf !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Ratioinf} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Ratioinf} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Var95" && fonds.performanceData) {
                  const Var95 = fonds.performanceData.var955an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Var95 !== '-' && Var95 !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Var95} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Var95} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Var99" && fonds.performanceData) {
                  const Var99 = fonds.performanceData.var995an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Var99 !== '-' && Var99 !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Var99} < ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Var99} > ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Calamar" && fonds.performanceData) {
                  const Calamar = fonds.performanceData.calamar5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Calamar !== '-' && Calamar !== null) {
                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Calamar} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Calamar} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "PerfAnnu" && fonds.performanceData) {
                  const PerfAnnu = fonds.performanceData.perfannu5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (PerfAnnu !== '-' && PerfAnnu !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${PerfAnnu} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfAnnu} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Sharpe" && fonds.performanceData) {
                  const Sharpe = fonds.performanceData.ratiosharpe5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Sharpe !== '-' && Sharpe !== null) {
                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Sharpe} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Sharpe} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Pertemax" && fonds.performanceData) {
                  const Pertemax = fonds.performanceData.pertemax5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Pertemax !== '-' && Pertemax !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Pertemax} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Pertemax} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Volatilite" && fonds.performanceData) {
                  const Volatilite = fonds.performanceData.volatility5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Volatilite !== '-' && Volatilite !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Volatilite} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Volatilite} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Trakingerror" && fonds.performanceData) {
                  const Trakingerror = fonds.performanceData.trackingerror5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Trakingerror !== '-' && Trakingerror !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Trakingerror} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Trakingerror} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Sortino" && fonds.performanceData) {
                  const Sortino = fonds.performanceData.sortino5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Sortino !== '-' && Sortino !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Sortino} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Sortino} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Omega" && fonds.performanceData) {
                  const Omega = fonds.performanceData.omega5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Omega !== '-' && Omega !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Omega} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Omega} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Dsr" && fonds.performanceData) {
                  const Dsr = fonds.performanceData.dsr5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Dsr !== '-' && Dsr !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Dsr} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Dsr} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Betahaussier" && fonds.performanceData) {
                  const Betahaussier = fonds.performanceData.betahaussier5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Betahaussier !== '-' && Betahaussier !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Betahaussier} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Betahaussier} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Betabaissier" && fonds.performanceData) {
                  const Betabaissier = fonds.performanceData.betabaissier5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Betabaissier !== '-' && Betabaissier !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Betabaissier} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Betabaissier} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Downcapture" && fonds.performanceData) {
                  const Downcapture = fonds.performanceData.downcapture5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Downcapture !== '-' && Downcapture !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Downcapture} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Downcapture} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Upcapture" && fonds.performanceData) {
                  const Upcapture = fonds.performanceData.upcapture5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Upcapture !== '-' && Upcapture !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Upcapture} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Upcapture} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Skewness" && fonds.performanceData) {
                  const Skewness = fonds.performanceData.skewness5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Skewness !== '-' && Skewness !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Skewness} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Skewness} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Kurtosis" && fonds.performanceData) {
                  const Kurtosis = fonds.performanceData.kurtosis5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Kurtosis !== '-' && Kurtosis !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Kurtosis} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Kurtosis} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
                if (typeCritere === "Beta" && fonds.performanceData) {
                  const Beta = fonds.performanceData.beta5an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (Beta !== '-' && Beta !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${Beta} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${Beta} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
              } else if (periode === "perfVeille") {
                if (typeCritere === "PerfCummul" && fonds.performanceData && fonds.firstData.data) {
                  const PerfCummul = fonds.performanceData.perfveille;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (PerfCummul !== '-' && PerfCummul !== null) {
                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${PerfCummul} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfCummul} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }

              } else if (periode === "perf4Semaines") {
                if (typeCritere === "PerfCummul" && fonds.performanceData) {
                  const PerfCummul = fonds.performanceData.perf4s;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (PerfCummul !== '-' && PerfCummul !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${PerfCummul} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfCummul} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }

              } else if (periode === "perf1erJanvier") {
                if (typeCritere === "PerfCummul" && fonds.performanceData) {
                  const PerfCummul = fonds.performanceData.ytd;
                  // Ajoutez d'autres propriétés si nécessaire

                  // Comparez les valeurs avec les critères
                  if (PerfCummul !== '-' && PerfCummul !== null) {
                    if (operation === "<=" && eval(`${PerfCummul} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfCummul} >= ${value}`)) {
                      correspondances++;
                    }


                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
              } else if (periode === "perf3Mois") {
                if (typeCritere === "PerfCummul" && fonds.performanceData) {
                  const PerfCummul = fonds.performanceData.perf3m;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (PerfCummul !== '-' && PerfCummul !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${PerfCummul} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfCummul} >= ${value}`)) {
                      correspondances++;
                    }
                    // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                  }
                }
              } else if (periode === "perf6Mois") {
                if (typeCritere === "PerfCummul" && fonds.performanceData) {
                  const PerfCummul = fonds.performanceData.perf6m;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (PerfCummul !== '-' && PerfCummul !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${PerfCummul} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfCummul} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }

              } else if (periode === "perf1An") {
                if (typeCritere === "PerfCummul" && fonds.performanceData) {
                  const PerfCummul = fonds.performanceData.perf1an;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (PerfCummul !== '-' && PerfCummul !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${PerfCummul} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfCummul} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }
              } else if (periode === "perf3Ans") {
                if (typeCritere === "PerfCummul" && fonds.performanceData) {
                  const PerfCummul = fonds.performanceData.perf3ans;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (PerfCummul !== '-' && PerfCummul !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${PerfCummul} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfCummul} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }

              } else if (periode === "perf5Ans") {
                if (typeCritere === "PerfCummul" && fonds.performanceData) {
                  const PerfCummul = fonds.performanceData.perf5ans;
                  // Ajoutez d'autres propriétés si nécessaire
                  if (PerfCummul !== '-' && PerfCummul !== null) {

                    // Comparez les valeurs avec les critères
                    if (operation === "<=" && eval(`${PerfCummul} <= ${value}`)) {
                      correspondances++;
                    } else if (operation === ">=" && eval(`${PerfCummul} >= ${value}`)) {
                      correspondances++;
                    }
                  }
                  // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
                }

              }
            } else if (typeof critere["periode"] === 'undefined' && typeof critere["operation"] !== 'undefined') {
              if (typeCritere === "Fraissous" && fonds.fundData) {
                const Fraissous = fonds.fundData.frais_souscription;
                // Ajoutez d'autres propriétés si nécessaire

                // Comparez les valeurs avec les critères
                if (operation === "<=" && eval(`${Fraissous} <= ${value}`)) {
                  correspondances++;
                } else if (operation === ">=" && eval(`${Fraissous} >= ${value}`)) {
                  correspondances++;
                }
                // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
              } else if (typeCritere === "Fraisgestion" && fonds.fundData) {
                const Fraisgestion = fonds.fundData.frais_gestion;
                // Ajoutez d'autres propriétés si nécessaire

                // Comparez les valeurs avec les critères
                if (operation === "<=" && eval(`${Fraisgestion} <= ${value}`)) {
                  correspondances++;
                } else if (operation === ">=" && eval(`${Fraisgestion} >= ${value}`)) {
                  correspondances++;
                }
                // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
              } else if (typeCritere === "Fraisrachat" && fonds.fundData) {
                const Fraisrachat = fonds.fundData.frais_rachat;
                // Ajoutez d'autres propriétés si nécessaire

                // Comparez les valeurs avec les critères
                if (operation === "<=" && eval(`${Fraisrachat} <= ${value}`)) {
                  correspondances++;
                } else if (operation === ">=" && eval(`${Fraisrachat} >= ${value}`)) {
                  correspondances++;
                }
                // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
              } else if (typeCritere === "Fraiscourant" && fonds.fundData) {
                const Fraiscourant = fonds.fundData.frais_courant;
                // Ajoutez d'autres propriétés si nécessaire

                // Comparez les valeurs avec les critères
                if (operation === "<=" && eval(`${Fraiscourant} <= ${value}`)) {
                  correspondances++;
                } else if (operation === ">=" && eval(`${Fraiscourant} >= ${value}`)) {
                  correspondances++;
                }
                // Ajoutez d'autres conditions pour les autres propriétés si nécessaire

              } else if (typeCritere === "Mininvest" && fonds.fundData) {
                const Mininvest = fonds.fundData.mininvestinitial;
                // Ajoutez d'autres propriétés si nécessaire

                // Comparez les valeurs avec les critères
                if (operation === "<=" && eval(`${Mininvest} <= ${value}`)) {
                  correspondances++;
                } else if (operation === ">=" && eval(`${Mininvest} >= ${value}`)) {
                  correspondances++;
                }
                // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
              } else if (typeCritere === "Actifnet" && fonds.fundData) {
                const Actifnet = fonds.fundData.actifnet;
                // Ajoutez d'autres propriétés si nécessaire

                // Comparez les valeurs avec les critères
                if (operation === "<=" && eval(`${Actifnet} <= ${value}`)) {
                  correspondances++;
                } else if (operation === ">=" && eval(`${Actifnet} >= ${value}`)) {
                  correspondances++;
                }
                // Ajoutez d'autres conditions pour les autres propriétés si nécessaire
              }

            } else {
              if (typeCritere === "Typeinvest" && fonds.fundData) {
                const Typeinvest = fonds.fundData.type_investissement;
                // Ajoutez d'autres propriétés si nécessaire

                // Comparez les valeurs avec les critères
                if (eval(`${Typeinvest} == ${value}`)) {
                  correspondances++;
                }
              }

            }

          }

          // Si le nombre de correspondances est égal au nombre total de critères, le fonds est inclus dans les résultats
          return correspondances === Object.keys(formData).length;
        });
      }


      // Envoyez les résultats en tant que réponse JSON
      res.json({
        code: 200,
        data: { funds: resultats }
      });
    } catch (error) {
      console.error('Erreur lors de la recherche des données :', error);
      res.status(500).json({ error: 'Une erreur est survenue lors de la récupération des données.' });
    }
  });







  /**
   * @swagger
   * tags:
   *   - name: Fund Ratios
   *   - name: Performance Data
   *   - name: Previous Performances
   *   - name: Derniere Valeur Liquidative
   */


  // Update management company information
  app.post('/api/addSociete', async (req, res) => {
    try {
      const { societeadd, pays } = req.body;
      societe.create({
        nom: societeadd,
        pays: pays,
        // Ajoutez d'autres champs ici
      })


      res.status(200).json({ message: 'Données insérées avec succès' });
    } catch (error) {
      // Gérez les erreurs ici
      console.error('Erreur lors de l\'insertion en base de données :', error);
      res.status(500).json({ message: 'Erreur lors de l\'insertion en base de données' });
    }
  });
  app.post('/api/updateSociete', async (req, res) => {
    const { societ, nom, description, email, tel, numeroagrement, pays, regulateur, dateimmatriculation, site_web, devise, password } = req.body;

    const updatedSociete = await societe.update(
      {
        //  nom: nom !== undefined ? nom : societ,
        description: description,
        email: email,
        tel: tel,
        numeroagrement: numeroagrement,
        pays: pays,
        regulateur: regulateur,
        dateimmatriculation: dateimmatriculation,
        site_web: site_web,
        devise: devise
      },
      {
        where: { nom: societ },
      }
    );

    const utilisateurs = await users.findOne({
      where: { denomination: societ }
    });

    if (utilisateurs.length > 0) {
      const utilisateur = utilisateurs[0]; // Vous pouvez modifier cela pour choisir l'utilisateur que vous souhaitez

      // Modification du mot de passe de l'utilisateur
      const newPassword = 'nouveauMotDePasse'; // Remplacez 'nouveauMotDePasse' par le nouveau mot de passe souhaité
      const hashedPassword = await bcrypt.hash(newPassword, 10); // Hashage du mot de passe

      // Modification du champ password dans la base de données
      await utilisateur.update({ password: password,/* denomination: nom !== undefined ? nom : societ*/ });
    }

    if (updatedSociete[0] === 1) {
      res.json({ message: 'Societe information updated successfully' });
    } else {
      res.status(404).json({ error: 'Societe not found' });
    }
  });
  app.get('/api/getSocietebyid/:id', async (req, res) => {

    societe.findOne({
      where: { nom: req.params.id }
    })
      .then(response => {

        const societe = {
          nom: response.nom,
          description: response.description,
          email: response.email,
          tel: response.tel,
          numeroagrement: response.numeroagrement,
          pays: response.pays,
          regulateur: response.regulateur,
          dateimmatriculation: response.dateimmatriculation,
          site_web: response.site_web,
          devise: response.devise


        };
        res.json({
          code: 200,
          data: {
            societe
          }
        })
      })
  })
  app.get('/api/getSocietebyidfisrt/:id', async (req, res) => {
    const selectedValues = req.query.query;

    // Recherche de la société par nom
    societe.findOne({
      where: { nom: req.params.id }
    })
      .then(async response => {
        // Récupération des informations de base de la société
        const societeData = {
          nom: response.nom,
          description: response.description,
          email: response.email,
          tel: response.tel,
          numeroagrement: response.numeroagrement,
          pays: response.pays,
          regulateur: response.regulateur,
          dateimmatriculation: response.dateimmatriculation,
          site_web: response.site_web,
          devise: response.devise
        };

        // Recherche du nombre de fonds associés à cette société
        const nbrePart = await fond.count({ where: { societe_gestion: response.nom } });
        var latestValorisations;
        var latestDate;
        var latestDateQuery;
        var result;
        var result5;
        var sumActifNetByYear;
        if (selectedValues == "EUR") {
          const sumActifNetQuery = `
  SELECT SUM(latest_valorisations.actif_net_EUR) AS sumActifNet
  FROM (
      SELECT v.fund_id, MAX(v.date) AS latest_date
      FROM valorisations v
      INNER JOIN fond_investissements f ON v.fund_id = f.id
      WHERE f.societe_gestion = :societeNom
      GROUP BY v.fund_id
  ) AS latest_dates
  INNER JOIN valorisations latest_valorisations 
  ON latest_dates.fund_id = latest_valorisations.fund_id 
  AND latest_dates.latest_date = latest_valorisations.date
  WHERE latest_valorisations.actif_net_EUR != '#N/A';
`;

          [result] = await sequelize.query(sumActifNetQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });



          const latestDateQuery = `
    SELECT MAX(valorisations.date) AS latestDate
    FROM valorisations
    INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
    WHERE fond_investissements.societe_gestion = :societeNom
`;

          // Exécuter la requête avec les paramètres nécessaires
          [result5] = await sequelize.query(latestDateQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });

          latestDate = result5.latestDate;

          const latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net_EUR, YEAR(valorisations.date) AS year
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.societe_gestion = :societeNom
          GROUP BY valorisations.fund_id, year
          ORDER BY valorisations.date DESC
      `;

          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });

          sumActifNetByYear = {};
          fundCountByYear = {};
          // Calcul de la somme des actifs nets par année
          for (const { year } of latestValorisations) {
            fundCountByYear[year] = 0;
          }
          // Calcul de la somme des actifs nets par année
          for (const { year, actif_net_EUR } of latestValorisations) {
            if (!sumActifNetByYear[year]) {
              sumActifNetByYear[year] = 0;
            }
            sumActifNetByYear[year] += parseFloat(actif_net_EUR);
            fundCountByYear[year] += 1; // Increment the count for the year

          }
        } else if (selectedValues == "USD") {
          const sumActifNetQuery = `
  SELECT SUM(latest_valorisations.actif_net_USD) AS sumActifNet
  FROM (
      SELECT v.fund_id, MAX(v.date) AS latest_date
      FROM valorisations v
      INNER JOIN fond_investissements f ON v.fund_id = f.id
      WHERE f.societe_gestion = :societeNom
      GROUP BY v.fund_id
  ) AS latest_dates
  INNER JOIN valorisations latest_valorisations 
  ON latest_dates.fund_id = latest_valorisations.fund_id 
  AND latest_dates.latest_date = latest_valorisations.date
  WHERE latest_valorisations.actif_net_USD != '#N/A';
`;

          [result] = await sequelize.query(sumActifNetQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });



          const latestDateQuery = `
    SELECT MAX(valorisations.date) AS latestDate
    FROM valorisations
    INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
    WHERE fond_investissements.societe_gestion = :societeNom
`;

          // Exécuter la requête avec les paramètres nécessaires
          [result5] = await sequelize.query(latestDateQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });

          latestDate = result5.latestDate;

          const latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net_USD, YEAR(valorisations.date) AS year
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.societe_gestion = :societeNom
          GROUP BY valorisations.fund_id, year
          ORDER BY valorisations.date DESC
      `;

          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });

          sumActifNetByYear = {};
          fundCountByYear = {};
          // Calcul de la somme des actifs nets par année
          for (const { year } of latestValorisations) {
            fundCountByYear[year] = 0;
          }
          // Calcul de la somme des actifs nets par année
          for (const { year, actif_net_USD } of latestValorisations) {
            if (!sumActifNetByYear[year]) {
              sumActifNetByYear[year] = 0;
            }
            sumActifNetByYear[year] += parseFloat(actif_net_USD);
            fundCountByYear[year] += 1; // Increment the count for the year

          }
        } else {
          const sumActifNetQuery = `
  SELECT SUM(latest_valorisations.actif_net) AS sumActifNet
  FROM (
      SELECT v.fund_id, MAX(v.date) AS latest_date
      FROM valorisations v
      INNER JOIN fond_investissements f ON v.fund_id = f.id
      WHERE f.societe_gestion = :societeNom
      GROUP BY v.fund_id
  ) AS latest_dates
  INNER JOIN valorisations latest_valorisations 
  ON latest_dates.fund_id = latest_valorisations.fund_id 
  AND latest_dates.latest_date = latest_valorisations.date
  WHERE latest_valorisations.actif_net != '#N/A';
`;

          [result] = await sequelize.query(sumActifNetQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });



          const latestDateQuery = `
    SELECT MAX(valorisations.date) AS latestDate
    FROM valorisations
    INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
    WHERE fond_investissements.societe_gestion = :societeNom
`;

          // Exécuter la requête avec les paramètres nécessaires
          [result5] = await sequelize.query(latestDateQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });

          latestDate = result5.latestDate;

          const latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net, YEAR(valorisations.date) AS year

          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.societe_gestion = :societeNom
          GROUP BY valorisations.fund_id, year
          ORDER BY valorisations.date DESC
      `;

          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });

          sumActifNetByYear = {};
          fundCountByYear = {};
          // Calcul de la somme des actifs nets par année
          for (const { year } of latestValorisations) {
            fundCountByYear[year] = 0;
          }
          for (const { year, actif_net } of latestValorisations) {
            if (!sumActifNetByYear[year]) {
              sumActifNetByYear[year] = 0;
            }
            sumActifNetByYear[year] += parseFloat(actif_net);
            fundCountByYear[year] += 1; // Increment the count for the year

          }

        }


        // Renvoi des données
        res.json({
          code: 200,
          data: {
            fundCountByYear: fundCountByYear,
            graph: sumActifNetByYear,
            societe: societeData,
            nbrePart: nbrePart,
            latestDate: latestDate,
            sumActifNet: result.sumActifNet || 0 // Utilisation de 0 si la somme est null
          }
        });
      })
      .catch(error => {
        // En cas d'erreur, renvoyer un code d'erreur approprié
        res.status(500).json({ error: "Erreur lors de la récupération des données de la société." });
      });
  });

  //Graph by pays
  app.get('/api/getPaysbyidfisrt/:id', async (req, res) => {
    const selectedValues = req.query.query;

    // Recherche de la société par nom
    pays_regulateurs.findOne({
      where: { pays: req.params.id }
    })
      .then(async response => {
        // Récupération des informations de base de la société
        const societeData = {
          nom: response.pays,
          placeFinanciere:response.nomdelabourse,
          devise:response.symboledevise,
          tauxObligations10Ans:response.tsr10,
          tauxSansRisque:response.to10

        };

        // Recherche du nombre de fonds associés à cette société
        const nbrePart = await fond.count({ where: { pays: response.pays } });
        const nbresocietes= await societe.count({ where: { pays: response.pays } });
        var latestValorisations;
        var latestDate;
        var performa;
        var result;
        var result5;
        var sumActifNetByYear;
        if (selectedValues == "EUR") {
          performa = await performences_eurs.findAll({
            attributes: ['fond_id', 'volatility1an', 'perfannu1an', 'volatility3an', 'perfannu3an', 'volatility5an', 'perfannu5an'], // Colonnes à sélectionner
            include: {
              model: fond, // Joindre la table fond
              attributes: ['nom_fond', 'categorie_globale'], // Aucune colonne sélectionnée de fond, juste pour la jointure
              where: { pays: req.params.id } // Filtrer par la société spécifiée
            },
            where: {
              date: Sequelize.literal(`(performences_eurs.date, fond_id) IN (SELECT MAX(date), fond_id FROM performences_eurs GROUP BY fond_id)`)
            }
          });
          const sumActifNetQuery = `
  SELECT SUM(latest_valorisations.actif_net_EUR) AS sumActifNet
  FROM (
      SELECT v.fund_id, MAX(v.date) AS latest_date
      FROM valorisations v
      INNER JOIN fond_investissements f ON v.fund_id = f.id
      WHERE f.pays = :pays
      GROUP BY v.fund_id
  ) AS latest_dates
  INNER JOIN valorisations latest_valorisations 
  ON latest_dates.fund_id = latest_valorisations.fund_id 
  AND latest_dates.latest_date = latest_valorisations.date
  WHERE latest_valorisations.actif_net_EUR != '#N/A';
`;

          [result] = await sequelize.query(sumActifNetQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });



          const latestDateQuery = `
    SELECT MAX(valorisations.date) AS latestDate
    FROM valorisations
    INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
    WHERE fond_investissements.pays = :pays
`;

          // Exécuter la requête avec les paramètres nécessaires
          [result5] = await sequelize.query(latestDateQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });

          latestDate = result5.latestDate;

          const latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net_EUR, YEAR(valorisations.date) AS year
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.pays = :pays
          GROUP BY valorisations.fund_id, year
          ORDER BY valorisations.date DESC
      `;

          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });

          sumActifNetByYear = {};
          fundCountByYear = {};
          // Calcul de la somme des actifs nets par année
          for (const { year } of latestValorisations) {
            fundCountByYear[year] = 0;
          }
          // Calcul de la somme des actifs nets par année
          for (const { year, actif_net_EUR } of latestValorisations) {
            if (!sumActifNetByYear[year]) {
              sumActifNetByYear[year] = 0;
            }
            if (actif_net_EUR !== '#N/A') {
              sumActifNetByYear[year] += parseFloat(actif_net_EUR);
              fundCountByYear[year] += 1; // Increment the count for the year

            }
          }
        } else if (selectedValues == "USD") {
          performa = await performences_usds.findAll({
            attributes: ['fond_id', 'volatility1an', 'perfannu1an', 'volatility3an', 'perfannu3an', 'volatility5an', 'perfannu5an'], // Colonnes à sélectionner
            include: {
              model: fond, // Joindre la table fond
              attributes: ['nom_fond', 'categorie_globale'], // Aucune colonne sélectionnée de fond, juste pour la jointure
              where: { pays: req.params.id } // Filtrer par la société spécifiée
            },
            where: {
              date: Sequelize.literal(`(performences_usds.date, fond_id) IN (SELECT MAX(date), fond_id FROM performences_usds GROUP BY fond_id)`)
            }
          });

          const sumActifNetQuery = `
  SELECT SUM(latest_valorisations.actif_net_USD) AS sumActifNet
  FROM (
      SELECT v.fund_id, MAX(v.date) AS latest_date
      FROM valorisations v
      INNER JOIN fond_investissements f ON v.fund_id = f.id
      WHERE f.pays = :pays
      GROUP BY v.fund_id
  ) AS latest_dates
  INNER JOIN valorisations latest_valorisations 
  ON latest_dates.fund_id = latest_valorisations.fund_id 
  AND latest_dates.latest_date = latest_valorisations.date
  WHERE latest_valorisations.actif_net_USD != '#N/A';
`;

          [result] = await sequelize.query(sumActifNetQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });



          const latestDateQuery = `
    SELECT MAX(valorisations.date) AS latestDate
    FROM valorisations
    INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
    WHERE fond_investissements.pays = :pays
`;

          // Exécuter la requête avec les paramètres nécessaires
          [result5] = await sequelize.query(latestDateQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });

          latestDate = result5.latestDate;

          const latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net_USD, YEAR(valorisations.date) AS year
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.pays = :pays
          GROUP BY valorisations.fund_id, year
          ORDER BY valorisations.date DESC
      `;

          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });

          sumActifNetByYear = {};
          fundCountByYear = {};
          // Calcul de la somme des actifs nets par année
          for (const { year } of latestValorisations) {
            fundCountByYear[year] = 0;
          }
          // Calcul de la somme des actifs nets par année
          for (const { year, actif_net_USD } of latestValorisations) {
            if (!sumActifNetByYear[year]) {
              sumActifNetByYear[year] = 0;
            }
            if (actif_net_USD !== '#N/A') {
              sumActifNetByYear[year] += parseFloat(actif_net_USD);
              fundCountByYear[year] += 1; // Increment the count for the year

            }
          }
        } else {
          performa = await performences.findAll({
            attributes: ['fond_id', 'volatility1an', 'perfannu1an', 'volatility3an', 'perfannu3an', 'volatility5an', 'perfannu5an'], // Colonnes à sélectionner
            include: {
              model: fond, // Joindre la table fond
              attributes: ['nom_fond', 'categorie_globale'], // Aucune colonne sélectionnée de fond, juste pour la jointure
              where: { pays: req.params.id } // Filtrer par la société spécifiée
            },
            where: {
              date: Sequelize.literal(`(performences.date, fond_id) IN (SELECT MAX(date), fond_id FROM performences GROUP BY fond_id)`)
            }
          });

          const sumActifNetQuery = `
  SELECT SUM(latest_valorisations.actif_net) AS sumActifNet
  FROM (
      SELECT v.fund_id, MAX(v.date) AS latest_date
      FROM valorisations v
      INNER JOIN fond_investissements f ON v.fund_id = f.id
      WHERE f.pays = :pays
      GROUP BY v.fund_id
  ) AS latest_dates
  INNER JOIN valorisations latest_valorisations 
  ON latest_dates.fund_id = latest_valorisations.fund_id 
  AND latest_dates.latest_date = latest_valorisations.date
  WHERE latest_valorisations.actif_net != '#N/A';
`;

          [result] = await sequelize.query(sumActifNetQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });



          const latestDateQuery = `
    SELECT MAX(valorisations.date) AS latestDate
    FROM valorisations
    INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
    WHERE fond_investissements.pays = :pays
`;

          // Exécuter la requête avec les paramètres nécessaires
          [result5] = await sequelize.query(latestDateQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });

          latestDate = result5.latestDate;

          const latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net, YEAR(valorisations.date) AS year
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.pays = :pays
          GROUP BY valorisations.fund_id, year
          ORDER BY valorisations.date DESC
      `;

          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });

          sumActifNetByYear = {};
          fundCountByYear = {};
          // Calcul de la somme des actifs nets par année
          for (const { year } of latestValorisations) {
            fundCountByYear[year] = 0;
          }
          // Calcul de la somme des actifs nets par année
          for (const { year, actif_net } of latestValorisations) {
            if (!sumActifNetByYear[year]) {
              sumActifNetByYear[year] = 0;
            }
            if (actif_net !== '#N/A') {
              sumActifNetByYear[year] += parseFloat(actif_net);
              fundCountByYear[year] += 1; // Increment the count for the year

            }
          }

        }


        // Renvoi des données
        res.json({
          code: 200,
          data: {
            performa,
            fundCountByYear: fundCountByYear,
            graph: sumActifNetByYear,
            societeData: societeData,
            nbrePart: nbrePart,
            nbresocietes:nbresocietes,
            latestDate: latestDate,
            sumActifNet: result.sumActifNet || 0 // Utilisation de 0 si la somme est null
          }
        });
      })
      .catch(error => {
        // En cas d'erreur, renvoyer un code d'erreur approprié
        res.status(500).json({ error: "Erreur lors de la récupération des données de la société." });
      });
  });
  app.get('/api/getPaysbyidstat/:id', async (req, res) => {
    // Recherche de la société par nom
    const selectedValues = req.query.query;

    pays_regulateurs.findOne({
      where: { pays: req.params.id }
    })
      .then(async response => {
        // Récupération des informations de base de la société
        const societeData = {
          nom: response.pays,

        };
        const repartition = await fond.findAll({
          attributes: ['categorie_globale', [sequelize.fn('COUNT', sequelize.col('id')), 'count']],
          where: {
            pays: req.params.id,
            categorie_globale: {
              [Sequelize.Op.not]: null
            }
          },
          group: ['categorie_globale']
        });
        var sumActifNetByCategory;
        var latestValorisations;
        var performa;
        var totalfondscompose = 0;
        var totalfonds = 0;
        var totalfondsignore = 0;
        totalfonds = await fond.count();

        if (selectedValues == "EUR") {
          performa = await performences_eurs.findAll({
            attributes: ['fond_id', 'volatility1an', 'perfannu1an', 'volatility3an', 'perfannu3an', 'volatility5an', 'perfannu5an'], // Colonnes à sélectionner
            include: {
              model: fond, // Joindre la table fond
              attributes: ['nom_fond', 'categorie_globale'], // Aucune colonne sélectionnée de fond, juste pour la jointure
              where: { pays: req.params.id } // Filtrer par la société spécifiée
            },
            where: {
              date: Sequelize.literal(`(performences_eurs.date, fond_id) IN (SELECT MAX(date), fond_id FROM performences_eurs GROUP BY fond_id)`)
            }
          });

          latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net_EUR
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.pays = :pays and fond_investissements.categorie_globale is not null
          GROUP BY valorisations.fund_id
          ORDER BY valorisations.date DESC
      `;
          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });
          sumActifNetByCategory = {};

          // Calcul de la somme des actifs nets par catégorie
          // Calcul de la somme des actifs nets par catégorie
          for (const { fund_id, actif_net_EUR } of latestValorisations) {
            const category = await findCategoryByFundId(fund_id); // Fonction à implémenter pour trouver la catégorie à partir de l'ID du fond

            if (!sumActifNetByCategory[category]) {
              sumActifNetByCategory[category] = 0;
            }
            if (actif_net_EUR !== '#N/A') {
              totalfondscompose += totalfondscompose;
              sumActifNetByCategory[category] += parseFloat(actif_net_EUR);
            }

          }
        } else if (selectedValues == "USD") {
          performa = await performences_usds.findAll({
            attributes: ['fond_id', 'volatility1an', 'perfannu1an', 'volatility3an', 'perfannu3an', 'volatility5an', 'perfannu5an'], // Colonnes à sélectionner
            include: {
              model: fond, // Joindre la table fond
              attributes: ['nom_fond', 'categorie_globale'], // Aucune colonne sélectionnée de fond, juste pour la jointure
              where: { pays: req.params.id } // Filtrer par la société spécifiée
            },
            where: {
              date: Sequelize.literal(`(performences_usds.date, fond_id) IN (SELECT MAX(date), fond_id FROM performences_usds GROUP BY fond_id)`)
            }
          });

          latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net_USD
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.pays = :pays and fond_investissements.categorie_globale is not null
          GROUP BY valorisations.fund_id
          ORDER BY valorisations.date DESC
      `;
          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });
          sumActifNetByCategory = {};

          // Calcul de la somme des actifs nets par catégorie
          // Calcul de la somme des actifs nets par catégorie
          for (const { fund_id, actif_net_USD } of latestValorisations) {
            const category = await findCategoryByFundId(fund_id); // Fonction à implémenter pour trouver la catégorie à partir de l'ID du fond

            if (!sumActifNetByCategory[category]) {
              sumActifNetByCategory[category] = 0;
            }

            if (actif_net_USD !== '#N/A') {
              totalfondscompose += totalfondscompose;

              sumActifNetByCategory[category] += parseFloat(actif_net_USD);
            }
          }
        } else {
          performa = await performences.findAll({
            attributes: ['fond_id', 'volatility1an', 'perfannu1an', 'volatility3an', 'perfannu3an', 'volatility5an', 'perfannu5an'], // Colonnes à sélectionner
            include: {
              model: fond, // Joindre la table fond
              attributes: ['nom_fond', 'categorie_globale'], // Aucune colonne sélectionnée de fond, juste pour la jointure
              where: { pays: req.params.id } // Filtrer par la société spécifiée
            },
            where: {
              date: Sequelize.literal(`(performences.date, fond_id) IN (SELECT MAX(date), fond_id FROM performences GROUP BY fond_id)`)
            }
          });

          latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.pays = :pays and fond_investissements.categorie_globale is not null
          GROUP BY valorisations.fund_id
          ORDER BY valorisations.date DESC
      `;
          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { pays: response.pays },
            type: sequelize.QueryTypes.SELECT
          });
          sumActifNetByCategory = {};

          // Calcul de la somme des actifs nets par catégorie
          // Calcul de la somme des actifs nets par catégorie
          for (const { fund_id, actif_net } of latestValorisations) {
            const category = await findCategoryByFundId(fund_id); // Fonction à implémenter pour trouver la catégorie à partir de l'ID du fond

            if (!sumActifNetByCategory[category]) {
              sumActifNetByCategory[category] = 0;
            }

            if (actif_net !== '#N/A') {
              totalfondscompose += totalfondscompose;
              sumActifNetByCategory[category] += parseFloat(actif_net);
            }
          }
        }
        totalfondsignore = totalfonds - totalfondscompose;
        // Renvoi des données
        res.json({
          code: 200,
          data: {
            performa,
            totalfondscompose,
            totalfonds,
            totalfondsignore,
            results2: sumActifNetByCategory,
            repartition: repartition,
            societe: societeData,

          }
        });
      })
      .catch(error => {
        // En cas d'erreur, renvoyer un code d'erreur approprié
        res.status(500).json({ error: "Erreur lors de la récupération des données de la société." });
      });
  });
  const findCategoryByFundId = async (fundId) => {
    // Implémentez ici la logique pour récupérer la catégorie à partir de l'identifiant du fond
    // Par exemple, vous pouvez exécuter une requête SQL pour obtenir la catégorie à partir de l'identifiant du fond

    // Exemple fictif de requête SQL
    const categoryQuery = `
        SELECT categorie_globale
        FROM fond_investissements
        WHERE id = :fundId
    `;

    // Exécutez la requête SQL avec le paramètre fundId
    const [result] = await sequelize.query(categoryQuery, {
      replacements: { fundId: fundId },
      type: sequelize.QueryTypes.SELECT
    });

    // Retournez la catégorie extraite de la requête
    return result.categorie_globale;
  };
  app.get('/api/getSocietebyidstat/:id', async (req, res) => {
    // Recherche de la société par nom
    const selectedValues = req.query.query;

    societe.findOne({
      where: { nom: req.params.id }
    })
      .then(async response => {
        // Récupération des informations de base de la société
        const societeData = {
          nom: response.nom,
          description: response.description,
          email: response.email,
          tel: response.tel,
          numeroagrement: response.numeroagrement,
          pays: response.pays,
          regulateur: response.regulateur,
          dateimmatriculation: response.dateimmatriculation,
          site_web: response.site_web,
          devise: response.devise
        };

        const repartition = await fond.findAll({
          attributes: ['categorie_globale', [sequelize.fn('COUNT', sequelize.col('id')), 'count']],
          where: {
            societe_gestion: req.params.id,
            categorie_globale: {
              [Sequelize.Op.not]: null
            }
          },
          group: ['categorie_globale']
        });
        var sumActifNetByCategory;
        var latestValorisations;
        var performa;
        var totalfondscompose = 0;
        var totalfonds = 0;
        var totalfondsignore = 0;
        totalfonds = await fond.count();
        if (selectedValues == "EUR") {
          performa = await performences_eurs.findAll({
            attributes: ['fond_id', 'volatility1an', 'perfannu1an', 'volatility3an', 'perfannu3an', 'volatility5an', 'perfannu5an'], // Colonnes à sélectionner
            include: {
              model: fond, // Joindre la table fond
              attributes: ['nom_fond', 'categorie_globale'], // Aucune colonne sélectionnée de fond, juste pour la jointure
              where: { societe_gestion: req.params.id } // Filtrer par la société spécifiée
            },
            where: {
              date: Sequelize.literal(`(performences_eurs.date, fond_id) IN (SELECT MAX(date), fond_id FROM performences_eurs GROUP BY fond_id)`)
            }
          });

          latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net_EUR
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.societe_gestion = :societeNom and  fond_investissements.categorie_globale is not null
          GROUP BY valorisations.fund_id
          ORDER BY valorisations.date DESC
      `;
          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });
          sumActifNetByCategory = {};

          // Calcul de la somme des actifs nets par catégorie
          // Calcul de la somme des actifs nets par catégorie
          for (const { fund_id, actif_net_EUR } of latestValorisations) {
            const category = await findCategoryByFundId(fund_id); // Fonction à implémenter pour trouver la catégorie à partir de l'ID du fond

            if (!sumActifNetByCategory[category]) {
              sumActifNetByCategory[category] = 0;
            }

            if (actif_net_EUR !== '#N/A') {
              totalfondscompose += totalfondscompose;

              sumActifNetByCategory[category] += parseFloat(actif_net_EUR);
            }
          }
        } else if (selectedValues == "USD") {
          performa = await performences_usds.findAll({
            attributes: ['fond_id', 'volatility1an', 'perfannu1an', 'volatility3an', 'perfannu3an', 'volatility5an', 'perfannu5an'], // Colonnes à sélectionner
            include: {
              model: fond, // Joindre la table fond
              attributes: ['nom_fond', 'categorie_globale'], // Aucune colonne sélectionnée de fond, juste pour la jointure
              where: { societe_gestion: req.params.id } // Filtrer par la société spécifiée
            },
            where: {
              date: Sequelize.literal(`(performences_usds.date, fond_id) IN (SELECT MAX(date), fond_id FROM performences_usds GROUP BY fond_id)`)
            }
          });

          latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net_USD
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.societe_gestion = :societeNom and  fond_investissements.categorie_globale is not null
          GROUP BY valorisations.fund_id
          ORDER BY valorisations.date DESC
      `;
          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });
          sumActifNetByCategory = {};

          // Calcul de la somme des actifs nets par catégorie
          // Calcul de la somme des actifs nets par catégorie
          for (const { fund_id, actif_net_USD } of latestValorisations) {
            const category = await findCategoryByFundId(fund_id); // Fonction à implémenter pour trouver la catégorie à partir de l'ID du fond

            if (!sumActifNetByCategory[category]) {
              sumActifNetByCategory[category] = 0;
            }

            if (actif_net_USD !== '#N/A') {
              totalfondscompose += totalfondscompose;

              sumActifNetByCategory[category] += parseFloat(actif_net_USD);
            }
          }
        } else {
          performa = await performences.findAll({
            attributes: ['fond_id', 'volatility1an', 'perfannu1an', 'volatility3an', 'perfannu3an', 'volatility5an', 'perfannu5an'], // Colonnes à sélectionner
            include: {
              model: fond, // Joindre la table fond
              attributes: ['nom_fond', 'categorie_globale'], // Aucune colonne sélectionnée de fond, juste pour la jointure
              where: { societe_gestion: req.params.id } // Filtrer par la société spécifiée
            },
            where: {
              date: Sequelize.literal(`(performences.date, fond_id) IN (SELECT MAX(date), fond_id FROM performences GROUP BY fond_id)`)
            }
          });

          latestValorisationsQuery = `
          SELECT valorisations.fund_id, valorisations.actif_net
          FROM valorisations
          INNER JOIN fond_investissements ON valorisations.fund_id = fond_investissements.id
          WHERE fond_investissements.societe_gestion = :societeNom and  fond_investissements.categorie_globale is not null
          GROUP BY valorisations.fund_id
          ORDER BY valorisations.date DESC
      `;
          // Exécuter la requête pour obtenir les dernières valorisations pour chaque fonds
          latestValorisations = await sequelize.query(latestValorisationsQuery, {
            replacements: { societeNom: response.nom },
            type: sequelize.QueryTypes.SELECT
          });
          sumActifNetByCategory = {};

          // Calcul de la somme des actifs nets par catégorie
          // Calcul de la somme des actifs nets par catégorie
          for (const { fund_id, actif_net } of latestValorisations) {
            const category = await findCategoryByFundId(fund_id); // Fonction à implémenter pour trouver la catégorie à partir de l'ID du fond

            if (!sumActifNetByCategory[category]) {
              sumActifNetByCategory[category] = 0;
            }

            if (actif_net !== '#N/A') {
              totalfondscompose += totalfondscompose;

              sumActifNetByCategory[category] += parseFloat(actif_net);
            }
          }
        }
        // Renvoi des données
        res.json({
          code: 200,
          data: {
            performa,
            totalfondscompose,
            totalfonds,
            totalfondsignore,
            results2: sumActifNetByCategory,
            repartition: repartition,
            societe: societeData,

          }
        });
      })
      .catch(error => {
        // En cas d'erreur, renvoyer un code d'erreur approprié
        res.status(500).json({ error: "Erreur lors de la récupération des données de la société." });
      });
  });
  app.post('/api/listeproduitsociete/:id', async (req, res) => {
    const formData = req.body.formData;
    const selectedValues = req.query.query;
    const selectedCategorie = req.query.selectedcategorie; // Corrected variable name

    let valuesArray; // Déclaration en dehors de la condition

    if (selectedValues) {
      valuesArray = selectedValues.split(',');
    }

    let whereClause = { societe_gestion: req.params.id }; // Utilisation de let au lieu de const

    if (valuesArray) {
      whereClause = {
        [Op.or]: valuesArray.map(value => ({
          id: value // Créer une condition pour chaque valeur dans valuesArray
        }))
      };
    }

    if (typeof selectedCategorie !== 'undefined' && selectedCategorie !== 'undefined') {
      whereClause.categorie_globale = selectedCategorie; // Filtrer par la catégorie globale si elle est renseignée
    }

    const funds = await fond.findAll({
      where: {
        [Op.and]: [whereClause] // Utiliser Op.and pour combiner les conditions
      }
    });


    const fundsWithAllData = await Promise.all(funds.map(async (fund) => {
      try {
        const fundData = await fond.findByPk(fund.id);

        if (!fundData) {
          return { error: `Aucun élément trouvé pour l'ID ${fund.id}` };
        }

        // Create an array of promises for the external API calls
        const promessesPerformances = performences.findOne({
          where: {
            fond_id: fund.id,
          },
          order: [
            ['date', 'DESC']
          ]
        })
          .catch((error) => {
            console.error('Erreur lors de la recherche des performances :', error);
            return { error: 'Erreur lors de la recherche des performances.' };
          });

        // Use Promise.all to wait for all queries to finish
        const [performanceResults] = await Promise.all([promessesPerformances]);

        // Combine data from both sources
        const fundCombinedData = {
          id: fund.id,
          fundData: fundData.toJSON(),
          performanceData: performanceResults.toJSON(),
        };

        return fundCombinedData;
      } catch (error) {
        console.error('Erreur lors de la recherche des données :', error);
        return { error: 'Une erreur est survenue lors de la récupération des données.' };
      }
    }));



    let resultats = fundsWithAllData;


    // Envoyez les résultats en tant que réponse JSON
    res.json({
      code: 200,
      data: { funds: resultats }
    });
  });

  app.post('/api/listeopcvm', async (req, res) => {
    const formData = req.body.formData;
    const selectedValues = req.query.query;
    const selectedpays = req.query.selectedpays; // Corrected variable name
    const selectedsociete=req.query.selectedsociete;

    let valuesArray; // Déclaration en dehors de la condition

    if (selectedValues) {
      valuesArray = selectedValues.split(',');
    }

    let whereClause = {}; // Utilisation de let au lieu de const

    if (valuesArray) {
      whereClause = {
        [Op.or]: valuesArray.map(value => ({
          id: value // Créer une condition pour chaque valeur dans valuesArray
        }))
      };
    }

    if (selectedpays && selectedpays != 'undefined') {
      whereClause.pays = selectedpays; // Filtrer par la catégorie globale si elle est renseignée
    } else {
      // Gérer le cas où selectedpays n'est pas défini
      console.log("selectedpays n'est pas défini");
      // Ou effectuer une autre action appropriée, comme attribuer une valeur par défaut à whereClause.pays
    }

    if (selectedsociete && selectedsociete != 'undefined') {
      whereClause.societe_gestion = selectedsociete; // Filtrer par la catégorie globale si elle est renseignée
    } else {
      // Gérer le cas où selectedpays n'est pas défini
      console.log("selectedsociete n'est pas défini");
      // Ou effectuer une autre action appropriée, comme attribuer une valeur par défaut à whereClause.pays
    }

    const fondall = await fond.findAll({
      where: whereClause, // Pas besoin d'encapsuler dans Op.and, oùClause est déjà un objet
      group: ['nom_fond'],
      order: [['nom_fond', 'ASC']]
    });

    // Pour stocker les résultats finaux
    let resultats = [];

  




    // Envoyez les résultats en tant que réponse JSON
    res.json({
      code: 200,
      data: { fonds: fondall }
    });
  });

  app.post('/api/listesociete', async (req, res) => {
    const formData = req.body.formData;
    const selectedValues = req.query.query;
    const selectedpays = req.query.selectedpays; // Corrected variable name

    let valuesArray; // Déclaration en dehors de la condition

    if (selectedValues) {
      valuesArray = selectedValues.split(',');
    }

    let whereClause = {}; // Utilisation de let au lieu de const

    if (valuesArray) {
      whereClause = {
        [Op.or]: valuesArray.map(value => ({
          nom: value // Créer une condition pour chaque valeur dans valuesArray
        }))
      };
    }

    if (selectedpays && selectedpays != 'undefined') {
      whereClause.pays = selectedpays; // Filtrer par la catégorie globale si elle est renseignée
    } else {
      // Gérer le cas où selectedpays n'est pas défini
      console.log("selectedpays n'est pas défini");
      // Ou effectuer une autre action appropriée, comme attribuer une valeur par défaut à whereClause.pays
    }

    const societes = await societe.findAll({
      where: whereClause, // Pas besoin d'encapsuler dans Op.and, oùClause est déjà un objet
      group: ['nom'],
      order: [['nom', 'ASC']]
    });

    // Pour stocker les résultats finaux
    let resultats = [];

    // Boucle à travers chaque société pour obtenir le nombre de fonds et la somme des actifs nets
    for (const soc of societes) {
      const nombreFonds = await fond.count({ where: { societe_gestion: soc.nom } });
      // const fonds = await fond.findAll({ where: { societe_gestion: soc.nom } });
      let sommeActifNet = 0;

      // Parcourir tous les fonds de la société
      /*  for (const f of fonds) {
          const dernierEnregistrement = await vl.findOne({
            include: [{ model: fond, where: { societe_gestion: soc.nom } }], // Effectuer une jointure avec la table fond pour récupérer les informations sur le fond
            order: [['date', 'DESC']] // Trier par date en ordre décroissant pour obtenir le dernier enregistrement
          });
   
          if (dernierEnregistrement) {
            sommeActifNet += dernierEnregistrement.actif_net;
          }
        }*/
      // Stocker les résultats dans un objet
      const resultatSociete = {
        nom: soc.nom,
        pays: soc.pays,
        // Ajouter le nombre de fonds et la somme des actifs nets à l'objet
        nombreFonds: nombreFonds,
        sommeActifNet: sommeActifNet || 0 // Assurer qu'il y a une valeur par défaut si aucune somme n'est trouvée
      };

      // Ajouter l'objet résultat à la liste des résultats
      resultats.push(resultatSociete);
    }







    // Envoyez les résultats en tant que réponse JSON
    res.json({
      code: 200,
      data: { societes: resultats }
    });
  });

  /*app.get('/api/getPaysbyidfisrt/:id', async (req, res) => {
    // Recherche de la société par nom
    pays_regulateurs.findOne({
      where: { pays: req.params.id }
    })
      .then(async response => {
        // Récupération des informations de base de la société
        const paysData = {
          nom: response.pays,
   
        };
   
        // Recherche du nombre de fonds associés à cette société
        const nbrePart = await fond.count({ where: { pays: req.params.id } });
   
        // Recherche du nombre de fonds associés à cette société
        const nbresoci = await societe.count({ where: { pays: req.params.id } });
   
   
   
        // Renvoi des données
        res.json({
          code: 200,
          data: {
            paysData: paysData.nom,
            nbrePart: nbrePart,
            nbreS: nbresoci
          }
        });
      })
      .catch(error => {
        // En cas d'erreur, renvoyer un code d'erreur approprié
        res.status(500).json({ error: "Erreur lors de la récupération des données de la société." });
      });
  });*/
  app.post('/api/listeproduitpayssociete/:id', async (req, res) => {
    const formData = req.body.formData;
    const selectedValues = req.query.query;
    const selectedCategorie = req.query.selectedcategorie; // Corrected variable name

    let valuesArray; // Déclaration en dehors de la condition

    if (selectedValues) {
      valuesArray = selectedValues.split(',');
    }

    let whereClause = { pays: req.params.id }; // Utilisation de let au lieu de const

    if (valuesArray) {
      whereClause = {
        [Op.or]: valuesArray.map(value => ({
          id: value // Créer une condition pour chaque valeur dans valuesArray
        }))
      };
    }

    if (typeof selectedCategorie !== 'undefined') {
      whereClause.categorie_globale = selectedCategorie; // Filtrer par la catégorie globale si elle est renseignée
    }

    const funds = await fond.findAll({
      where: {
        [Op.and]: [whereClause] // Utiliser Op.and pour combiner les conditions
      }
    });


    const fundsWithAllData = await Promise.all(funds.map(async (fund) => {
      try {
        const fundData = await fond.findByPk(fund.id);

        if (!fundData) {
          return { error: `Aucun élément trouvé pour l'ID ${fund.id}` };
        }

        // Create an array of promises for the external API calls
        const promessesPerformances = performences.findOne({
          where: {
            fond_id: fund.id,
          },
          order: [
            ['date', 'DESC']
          ]
        })
          .catch((error) => {
            console.error('Erreur lors de la recherche des performances :', error);
            return { error: 'Erreur lors de la recherche des performances.' };
          });

        // Use Promise.all to wait for all queries to finish
        const [performanceResults] = await Promise.all([promessesPerformances]);

        // Combine data from both sources
        const fundCombinedData = {
          id: fund.id,
          fundData: fundData.toJSON(),
          performanceData: performanceResults.toJSON(),
        };

        return fundCombinedData;
      } catch (error) {
        console.error('Erreur lors de la recherche des données :', error);
        return { error: 'Une erreur est survenue lors de la récupération des données.' };
      }
    }));



    let resultats = fundsWithAllData;


    // Envoyez les résultats en tant que réponse JSON
    res.json({
      code: 200,
      data: { funds: resultats }
    });
  });
  app.post('/api/listesocietepays/:id', async (req, res) => {
    const formData = req.body.formData;
    const selectedValues = req.query.query;
    const selectedpays = req.query.selectedpays; // Corrected variable name

    let valuesArray; // Déclaration en dehors de la condition

    if (selectedValues) {
      valuesArray = selectedValues.split(',');
    }

    let whereClause = { pays: req.params.id }; // Utilisation de let au lieu de const

    if (valuesArray) {
      whereClause = {
        [Op.or]: valuesArray.map(value => ({
          nom: value // Créer une condition pour chaque valeur dans valuesArray
        }))
      };
    }



    const societes = await societe.findAll({
      where: whereClause // Pas besoin d'encapsuler dans Op.and, oùClause est déjà un objet

    });

    // Pour stocker les résultats finaux
    let resultats = [];

    // Boucle à travers chaque société pour obtenir le nombre de fonds et la somme des actifs nets
    for (const soc of societes) {
      const nombreFonds = await fond.count({ where: { societe_gestion: soc.nom } });
      //   const fonds = await fond.findAll({ where: { societe_gestion: soc.nom } });
      let sommeActifNet = 0;

      // Parcourir tous les fonds de la société
      /*  for (const f of fonds) {
          const dernierEnregistrement = await vl.findOne({
            include: [{ model: fond, where: { societe_gestion: soc.nom } }], // Effectuer une jointure avec la table fond pour récupérer les informations sur le fond
            order: [['date', 'DESC']] // Trier par date en ordre décroissant pour obtenir le dernier enregistrement
          });
   
          if (dernierEnregistrement) {
            sommeActifNet += dernierEnregistrement.actif_net;
          }
        }*/
      // Stocker les résultats dans un objet
      const resultatSociete = {
        nom: soc.nom,
        pays: soc.pays,
        // Ajouter le nombre de fonds et la somme des actifs nets à l'objet
        nombreFonds: nombreFonds,
        sommeActifNet: sommeActifNet || 0 // Assurer qu'il y a une valeur par défaut si aucune somme n'est trouvée
      };

      // Ajouter l'objet résultat à la liste des résultats
      resultats.push(resultatSociete);
    }







    // Envoyez les résultats en tant que réponse JSON
    res.json({
      code: 200,
      data: { societes: resultats }
    });
  });

  app.get('/api/getDevises', async (req, res) => {
    devises.findAll({
      //where:{id:1}
    })
      .then(response => {

        const devises = response.map((data) => ({
          id: data.id,
          devise: data.Symbole,


        }));
        res.json({
          code: 200,
          data: {
            devises
          }
        })
      })
  })
  app.post('/api/assignportefeuille', async (req, res) => {
    const { portfolioId, indices, categories, tsr, tacc } = req.body;

    // Appeler l'endpoint pour récupérer les performances
    const performanceResponse = await fetch(`${urll}/api/valLiqportefeuillewithindice/${portfolioId}/${indices}/${tsr}/${categories}`);
    if (performanceResponse.status !== 200) {
      return res.status(performanceResponse.status).json({ message: 'Error fetching performance data' });
    }
    const performanceData = await performanceResponse.json();

    // Répondre avec succès et les données du GET endpoint
    res.json({
      code: 200,
      data: {
        performanceData
      }
    });
  });

  app.get('/api/getIndice', async (req, res) => {
    try {
      const indices = await indice.findAll({
        attributes: [
          [sequelize.fn('DISTINCT', sequelize.col('id_indice')), 'nom_indice']
        ]
      });



      res.json({
        code: 200,
        data: {
          indices: indices.map(index => ({ id: index.id, name: index.nom_indice })),
        }
      });
    } catch (error) {
      res.status(500).json({ error: 'Error fetching data' });
    }
  });

  app.get('/api/getCategories', async (req, res) => {
    try {
      const categoriesRegion = await fond.findAll({
        attributes: [
          [sequelize.fn('DISTINCT', sequelize.col('categorie_regional')), 'categorie_regional']
        ]
      });

      const categoriesNational = await fond.findAll({
        attributes: [
          [sequelize.fn('DISTINCT', sequelize.col('categorie_national')), 'categorie_national']
        ]
      });

      // Filtrer les valeurs vides
      const filteredCategoriesRegion = categoriesRegion
        .map(item => item.get('categorie_regional'))
        .filter(categorie => categorie !== null && categorie !== '');

      const filteredCategoriesNational = categoriesNational
        .map(item => item.get('categorie_national'))
        .filter(categorie => categorie !== null && categorie !== '');

      const distinctCategorieregional = filteredCategoriesRegion.map(category => category);
      const distinctNationalCategories = filteredCategoriesNational.map(category => category);

      res.json({
        code: 200,
        data: {
          categoriesRegional: distinctCategorieregional,
          categoriesNational: distinctNationalCategories
        }
      });
    } catch (error) {
      res.status(500).json({ error: 'Error fetching data' });
    }
  });

  app.get('/api/valLiqportefeuillewithindice/:id/:indice/:tsr/:categorie', async (req, res) => {

    const portefeuilleId = parseInt(req.params.id)
    const response = await portefeuille_vl_cumul.findAll({
      where: {
        portefeuille_id: portefeuilleId
      },
      order: [
        ['date', 'ASC']
      ]
    });
    const response1 = await indice.findAll({
      where: {
        id_indice: req.params.indice
      },
      order: [
        ['date', 'ASC']
      ]
    });


    if (response.length > 0) {
      // Convertir les dates en format YYYY-MM-DD
      const dates = response.map(data => moment(data.date).format('YYYY-MM-DD'));
      const values = response.map(data => parseFloat(data.base_100_bis));

      const datesInd = response1.map(data => moment(data.date).format('YYYY-MM-DD'));
      const valuesInd = response1.map(data => data.valeur);

      // Trouver les dates communes entre les deux ensembles de données
      const commonDates = dates.filter(date => datesInd.includes(date));

      // Récupérer les valeurs pour les dates communes
      const commonValues = commonDates.map(date => ({
        date,
        value: values[dates.indexOf(date)],
        indValueRef: valuesInd[datesInd.indexOf(date)]
      }));



      const lastDate = dates[dates.length - 1];

      const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);
      const baseUrl = urll; // Remplacez par votre URL de base
      const lastValResponse = await fetch(`${baseUrl}/api/performancesportefeuillewithindice/fond/${portefeuilleId}/${req.params.categorie}/${lastDate}`);

      const lastValData = await lastValResponse.json();

      const last1ansRatiosResponse = await fetch(`${baseUrl}/api/ratiosportfeuillewithindice/1/${portefeuilleId}/${parseFloat(req.params.tsr)}/${req.params.indice}`);

      if (!last1ansRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const last1ansRatiosData = await last1ansRatiosResponse.json();

      const lastRatiosResponse = await fetch(`${baseUrl}/api/ratiosportfeuillewithindice/3/${portefeuilleId}/${parseFloat(req.params.tsr)}/${req.params.indice}`);

      if (!lastRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const lastRatiosData = await lastRatiosResponse.json();

      const last5ansRatiosResponse = await fetch(`${baseUrl}/api/ratiosportfeuillewithindice/5/${portefeuilleId}/${parseFloat(req.params.tsr)}/${req.params.indice}`);

      if (!last5ansRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const last5ansRatiosData = await last5ansRatiosResponse.json();



      res.json({
        code: 200,
        data: {
          lastDate,
          graphs: commonValues,
          lastdatepreviousmonth,
          performances: lastValData,
          ratios3a: lastRatiosData,
          ratios1a: last1ansRatiosData,
          ratios5a: last5ansRatiosData
        }
      });
    } else {
      res.status(500).json({ message: 'Erreur lors de la récupération des données' });

    }
    /* } catch (error) {
       console.error('Erreur lors de la récupération des données:', error);
       res.status(500).json({ message: 'Erreur lors de la récupération des données' });
     }*/
  });

  app.get('/api/performancesportefeuillewithindice/fond/:id/:categorie/:date', async (req, res) => {

    performancesCategorie = await getPerformancesByCategorynow(req.params.categorie, "2024-03-22");


    portefeuille_vl_cumul.findAll({
      where: {
        portefeuille_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        let lastValuep = response[response.length - 1].base_100_bis; // Dernière valeur


        // Valeurs liquidatives
        const values = response.map((data) => data.base_100_bis);
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));

        //  const values = response.map((data) => data.value);
        const lastValue = lastValuep;
        //  const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const lastDate = dates[dates.length - 1]

        const targetYear = groupDatesByYear(dates).length

        const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);

        // Calcul des performances glissantes
        const previousValue = values[values.length - 2];
        const perfVeille = calculatePerformance(lastValue, previousValue);
        const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
        const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
        const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
        const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
        const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
        const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
        const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
        const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
        const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
        const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
        const perf15Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]);
        const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
        const perfOrigine = calculatePerformance(lastValue, values[0]);

        //Performances fin de mois
        const targetDate1An = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
        const targetDate3Ans = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
        const targetDate5Ans = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
        const targetDate8Ans = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
        const targetDate10Ans = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
        const targetDate12Ans = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
        const targetDate15Ans = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
        const targetDate20Ans = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
        const targetDateOrigine = groupDatesByMonth(dates)[0]
        const perfFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        console.log(findLastDateOfPreviousMonth(dates))
        //Performances annualizées fin de mois
        const perfFindeMoisAnnualized1An = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
        const perfFindeMoisAnnualized3Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
        const perfFindeMoisAnnualized5Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
        const perfFindeMoisAnnualized8Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
        const perfFindeMoisAnnualized10Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
        const perfFindeMoisAnnualized12Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
        const perfFindeMoisAnnualized15Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates)))], 15);
        const perfFindeMoisAnnualized20Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates)))], 20);
        const perfFindeMoisAnnualizedOrigine = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);


        //Performances cumulées fin de mois
        const perfCumuleeFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfCumuleeFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfCumuleeFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfCumuleeFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfCumuleeFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfCumuleeFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfCumuleeFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfCumuleeFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfCumuleeFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        //Performances annualizées à date
        const perfAnnualizedtodate1An = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1);
        const perfAnnualizedtodate3Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3);
        const perfAnnualizedtodate5Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5);
        const perfAnnualizedtodate8Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8);
        const perfAnnualizedtodate10Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10);
        const perfAnnualizedtodate12Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12);
        const perfAnnualizedtodate15Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15);
        const perfAnnualizedtodate20Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20);
        const perfAnnualizedtodateOrigine = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);
        //Performances  annee calendaire
        const ArrayDates = groupDatesByYear(dates);
        const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
        const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
        const multipliedValues = adaptValues1.map(item => {
          const year = item[0];
          const value1 = item[1];
          const value3 = item[2] * 100; // Multipliez la troisième position par 100

          return [year, value1, value3];
        });


        console.log(multipliedValues);
        res.json({
          code: 200,
          data: {
            portefeuille: req.params.id,
            lastdatepreviousmonth: lastdatepreviousmonth,
            //    perf3Moisactif_net: perf3Moisactif_net,
            perfVeille: perfVeille,
            perf4Semaines: perf4Semaines,
            perf1erJanvier: perf1erJanvier,
            perf3Mois: perf3Mois,
            perf6Mois: perf6Mois,
            perf1An: perf1An,
            perf3Ans: perf3Ans,
            perf5Ans: perf5Ans,
            perf8Ans: perf8Ans,
            perf10Ans: perf10Ans,
            perf12Ans: perf12Ans,
            perf15Ans: perf15Ans,
            perf20Ans: perf20Ans,
            perfOrigine: perfOrigine,
            perfFindeMois1An: perfFindeMois1An,
            perfFindeMois3Ans: perfFindeMois3Ans,
            perfFindeMois5Ans: perfFindeMois5Ans,
            perfFindeMois8Ans: perfFindeMois8Ans,
            perfFindeMois10Ans: perfFindeMois10Ans,
            perfFindeMois12Ans: perfFindeMois12Ans,
            perfFindeMois15Ans: perfFindeMois15Ans,
            perfFindeMois20Ans: perfFindeMois20Ans,
            perfFindeMoisOrigine: perfFindeMoisOrigine,
            perfFindeMoisAnnualized1An: perfFindeMoisAnnualized1An,
            perfFindeMoisAnnualized3An: perfFindeMoisAnnualized3Ans,
            perfFindeMoisAnnualized5Ans: perfFindeMoisAnnualized5Ans,
            perfFindeMoisAnnualized8Ans: perfFindeMoisAnnualized8Ans,
            perfFindeMoisAnnualized10Ans: perfFindeMoisAnnualized10Ans,
            perfFindeMoisAnnualized12Ans: perfFindeMoisAnnualized12Ans,
            perfFindeMoisAnnualized15Ans: perfFindeMoisAnnualized15Ans,
            perfFindeMoisAnnualized20Ans: perfFindeMoisAnnualized20Ans,
            perfFindeMoisAnnualizedOrigine: perfFindeMoisAnnualizedOrigine,
            perfCumuleeFindeMois1An: perfCumuleeFindeMois1An,
            perfCumuleeFindeMois3Ans: perfCumuleeFindeMois3Ans,
            perfCumuleeFindeMois5Ans: perfCumuleeFindeMois5Ans,
            perfCumuleeFindeMois8Ans: perfCumuleeFindeMois8Ans,
            perfCumuleeFindeMois10Ans: perfCumuleeFindeMois10Ans,
            perfCumuleeFindeMois12Ans: perfCumuleeFindeMois12Ans,
            perfCumuleeFindeMois15Ans: perfCumuleeFindeMois15Ans,
            perfCumuleeFindeMois20Ans: perfCumuleeFindeMois20Ans,
            perfCumuleeFindeMoisOrigine: perfCumuleeFindeMoisOrigine,
            perfAnnualizedtodate1An: perfAnnualizedtodate1An,
            perfAnnualizedtodate3Ans: perfAnnualizedtodate3Ans,
            perfAnnualizedtodate5Ans: perfAnnualizedtodate5Ans,
            perfAnnualizedtodate8Ans: perfAnnualizedtodate8Ans,
            perfAnnualizedtodate10Ans: perfAnnualizedtodate10Ans,
            perfAnnualizedtodate12Ans: perfAnnualizedtodate12Ans,
            perfAnnualizedtodate15Ans: perfAnnualizedtodate15Ans,
            perfAnnualizedtodate20Ans: perfAnnualizedtodate20Ans,
            perfAnnualizedtodateOrigine: perfAnnualizedtodateOrigine,
            adaptValues1: multipliedValues,
            performancesCategorie: performancesCategorie
          }
        })

      })
  })

  app.get('/api/ratiosportfeuillewithindice/:year/:id/:tsr/:indice', async (req, res) => {
    try {


      const response = await portefeuille_vl_cumul.findAll({
        where: {
          portefeuille_id: req.params.id
        },
        order: [
          ['date', 'DESC']
        ]
      })
      const response1 = await indice.findAll({
        where: {
          id_indice: req.params.indice
        },
        order: [
          ['date', 'DESC']
        ]
      })

      ////////////////////////////

      // Convertir les dates en format YYYY-MM-DD
      const dates = response.map(data => moment(data.date).format('YYYY-MM-DD'));
      const values = response.map(data => parseFloat(data.base_100_bis));

      const datesInd = response1.map(data => moment(data.date).format('YYYY-MM-DD'));
      const valuesInd = response1.map(data => data.valeur);

      // Trouver les dates communes entre les deux ensembles de données
      const commonDates = dates.filter(date => datesInd.includes(date));

      // Récupérer les valeurs pour les dates communes
      const commonValues = commonDates.map(date => ({
        date,
        value: values[dates.indexOf(date)],
        indValueRef: valuesInd[datesInd.indexOf(date)]
      }));

      const datescomun = commonValues.map(commun => commun.date);
      const valuescomun = commonValues.map(commun => commun.value);
      const valuesindcomun = commonValues.map(commun => commun.indValueRef);

      // Exécuter les calculs en fonction de l'année
      const tauxsr = parseFloat(req.params.tsr);


      const lastPreviousDate = findLastDateOfPreviousMonth(datescomun);
      const lastValue = commonValues.find(cv => cv.date === lastPreviousDate)?.value;
      const lastValueInd = commonValues.find(cv => cv.date === lastPreviousDate)?.indValueRef;

      // Période de calcul (ajustée pour les dates communes)
      // Trouver l'index de lastPreviousDate dans commonDates
      const startIndex = commonDates.indexOf(lastPreviousDate);
      // Extraire les données depuis lastPreviousDate jusqu'à la fin des données
      const yArrayValuesnew = commonValues.slice(startIndex).map(cv => cv.value);
      const yArrayDatesnew = commonValues.slice(startIndex).map(cv => cv.date);
      const yArrayValuesindifrefnew = commonValues.slice(startIndex).map(cv => cv.indValueRef);

      const donneesarray = yArrayValuesnew.map((value, i) => ({ date: yArrayDatesnew[i], value }));
      const donneesarrayindref = yArrayValuesindifrefnew.map((value, i) => ({ date: yArrayDatesnew[i], value }));


      const numberOfUniqueYears = calculateYearsBetweenDates(datescomun);

      if (req.params.year === "1" && numberOfUniqueYears >= 1) {
        handleCalculations(req, res, donneesarray, donneesarrayindref, datescomun, values, valuesindcomun, lastPreviousDate, 1, 1, tauxsr);
      } else if (req.params.year === "3" && numberOfUniqueYears >= 3) {
        handleCalculations(req, res, donneesarray, donneesarrayindref, datescomun, values, valuesindcomun, lastPreviousDate, 3, 1, tauxsr);
      } else if (req.params.year === "5" && numberOfUniqueYears >= 5) {
        handleCalculations(req, res, donneesarray, donneesarrayindref, datescomun, values, valuesindcomun, lastPreviousDate, 5, 1, tauxsr);
      } else {
        res.status(200).json({ code: 200, message: "Invalid year parameter" });
      }
    } catch (error) {
      console.error('Erreur lors du traitement des ratios:', error);
      res.status(500).json({ code: 500, message: 'Erreur interne du serveur' });
    }
  });

  function calculateYearsBetweenDates(dates) {
    // Convertir les dates en objets Date
    const minDate = new Date(Math.min(...dates.map(date => new Date(date))));
    const maxDate = new Date(Math.max(...dates.map(date => new Date(date))));

    // Calculer la différence en millisecondes
    const diffInMs = maxDate - minDate;

    // Convertir la différence en années
    const diffInYears = diffInMs / (1000 * 60 * 60 * 24 * 365.25);

    return diffInYears;
  }

  app.post('/api/calculatePerformance', async (req, res) => {
    const { selectedIndex, selectedCategory } = req.body;

    // Implémentez ici votre logique pour calculer les performances
    const performances = await calculatePerformance(selectedIndex, selectedCategory);

    res.json({
      code: 200,
      data: performances
    });
  });

  app.get('/api/getSocietes', async (req, res) => {
    societe.findAll({
      //where:{id:1}
    })
      .then(response => {

        const societes = response.map((data) => ({
          id: data.id,
          name: data.nom,
          description: data.description,
          email: data.email,
          tel: data.tel,

        }));
        res.json({
          code: 200,
          data: {
            societes
          }
        })
      })
  })
  app.get('/api/getSocietesbypays/:pays', async (req, res) => {
    const pays = req.params.pays; // Use req.params to access route parameters

    societe.findAll({
      where: { pays: pays }
    })
      .then(response => {

        const societes = response.map((data) => ({
          id: data.id,
          name: data.nom,
          description: data.description,
          email: data.email,
          tel: data.tel,

        }));
        res.json({
          code: 200,
          data: {
            societes
          }
        })
      })
  })
  app.get('/api/getPays', (req, res) => {
    // Récupérez la liste des pays depuis la base de données
    pays_regulateurs
      .findAll({
        attributes: ['id', 'pays'], // Ajoutez les colonnes nécessaires
        group: ['pays'],
        order: [['pays', 'ASC']]
      })
      .then(response => {

        const paysOptions = response.map((data) => ({
          value: data.pays,
          label: data.pays,
        }));
        res.json({
          code: 200,
          data: {
            paysOptions
          }
        })
      })
  });

  app.get('/api/getPaysall', async (req, res) => {
    try {
      // Retrieve the list of countries from pays_regulateurs table
      const countries = await pays_regulateurs.findAll({
        attributes: [[sequelize.literal('DISTINCT pays'), 'pays']],
        order: [['pays', 'ASC']]
      });

      // Retrieve the count of companies per country from the societe table
      const companiesPerCountry = await sequelize.query(`
      SELECT pays, COUNT(*) AS companyCount 
      FROM societes
      GROUP BY pays
    `, { type: sequelize.QueryTypes.SELECT });

      // Combine the data to get the required format for countries and their respective company counts
      const countriesWithCompanies = countries.map(country => ({
        pays: country.pays,
        companyCount: companiesPerCountry.find(c => c.pays === country.pays)?.companyCount ?? 0
      }));

      // Prepare data for table display
      const tableData = countriesWithCompanies.map(({ pays, companyCount }) => ({ pays, companyCount }));

      res.json({
        code: 200,
        data: {
          countriesWithCompanies: tableData
        }
      });
    } catch (error) {
      // Handle errors
      console.error('Error:', error);
      res.status(500).json({
        code: 500,
        message: 'Internal Server Error'
      });
    }
  });




  app.get('/api/getRegulateur', (req, res) => {
    const selectedPays = req.query.pays;

    // Recherchez le régulateur correspondant dans la base de données en fonction du pays sélectionné
    pays_regulateurs
      .findOne({
        attributes: ['regulateur'],
        where: { pays: selectedPays },
      })
      .then((response) => {
        if (response) {
          const regulateur = {
            value: response.regulateur,
            label: response.regulateur,
          };

          res.json({
            code: 200,
            data: {
              regulateur
            }
          });
        } else {
          res.status(404).json({
            code: 404,
            error: 'Régulateur introuvable pour ce pays.',
          });
        }
      })
      .catch((error) => {
        console.error(error);
        res.status(500).json({
          code: 500,
          error: 'Une erreur s\'est produite lors de la récupération du régulateur.',
        });
      });
  });

  app.get('/api/getDevise', (req, res) => {
    const selectedPays = req.query.pays;

    // Recherchez le régulateur correspondant dans la base de données en fonction du pays sélectionné
    pays_regulateurs
      .findOne({
        attributes: ['symboledevise'],
        where: { pays: selectedPays },
      })
      .then((response) => {
        if (response) {
          const devises = {
            value: response.symboledevise,
            label: response.symboledevise,
          };

          res.json({
            code: 200,
            data: {
              devises
            }
          });
        } else {
          res.status(404).json({
            code: 404,
            error: 'Devise introuvable pour ce pays.',
          });
        }
      })
      .catch((error) => {
        console.error(error);
        res.status(500).json({
          code: 500,
          error: 'Une erreur s\'est produite lors de la récupération du régulateur.',
        });
      });
  });


  /**
   * @swagger
   * /api/valLiq/{fund_id}:
   *   get:
   *     tags:
   *       - Derniere Valeur Liquidative
   *     summary: Retrieve the last value and date for a specific record.
   *     description: Retrieve the last liquidation value and date for a specific record.
   *     parameters:
   *       - name: fund_id
   *         in: path
   *         description: The fund_id of the record.
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Successful response containing the last value and date.
   *         content:
   *           application/json:
   *             schema:
   *               type: object
   *               properties:
   *                 code:
   *                   type: integer
   *                   example: 200
   *                 data:
   *                   type: object
   *                   properties:
   *                     lastValue:
   *                       type: number
   *                       format: double
   *                       example: 123.45
   *                       description: The last liquidation value.
   *                     lastDate:
   *                       type: string
   *                       format: date
   *                       example: "2023-09-02"
   *                       description: The date corresponding to the last value.
   */
  app.get('/api/valLiq/:id', async (req, res) => {
    //  try {
    const response = await vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    });
    if (response.length > 0) {
      /* const graphs = response.map(data => ({
         dates :moment(data.date).format('YYYY-MM-DD'), // Remplacez avec la propriété correcte de l'objet
         bases_100:data.base_100, // Remplacez avec la propriété correcte de l'objet
         bases_100_InRef:data.base_100_InRef,
     }));*/
      const hasIndRef = response.some(data => data.indRef !== null);

      const graphs = response.map(data => {
        if (hasIndRef) {
          if (data.value !== null && data.indRef !== null) {
            return {
              dates: moment(data.date).format('YYYY-MM-DD'), // Remplacez avec la propriété correcte de l'objet
              values: data.vl_ajuste, //todo Remplacez avec la propriété correcte de l'objet
              valuesInd: data.indRef, // Inclure indRef seulement si non nul
            };
          };
        } else {
          return {
            dates: moment(data.date).format('YYYY-MM-DD'), // Remplacez avec la propriété correcte de l'objet
            values: data.value, // Remplacez avec la propriété correcte de l'objet
          };
        }

      }).filter(Boolean); // Supprimer les valeurs nulles de l'array

      // Faites ce que vous voulez avec l'array `graphs` ici

      const values = response.map((data) => data.value);//todo
      //  const bases_100 = response.map((data) => data.base_100);
      //  const bases_100_InRef = response.map((data) => data.base_100_InRef);
      const fundnames = response.map((data) => data.fund_name);
      const libelle_fonds = response.map((data) => data.libelle_fond);
      const fundids = response.map((data) => data.fund_id);
      const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
      const libelle_indices = response.map((data) => data.indice_name);
      const ID_indices = response.map((data) => data.ID_indice);

      const lastValue = values[response.length - 1];
      const lastDate = dates[response.length - 1];
      const fundname = fundnames[response.length - 1];
      const fundid = fundids[response.length - 1];
      const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);
      const baseUrl = urll; // Remplacez par votre URL de base
      const lastValResponse = await fetch(`${baseUrl}/api/performances/fond/${fundid}?date=${lastDate}`);
      const libelle_indice = libelle_indices[response.length - 1];
      const ID_indice = ID_indices[0];
      const currentDate = moment();

      // Calculate the number of missing days
      const daysDiff = currentDate.diff(lastDate, 'days');

      // Calculate the number of missing weekends
      const weekends = Array.from({ length: daysDiff }, (_, i) => moment(lastValue).add(i, 'days'))
        .filter(date => date.day() === 0 || date.day() === 6)
        .length;

      // Calculate the number of missing Vl dates
      const missingVl = daysDiff - weekends;
      if (!lastValResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const lastValData = await lastValResponse.json();

      const last1ansRatiosResponse = await fetch(`${baseUrl}/api/ratiosnew/1/${fundid}`);

      if (!last1ansRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const last1ansRatiosData = await last1ansRatiosResponse.json();

      const lastRatiosResponse = await fetch(`${baseUrl}/api/ratiosnew/3/${fundid}`);

      if (!lastRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const lastRatiosData = await lastRatiosResponse.json();

      const last5ansRatiosResponse = await fetch(`${baseUrl}/api/ratiosnew/5/${fundid}`);

      if (!last5ansRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const last5ansRatiosData = await last5ansRatiosResponse.json();

      const resultat = await fond.findOne({
        attributes: ['indice_benchmark','indice', 'structure_fond', 'strategie_politique_invest', 'philosophie_fond', 'code_ISIN', 'date_creation', 'periodicite', "affectation", "minimum_investissement", "frais_souscription", "frais_rachat", "frais_gestion", "frais_entree", "frais_sortie", 'categorie_libelle', 'nom_fond', 'categorie_national', 'pays', 'categorie_globale', 'categorie_regional', 'type_investissement', 'classification', 'societe_gestion', 'nom_gerant'],
        where: {
          id: parseInt(req.params.id),
        },
      });
      const indice_benchmark = resultat.indice_benchmark;
      const indice = resultat.indice;
      const affectation = resultat.affectation;
      const structure_fond = resultat.structure_fond;
      const code_ISIN = resultat.code_ISIN;
      const frais_souscription = resultat.frais_souscription;
      const frais_rachat = resultat.frais_rachat;
      const frais_gestion = resultat.frais_gestion;
      const frais_entree = resultat.frais_entree;
      const frais_sortie = resultat.frais_sortie;
      const minimum_investissement = resultat.minimum_investissement;

      const categorie_libelle = resultat.categorie_libelle;
      const pays = resultat.pays;
      const date_creationfund = resultat.date_creation;

      const categorie_national = resultat.categorie_national;
      const categorie_globale = resultat.categorie_globale;
      const categorie_regional = resultat.categorie_regional;
      const type_investissement = resultat.type_investissement;
      const periodicite = resultat.periodicite;
      const philosophie_fond = resultat.philosophie_fond;
      const strategie_politique_invest = resultat.strategie_politique_invest;

      const classification = resultat.classification;
      const societe_gestion = resultat.societe_gestion;
      const nom_gerant = resultat.nom_gerant;
      const libelle_fond = resultat.nom_fond;

      const pays_regul = await pays_regulateurs.findOne({
        attributes: ['regulateur', 'sitewebregulateur', 'nomdelabourse', 'URLdelabourse', 'nomdevise', 'symboledevise'],
        where: {
          pays: pays,
        },
      });
      const regulateur = pays_regul.regulateur;
      const sitewebregulateur = pays_regul.sitewebregulateur;
      const nomdelabourse = pays_regul.nomdelabourse;
      const URLdelabourse = pays_regul.URLdelabourse;
      const symboledevise = pays_regul.symboledevise;

      const societegestion = await societe.findOne({
        attributes: ['nom', 'description', 'site_web'],
        where: {
          nom: societe_gestion,
        },
      });

      const societesiteweb=societegestion.site_web;

    

      const meilleursFonds = await performences.findAll({
        attributes: [
          'fond_investissement.nom_fond',
          'perfannu3an',
          'perf1an',
          'perf3ans',
          'ytd',
          'volatility3an'
        ],
        include: [{
          model: fond,
          attributes: ['nom_fond'], // Sélectionner seulement le nom du fond, vous pouvez ajouter d'autres attributs si nécessaire
          required: true
        }],
        where: {
          date: lastDate
        },
        order: [
          ['perfannu3an', 'DESC']
        ],
        limit: 5
      });

      const resultatsMeilleursFonds = meilleursFonds.map(fond => ({
        nom_fond: fond.fond_investissement ? fond.fond_investissement.nom_fond : null, // Vérifie si fond existe
        performance_annualisee: parseFloat(fond.perfannu3an),
        performance_1_an: parseFloat(fond.perf1an),
        performance_3_ans: parseFloat(fond.perfannu3an),
        performance_ytd: parseFloat(fond.ytd),
        volatility3an: parseFloat(fond.volatility3an)
      }));

     
      res.json({
        code: 200,
        data: {
          meilleursFonds: resultatsMeilleursFonds,
          societesiteweb: societesiteweb || null,
          ID_indice: indice,
          indice_benchmark,
          affectation,
          strategie_politique_invest,
          philosophie_fond,
          frais_souscription,
          frais_rachat,
          frais_gestion,
          frais_entree,
          frais_sortie,
          periodicite,
          structure_fond,
          minimum_investissement,
          missingVl,
          code_ISIN,
          date_creationfund,
          regulateur,
          sitewebregulateur,
          nomdelabourse,
          URLdelabourse,
          symboledevise,
          graphs: graphs,
          categorie_libelle,
          categorie_national,
          nom_gerant,
          categorie_globale,
          societe_gestion,
          categorie_regional,
          classification,
          type_investissement,
          lastValue,
          pays,
          lastDate,
          fundname,
          fundid,
          libelle_fond,
          libelle_indice,
          lastdatepreviousmonth,
          performances: lastValData,
          ratios3a: lastRatiosData,
          ratios1a: last1ansRatiosData,
          ratios5a: last5ansRatiosData
        }
      });
    } else {
      res.status(500).json({ message: 'Erreur lors de la récupération des données' });

    }
    /* } catch (error) {
       console.error('Erreur lors de la récupération des données:', error);
       res.status(500).json({ message: 'Erreur lors de la récupération des données' });
     }*/
  });

  app.get('/api/valLiqdev/:id/:devise', async (req, res) => {
    //  try {
    const response = await vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    });
    if (response.length > 0) {

      const graphs = response.map(data => {
        if (data.value !== null && data.indRef_EUR !== null) {
          return {
            dates: moment(data.date).format('YYYY-MM-DD'), // Remplacez avec la propriété correcte de l'objet
            values: data.value, // Remplacez avec la propriété correcte de l'objet
            valuesInd: req.params.devise == "USD" ? data.indRef_USD : data.indRef_EUR,
          };
        } else {
          return null; // Ignorer les lignes où la condition n'est pas satisfaite
        }
      }).filter(Boolean); // Supprimer les valeurs nulles de l'array
      let values;
      if (req.params.devise == "USD") {
        values = response.map((data) => data.value_USD);
      } else {
        values = response.map((data) => data.value_EUR);
      }

      //  const bases_100 = response.map((data) => data.base_100);
      //  const bases_100_InRef = response.map((data) => data.base_100_InRef);
      const fundnames = response.map((data) => data.fund_name);
      const libelle_fonds = response.map((data) => data.libelle_fond);
      const fundids = response.map((data) => data.fund_id);
      const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
      const libelle_indices = response.map((data) => data.indice_name);
      const ID_indices = response.map((data) => data.ID_indice);

      const lastValue = values[response.length - 1];
      const lastDate = dates[response.length - 1];
      const fundname = fundnames[response.length - 1];
      const fundid = fundids[response.length - 1];
      const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);
      const baseUrl = urll; // Remplacez par votre URL de base
      const lastValResponse = await fetch(`${baseUrl}/api/performancesdev/fond/${fundid}/${req.params.devise}?date=${lastDate}`);
      const libelle_indice = libelle_indices[response.length - 1];
      const ID_indice = ID_indices[response.length - 1];
      const currentDate = moment();

      // Calculate the number of missing days
      const daysDiff = currentDate.diff(lastDate, 'days');

      // Calculate the number of missing weekends
      const weekends = Array.from({ length: daysDiff }, (_, i) => moment(lastValue).add(i, 'days'))
        .filter(date => date.day() === 0 || date.day() === 6)
        .length;

      // Calculate the number of missing Vl dates
      const missingVl = daysDiff - weekends;
      if (!lastValResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const lastValData = await lastValResponse.json();

      const last1ansRatiosResponse = await fetch(`${baseUrl}/api/ratiosnewdev/1/${fundid}/${req.params.devise}`);

      if (!last1ansRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const last1ansRatiosData = await last1ansRatiosResponse.json();

      const lastRatiosResponse = await fetch(`${baseUrl}/api/ratiosnewdev/3/${fundid}/${req.params.devise}`);

      if (!lastRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const lastRatiosData = await lastRatiosResponse.json();

      const last5ansRatiosResponse = await fetch(`${baseUrl}/api/ratiosnewdev/5/${fundid}/${req.params.devise}`);

      if (!last5ansRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const last5ansRatiosData = await last5ansRatiosResponse.json();

      const resultat = await fond.findOne({
        attributes: ['structure_fond', 'code_ISIN', 'date_creation', 'periodicite', "affectation", "minimum_investissement", "frais_souscription", "frais_rachat", "frais_gestion", "frais_entree", "frais_sortie", 'categorie_libelle', 'nom_fond', 'categorie_national', 'pays', 'categorie_globale', 'categorie_regional', 'type_investissement', 'classification', 'societe_gestion', 'nom_gerant'],
        where: {
          id: req.params.id,
        },
      });
      const affectation = resultat.affectation;
      const structure_fond = resultat.structure_fond;
      const code_ISIN = resultat.code_ISIN;
      const frais_souscription = resultat.frais_souscription;
      const frais_rachat = resultat.frais_rachat;
      const frais_gestion = resultat.frais_gestion;
      const frais_entree = resultat.frais_entree;
      const frais_sortie = resultat.frais_sortie;
      const minimum_investissement = resultat.minimum_investissement;

      const categorie_libelle = resultat.categorie_libelle;
      const pays = resultat.pays;
      const date_creationfund = resultat.date_creation;

      const categorie_national = resultat.categorie_national;
      const categorie_globale = resultat.categorie_globale;
      const categorie_regional = resultat.categorie_regional;
      const type_investissement = resultat.type_investissement;
      const periodicite = resultat.periodicite;

      const classification = resultat.classification;
      const societe_gestion = resultat.societe_gestion;
      const nom_gerant = resultat.nom_gerant;
      const libelle_fond = resultat.nom_fond;

      const pays_regul = await pays_regulateurs.findOne({
        attributes: ['regulateur', 'sitewebregulateur', 'nomdelabourse', 'URLdelabourse', 'nomdevise', 'symboledevise'],
        where: {
          pays: pays,
        },
      });
      const regulateur = pays_regul.regulateur;
      const sitewebregulateur = pays_regul.sitewebregulateur;
      const nomdelabourse = pays_regul.nomdelabourse;
      const URLdelabourse = pays_regul.URLdelabourse;
      const symboledevise = pays_regul.symboledevise;


      res.json({
        code: 200,
        data: {
          ID_indice,
          affectation,
          frais_souscription,
          frais_rachat,
          frais_gestion,
          frais_entree,
          frais_sortie,
          periodicite,
          structure_fond,
          minimum_investissement,
          missingVl,
          code_ISIN,
          date_creationfund,
          regulateur,
          sitewebregulateur,
          nomdelabourse,
          URLdelabourse,
          symboledevise,
          graphs: graphs,
          categorie_libelle,
          categorie_national,
          nom_gerant,
          categorie_globale,
          societe_gestion,
          categorie_regional,
          classification,
          type_investissement,
          lastValue,
          pays,
          lastDate,
          fundname,
          fundid,
          libelle_fond,
          libelle_indice,
          lastdatepreviousmonth,
          performances: lastValData,
          ratios3a: lastRatiosData,
          ratios1a: last1ansRatiosData,
          ratios5a: last5ansRatiosData
        }
      });
    } else {
      res.status(500).json({ message: 'Erreur lors de la récupération des données' });

    }
    /* } catch (error) {
       console.error('Erreur lors de la récupération des données:', error);
       res.status(500).json({ message: 'Erreur lors de la récupération des données' });
     }*/
  });

  const fetchData = async (url) => {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Erreur HTTP : ${response.statusText}`);
      }
      return response.json();
    } catch (error) {
      console.error('Erreur lors de la requête fetch :', error.message);
      throw error; // Vous pouvez choisir de relancer l'erreur ou de la gérer selon vos besoins.
    }
  };
  app.get('/api/valLiqportefeuilledev/:id/:devise', async (req, res) => {
    //  try {
    //  const transactionDatas = await getTransactionData(req.params.id);
    const portefeuilleDatas = await getportefeuilleData(parseInt(req.params.id));
    const devise = req.params.devise
    const response = await portefeuille_vl_cumul.findAll({
      where: {
        portefeuille_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    });
    if (response.length > 0) {
      let lastValuep = response[0].base_100_bis; // Dernière valeur


      // const tauxsr=0.03;-0.0116;-0,0234
      const tauxsr = -0.0234;
      // Valeurs liquidatives
      const values = response.map((data) => data.base_100_bis);
      const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
      const lastDate = dates[dates.length - 1];

      const graphs = response.map(data => ({
        dates: moment(data.date).format('YYYY-MM-DD'), // Remplacez avec la propriété correcte de l'objet
        values: data.base_100_bis, // Remplacez avec la propriété correcte de l'objet
        // valuesInd: data.indRef,
      }));


      const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);
      const baseUrl = urll; // Remplacez par votre URL de base
      const lastValResponse = await fetch(`${baseUrl}/api/performancesportefeuilledev/fond/${req.params.id}/${devise}`);

      const lastValData = await lastValResponse.json();

      const last1ansRatiosResponse = await fetch(`${baseUrl}/api/ratiosportefeuilledev/1/${req.params.id}/${devise}`);

      if (!last1ansRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const last1ansRatiosData = await last1ansRatiosResponse.json();

      const lastRatiosResponse = await fetch(`${baseUrl}/api/ratiosportefeuilledev/3/${req.params.id}/${devise}`);

      if (!lastRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const lastRatiosData = await lastRatiosResponse.json();

      const last5ansRatiosResponse = await fetch(`${baseUrl}/api/ratiosportefeuilledev/5/${req.params.id}/${devise}`);

      if (!last5ansRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const last5ansRatiosData = await last5ansRatiosResponse.json();



      res.json({
        code: 200,
        data: {
          lastDate,

          graphs: portefeuilleDatas,

          lastdatepreviousmonth,
          performances: lastValData,
          ratios3a: lastRatiosData,
          ratios1a: last1ansRatiosData,
          ratios5a: last5ansRatiosData
        }
      });
    } else {
      res.status(500).json({ message: 'Erreur lors de la récupération des données' });

    }
    /* } catch (error) {
       console.error('Erreur lors de la récupération des données:', error);
       res.status(500).json({ message: 'Erreur lors de la récupération des données' });
     }*/
  });

  app.get('/api/valLiqportefeuille/:id', async (req, res) => {
    //  try {
    //  const transactionDatas = await getTransactionData(req.params.id);
    //  const portefeuilleDatas = await getportefeuilleData(parseInt(req.params.id));

    const response = await portefeuille_vl_cumul.findAll({
      where: {
        portefeuille_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    });
    if (response.length > 0) {
      const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
      const lastDate = dates[dates.length - 1];

      const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);
      const baseUrl = urll; // Remplacez par votre URL de base
      const lastValResponse = await fetch(`${baseUrl}/api/performancesportefeuille/fond/${req.params.id}`);

      const lastValData = await lastValResponse.json();

      const last1ansRatiosResponse = await fetch(`${baseUrl}/api/ratiosportefeuille/1/${req.params.id}`);

      if (!last1ansRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const last1ansRatiosData = await last1ansRatiosResponse.json();

      const lastRatiosResponse = await fetch(`${baseUrl}/api/ratiosportefeuille/3/${req.params.id}`);

      if (!lastRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const lastRatiosData = await lastRatiosResponse.json();

      const last5ansRatiosResponse = await fetch(`${baseUrl}/api/ratiosportefeuille/5/${req.params.id}`);

      if (!last5ansRatiosResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const last5ansRatiosData = await last5ansRatiosResponse.json();



      res.json({
        code: 200,
        data: {
          lastDate,
          graphs: response,

          lastdatepreviousmonth,
          performances: lastValData,
          ratios3a: lastRatiosData,
          ratios1a: last1ansRatiosData,
          ratios5a: last5ansRatiosData
        }
      });
    } else {
      res.status(500).json({ message: 'Erreur lors de la récupération des données' });

    }
    /* } catch (error) {
       console.error('Erreur lors de la récupération des données:', error);
       res.status(500).json({ message: 'Erreur lors de la récupération des données' });
     }*/
  });

  /**
  * @swagger
  * /api/recherchefonds:
  *   get:
  *     tags:
  *       - Derniere Valeur Liquidative
  *     summary: Retrieve the last value and date for a specific record.
  *     description: Retrieve the last liquidation value and date for a specific record.
  *     parameters:
  *       - name: fund_id
  *         in: path
  *         description: The fund_id of the record.
  *         required: true
  *         schema:
  *           type: string
  *     responses:
  *       200:
  *         description: Successful response containing the last value and date.
  *         content:
  *           application/json:
  *             schema:
  *               type: object
  *               properties:
  *                 code:
  *                   type: integer
  *                   example: 200
  *                 data:
  *                   type: object
  *                   properties:
  *                     lastValue:
  *                       type: number
  *                       format: double
  *                       example: 123.45
  *                       description: The last liquidation value.
  *                     lastDate:
  *                       type: string
  *                       format: date
  *                       example: "2023-09-02"
  *                       description: The date corresponding to the last value.
  */
  /*app.post('/api/recherchefonds', async (req, res) => {
    try {
   //   const formData = req.body.formData;
      const selectedValues = req.query.query;
      const selectedcategorie = req.query.selectedcategorie;
      const selectedsociete = req.query.selectedsociete;
   
      const valuesArray = selectedValues.split(',');
   
      const funds = await fetchFundsByValorisation(valuesArray, selectedcategorie, selectedsociete);
   
      const fundsWithAllData = await Promise.all(funds.map(async (fund) => {
        try {
          const fundData = await fond.findByPk(fund.id);
   
          if (!fundData) {
            return { error: `Aucun élément trouvé pour l'ID ${fund.id}` };
          }
   
          const [firstData, secondData, thirdData, fourthData] = await Promise.all([
            fetch(`${urll}/api/performances/fond/${fund.id}`).then(response => response.json()),
            fetch(`${urll}/api/ratios/1/${fund.id}`).then(response => response.json()),
            fetch(`${urll}/api/ratios/3/${fund.id}`).then(response => response.json()),
            fetch(`${urll}/api/ratios/5/${fund.id}`).then(response => response.json())
          ]);
   
          return {
            id: fund.id,
            fundData: fundData.toJSON(),
            firstData,
            secondData,
            thirdData,
            fourthData,
          };
        } catch (error) {
          console.error('Erreur lors du traitement du fond :', error);
          return { error: 'Une erreur est survenue lors du traitement du fond.' };
        }
      }));
   
      console.log("Avant res.json"); // Ajout d'un point de débogage
      res.json({
        code: 200,
        data: {
          funds: fundsWithAllData,
        },
      });
    } catch (error) {
      console.error('Erreur lors de la récupération des données :', error);
      res.status(500).json({ error: 'Une erreur est survenue lors de la récupération des données.' });
    }
  });
  */

  app.post('/api/recherchefonds', async (req, res) => {
    try {
      const selectedValues = req.query.query;
      const selectedCategorie = req.query.selectedcategorie; // Corrected variable name
      const selectedSociete = req.query.selectedsociete; // Corrected variable name

      const valuesArray = selectedValues.split(',');

      // Fetch funds based on criteria
      const funds = await fetchFundsByValorisation(valuesArray, selectedCategorie, selectedSociete, 'undefined', '');

      if (!funds.length) {
        res.status(404).json({ error: 'No funds found.' });
        return;
      }

      const fundIds = funds.map(fund => fund.id);

      // Fetch all fund data in one batch
      const fundDataResults = await fond.findAll({
        where: { id: fundIds }
      });

      // Fetch all performance data in one batch
      const performanceResults = await performences.findAll({
        where: {
          fond_id: fundIds
        },
        order: [['date', 'DESC']]
      });

      // Create a map for performance data for quick lookup
      const performanceMap = performanceResults.reduce((acc, performance) => {
        if (!acc[performance.fond_id]) {
          acc[performance.fond_id] = performance;
        }
        return acc;
      }, {});

      // Combine data
      const fundsWithAllData = fundDataResults.map(fundData => {
        const performanceData = performanceMap[fundData.id] || null;
        return {
          id: fundData.id,
          fundData: fundData.toJSON(),
          performanceData: performanceData ? performanceData.toJSON() : null
        };
      });

      res.json({
        code: 200,
        data: {
          funds: fundsWithAllData,
        },
      });
    } catch (error) {
      console.error('Erreur lors de la recherche des fonds :', error);
      res.status(500).json({ error: 'Une erreur est survenue lors de la recherche des fonds.' });
    }
  });







  /**
  * @swagger
  * /api/searchFunds/{fund_id}:
  *   get:
  *     tags:
  *       - Derniere Valeur Liquidative
  *     summary: Retrieve the last value and date for a specific record.
  *     description: Retrieve the last liquidation value and date for a specific record.
  *     parameters:
  *       - name: fund_id
  *         in: path
  *         description: The fund_id of the record.
  *         required: true
  *         schema:
  *           type: string
  *     responses:
  *       200:
  *         description: Successful response containing the last value and date.
  *         content:
  *           application/json:
  *             schema:
  *               type: object
  *               properties:
  *                 code:
  *                   type: integer
  *                   example: 200
  *                 data:
  *                   type: object
  *                   properties:
  *                     lastValue:
  *                       type: number
  *                       format: double
  *                       example: 123.45
  *                       description: The last liquidation value.
  *                     lastDate:
  *                       type: string
  *                       format: date
  *                       example: "2023-09-02"
  *                       description: The date corresponding to the last value.
  */
  /* app.get('/api/searchFunds', async(req, res) => {
  ///  const searchTerm = req.query.query;
   
   
    const query = `
    SELECT f.*
    FROM fond_investissements AS f
    WHERE  f.id IN (SELECT v.fund_id FROM valorisations AS v )
  `;
   
  const fondsDansCategorie = await sequelize.query(query, {
   
    type: sequelize.QueryTypes.SELECT,
  });
   
  // Retournez la liste des fonds
   
            //const funds = response.map((data) => data.id);
           
            const funds = fondsDansCategorie.map(data => ({
                label : data.nom_fond.toString()+" "+data.code_ISIN, // Remplacez avec la propriété correcte de l'objet
   
                value: data.id, // Remplacez avec la propriété correcte de l'objet
            }));
            res.json({
                code: 200,
                data: {
                    funds
                   
                   
                }
            })
   
        
  })*/
  app.get('/api/searchFunds', async (req, res) => {
    const { minHorizon, maxHorizon, selectedPays, selectedRegion } = req.query;
    let query = `
    SELECT DISTINCT f.id, f.nom_fond, f.code_ISIN
    FROM fond_investissements AS f
    INNER JOIN valorisations AS v ON f.id = v.fund_id
  `;

    if (minHorizon && maxHorizon) {
      query += `
      WHERE v.date >= :minHorizon
      AND v.date <= :maxHorizon
    `;
    }

    if (selectedPays) {
      query = ` SELECT DISTINCT f.id, f.nom_fond, f.code_ISIN
    FROM fond_investissements AS f
    INNER JOIN valorisations AS v ON f.id = v.fund_id
  WHERE
           f.pays = :selectedPays

    `;
    }

    if (selectedRegion) {
      query = ` SELECT DISTINCT f.id, f.nom_fond, f.code_ISIN
    FROM fond_investissements AS f
    INNER JOIN valorisations AS v ON f.id = v.fund_id
  WHERE
       f.region = :selectedRegion
     
    `;
    }

    try {
      const fondsDansCategorie = await sequelize.query(query, {
        type: sequelize.QueryTypes.SELECT,
        replacements: { minHorizon, maxHorizon },
      });

      const funds = fondsDansCategorie.map(data => ({
        label: `${data.nom_fond.toString()} ${data.code_ISIN}`,
        value: data.id,
        // name: data.nom_fond.toString(),
        // description: data.description.toString()
      }));

      res.json({
        code: 200,
        data: {
          funds,
        },
      });
    } catch (error) {
      console.error("Erreur lors de la requête SQL :", error);
      res.status(500).json({ error: 'Erreur lors de la requête SQL.' });
    }
  });

  app.get('/api/searchFundsreconstitution', async (req, res) => {
    const { categorie, univers, universsous, selectedPays, selectedRegion } = req.query;

    const categories = categorie.split(',');
    /* const univers = data?.data.portefeuille.univers;
      const universsous = data?.data.portefeuille.universsous;*/

    const getFundsByCategorie = async (categories) => {
      if (categories.includes("Toutes les classes")) {
        // Si "Toutes les classes" est dans les catégories, renvoyer tout
        query = `
            SELECT f.*
            FROM fond_investissements AS f
            WHERE f.id IN (SELECT v.fund_id FROM valorisations AS v)
          `;
      } else {
        // Sinon, filtrer par les catégories spécifiées
        query = `
            SELECT f.*
            FROM fond_investissements AS f
            WHERE f.id IN (SELECT v.fund_id FROM valorisations AS v)
            AND f.categorie_globale IN (${categories.map(cat => `'${cat}'`).join(',')})
          `;
      }
      if (selectedPays) {
        query += `
      AND  f.pays = :selectedPays
     
    `;
      }

      if (selectedRegion) {
        query += `
      AND f.region = :selectedRegion
     
    `;
      }


      const fondsDansCategorie = await sequelize.query(query, {
        type: sequelize.QueryTypes.SELECT,
        replacements: { selectedRegion, selectedPays },

      });

      return fondsDansCategorie.map(data => ({
        label: data.nom_fond.toString() + " " + data.code_ISIN,
        value: data.id,
      }));
    };

    const getFundsByRegionalCategorie = async (univers, universsous, categories) => {
      const categorieWithUnivers = categories.map(cat => `'${cat} ${univers}'`);
      if (univers === "Tous univers") {
        query = `
            SELECT f.*
            FROM fond_investissements AS f
            WHERE f.id IN (SELECT v.fund_id FROM valorisations AS v)
          `;
      } else {
        query = `
            SELECT f.*
            FROM fond_investissements AS f
            WHERE f.id IN (SELECT v.fund_id FROM valorisations AS v)
            AND f.categorie_regional IN (${categorieWithUnivers.join(',')})
          `;
      }
    }

    const getFundsByNationalCategorie = async (universsous, categories) => {
      // Construisez votre requête SQL pour récupérer les fonds en fonction de la catégorie nationale
      const categorieWithUniverssous = categories.map(cat => `'${cat} ${universsous}'`);
      if (univers === "Tous univers") {
        query = `
            SELECT f.*
            FROM fond_investissements AS f
            WHERE f.id IN (SELECT v.fund_id FROM valorisations AS v)
          `;
      } else {
        query = `
            SELECT f.*
            FROM fond_investissements AS f
            WHERE f.id IN (SELECT v.fund_id FROM valorisations AS v)
            AND f.categorie_national IN (${categorieWithUniverssous.join(',')})
          `;
      }
      // Exécutez la requête SQL et obtenez les fonds correspondants
      const fondsDansCategorieNationale = await sequelize.query(query, {
        type: sequelize.QueryTypes.SELECT,
      });

      return fondsDansCategorieNationale.map(data => ({
        label: data.nom_fond.toString() + " " + data.code_ISIN,
        value: data.id,
      }));
    };

    const [fundsByCategorie, fundsByRegionalCategorie, fundsByNationalCategorie] = await Promise.all([
      getFundsByCategorie(categories),
      getFundsByRegionalCategorie(univers, universsous, categories),
      getFundsByNationalCategorie(universsous, categories),
    ]);

    res.json({
      code: 200,
      data: {
        fundsByCategorie,
        fundsByRegionalCategorie,
        fundsByNationalCategorie,
      },
    });
  });
  app.post('/api/updatefond/:id', async (req, res) => {
    try {
      const fondId = req.params.id;

      // Trouver le fond en question
      const fonds = await fond.findOne({ where: { id: parseInt(fondId) } });

      if (!fonds) {
        return res.status(404).json({ error: 'Fond non trouvé.' });
      }

      // Mettre à jour la propriété active du fond à 1
      const updatedFond = await fond.update({ active: 1 }, {
        where: {
          id: parseInt(fondId)
        }
      });

      res.json({
        code: 200,
        message: 'Fond mis à jour avec succès.',
        data: updatedFond
      });
    } catch (err) {
      res.status(500).json({ error: 'Erreur lors de la mise à jour du fond.' });
    }
  });


  //Users adamin valide
  app.get('/api/getusersbyadmin', (req, res) => {
    ///  const searchTerm = req.query.query;

    // Vérifiez si searchTerm existe
    /*if (!searchTerm) {
        return res.status(400).json({ error: 'Le paramètre query est manquant.' });
    }*/

    users.findAll({
      where: {
      },
      order: [
        ['id', 'DESC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const userss = response.map(data => ({
          id: data.id,
          email: data.email, // Remplacez avec la propriété correcte de l'objet
          nom: data.nom, // Remplacez avec la propriété correcte de l'objet
          prenoms: data.prenoms,
          active: data.active

        }));
        res.json({
          code: 200,
          data: {
            userss
          }
        })

      })
  })
 
  app.post('/api/activate-user/:id', (req, res) => {
    const userId = req.params.id;
  
    // Trouver l'utilisateur avec l'ID
    users.findOne({
      where: {
        id: userId
      }
    })
    .then(user => {
      if (!user) {
        return res.status(404).json({ error: 'Utilisateur non trouvé' });
      }
  
      // Mettre à jour l'utilisateur pour l'activer
      return user.update({ active: 1 });
    })
    .then(updatedUser => {
      // Répondre avec une confirmation de l'activation
      res.json({
        code: 200,
        message: "L'utilisateur a été activé avec succès",
        data: {
          id: updatedUser.id,
          nom: updatedUser.nom,
          active: updatedUser.active,
        }
      });
    })
    .catch(error => {
      console.error('Erreur lors de l\'activation de l\'utilisateur:', error);
      res.status(500).json({ error: 'Erreur interne du serveur' });
    });
  });
  
  //Frais
  app.get('/api/getfraisbyadmin', (req, res) => {
    ///  const searchTerm = req.query.query;

    // Vérifiez si searchTerm existe
    /*if (!searchTerm) {
        return res.status(400).json({ error: 'Le paramètre query est manquant.' });
    }*/

    frais.findAll({
      where: {
      },
      order: [
        ['id', 'DESC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const frais = response.map(data => ({
          id: data.id,
          fond_id: data.fond_id, // Remplacez avec la propriété correcte de l'objet
          fond: data.fond, // Remplacez avec la propriété correcte de l'objet
          frais_transa_achat: data.frais_transa_achat,
          frais_transa_vente: data.frais_transa_vente

        }));
        res.json({
          code: 200,
          data: {
            frais
          }
        })

      })
  })
  app.get('/api/getfraisbyadminid/:id', (req, res) => {
    frais.findOne({
      where: {
        fond_id: req.params.id
      },
      order: [
        ['id', 'DESC']
      ]
    })
      .then(data => {
        if (data) {
          res.json({
            code: 200,
            data: {
              id: data.id,
              fond_id: data.fond_id,
              fond: data.fond,
              frais_transa_achat: data.frais_transa_achat,
              frais_transa_vente: data.frais_transa_vente
            }
          });
        } else {
          res.status(404).json({ error: 'Data not found' });
        }
      })
      .catch(error => {
        res.status(500).json({ error: 'Internal Server Error' });
      });
  });
  app.post('/api/createfrais', async (req, res) => {
    try {
      const { fond_id, frais_transa_achat, frais_transa_vente } = req.body;

      // Vérifiez si le fond existe
      const fondExists = await fond.findOne({ where: { id: parseInt(fond_id) } });

      if (!fondExists) {
        return res.status(404).json({ error: 'Fond non trouvé.' });
      }

      // Vérifiez si les frais existent déjà pour ce fond
      const fraisExists = await frais.findOne({ where: { fond_id: parseInt(fond_id) } });

      if (fraisExists) {
        // Mettez à jour les frais existants
        const updatedFrais = await frais.update(
          { frais_transa_achat, frais_transa_vente },
          { where: { fond_id: parseInt(fond_id) } }
        );
        return res.json({
          code: 200,
          message: 'Frais mis à jour avec succès.',
          data: updatedFrais,
        });
      }

      // Créez les frais de transaction
      const newFrais = await frais.create({
        fond: fondExists.nom_fond,
        fond_id: parseInt(fond_id),
        frais_transa_achat,
        frais_transa_vente,
      });

      res.json({
        code: 200,
        message: 'Frais créés avec succès.',
        data: newFrais,
      });
    } catch (err) {
      res.status(500).json({ error: 'Erreur lors de la création ou de la mise à jour des frais.' });
    }
  });
  app.post('/api/updatefraisbyadminid/:id', async (req, res) => {
    try {
      const fondId = req.params.id;
      const { frais_transa_achat, frais_transa_vente } = req.body;

      // Trouver le fond en question
      const fonds = await frais.findOne({ where: { fond_id: parseInt(fondId) } });

      if (!fonds) {
        return res.status(404).json({ error: 'Fond non trouvé.' });
      }

      // Mettre à jour les frais de transaction
      const updatedFond = await frais.update(
        { frais_transa_achat, frais_transa_vente },
        {
          where: {
            fond_id: parseInt(fondId)
          }
        }
      );

      res.json({
        code: 200,
        message: 'Frais mis à jour avec succès.',
        data: updatedFond
      });
    } catch (err) {
      res.status(500).json({ error: 'Erreur lors de la mise à jour des frais.' });
    }
  });
  app.get('/api/getfondbyadmin', (req, res) => {
    ///  const searchTerm = req.query.query;

    // Vérifiez si searchTerm existe
    /*if (!searchTerm) {
        return res.status(400).json({ error: 'Le paramètre query est manquant.' });
    }*/

    fond.findAll({
      where: {

        /* id: {
           //  [Sequelize.Op.like]: `%${searchTerm}%`
         }*/
      },
      order: [
        ['id', 'DESC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const funds = response.map(data => ({
          id: data.id,
          nom_fond: data.nom_fond.toString(), // Remplacez avec la propriété correcte de l'objet
          code_ISIN: data.dev_libelle,
          categorie_libelle: data.categorie_libelle,
          categorie_national: data.categorie_national,
          datejour: data.datejour,
          active: data.active,
          code_ISIN: data.code_ISIN, // Remplacez avec la propriété correcte de l'objet
        }));
        res.json({
          code: 200,
          data: {
            funds


          }
        })

      })
  })
  app.get('/api/getfondbyuser/:id', (req, res) => {
    const societeGestionId = req.params.id;
    const pays = req.query.pays;

    // Définir la clause where de base
    let whereClause = {
      active: 0
    };

    if (pays) {
      whereClause.pays = pays;
    } else {
      whereClause.societe_gestion = societeGestionId;
    }


    fond.findAll({
      where: whereClause,
      order: [
        ['id', 'DESC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const funds = response.map(data => ({
          id: data.id,
          nom_fond: data.nom_fond.toString(), // Remplacez avec la propriété correcte de l'objet
          code_ISIN: data.dev_libelle,
          categorie_libelle: data.categorie_libelle,
          categorie_national: data.categorie_national,
          datejour: data.datejour,
          active: data.active,

          code_ISIN: data.code_ISIN, // Remplacez avec la propriété correcte de l'objet
        }));
        res.json({
          code: 200,
          data: {
            funds


          }
        })

      })
  })
  app.get('/api/getfondbyuservalide/:id', (req, res) => {
    const societeGestionId = req.params.id;
    const pays = req.query.pays;

    // Définir la clause where de base
    let whereClause = {
      active: 0
    };

    if (pays) {
      whereClause.pays = pays;
    } else {
      whereClause.societe_gestion = societeGestionId;
    }


    fond.findAll({
      where: whereClause,
      order: [
        ['id', 'DESC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const funds = response.map(data => ({
          id: data.id,
          nom_fond: data.nom_fond.toString(), // Remplacez avec la propriété correcte de l'objet
          code_ISIN: data.dev_libelle,
          categorie_libelle: data.categorie_libelle,
          categorie_national: data.categorie_national,
          datejour: data.datejour,
          active: data.active,

          code_ISIN: data.code_ISIN, // Remplacez avec la propriété correcte de l'objet
        }));
        res.json({
          code: 200,
          data: {
            funds


          }
        })

      })
  })
  app.get('/api/getfondbysociete/:id', (req, res) => {
    ///  const searchTerm = req.query.query;

    // Vérifiez si searchTerm existe
    /*if (!searchTerm) {
        return res.status(400).json({ error: 'Le paramètre query est manquant.' });
    }*/

    fond.findAll({
      where: {
        societe_gestion: req.params.id,
        /* id: {
           //  [Sequelize.Op.like]: `%${searchTerm}%`
         }*/
      },
      order: [
        ['id', 'DESC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const funds = response.map(data => ({
          id: data.id,
          nom_fond: data.nom_fond.toString(), // Remplacez avec la propriété correcte de l'objet
          test: data.nom_fond.toString() + " " + data.code_ISIN,
          categorie_libelle: data.categorie_libelle,
          categorie_national: data.categorie_national,
          datejour: data.datejour,
          active: data.active,

          code_ISIN: data.code_ISIN, // Remplacez avec la propriété correcte de l'objet
        }));
        res.json({
          code: 200,
          data: {
            funds


          }
        })

      })
  })

  app.get('/api/getfondbypays/:id', (req, res) => {
    ///  const searchTerm = req.query.query;

    // Vérifiez si searchTerm existe
    /*if (!searchTerm) {
        return res.status(400).json({ error: 'Le paramètre query est manquant.' });
    }*/

    fond.findAll({
      where: {
        pays: req.params.id,
        /* id: {
           //  [Sequelize.Op.like]: `%${searchTerm}%`
         }*/
      },
      order: [
        ['id', 'DESC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const funds = response.map(data => ({
          id: data.id,
          nom_fond: data.nom_fond.toString(), // Remplacez avec la propriété correcte de l'objet
          test: data.nom_fond.toString() + " " + data.code_ISIN,
          categorie_libelle: data.categorie_libelle,
          categorie_national: data.categorie_national,
          datejour: data.datejour,
          active: data.active,

          code_ISIN: data.code_ISIN, // Remplacez avec la propriété correcte de l'objet
        }));
        res.json({
          code: 200,
        data: {
          funds
        }



        })

      })
  })
  app.get('/api/getfondbyidmeta/:id', async (req, res) => {
    try {
      const response = await fond.findOne({
        where: {
          id: parseInt(req.params.id),
          // ...
        },
        order: [['id', 'DESC']]
      });





      const funds = {
        id: response.id,
        nom_fond: response.nom_fond.toString(),
        categorie_libelle: response.categorie_libelle,
        categorie_national: response.categorie_national,
        societe_gestion:response.societe_gestion,
        categorie_globale:response.categorie_globale,
        pays:response.pays,
        devise: response.dev_libelle, // assuming dev_libelle is the currency
        datejour: response.datejour,
        active: response.active,
        code_ISIN: response.code_ISIN
      };

      res.json({
        code: 200,
        funds,
      });
    } catch (error) {
      console.error("Une erreur s'est produite :", error);
      res.status(500).json({ message: 'Erreur interne du serveur' });
    }
  });
  app.get('/api/getfondbyid/:id', async (req, res) => {
    try {


      const distinctFundIdss = req.query.funds.replace(/[^0-9A-Za-z\s,]+/g, '').split(',')
      const distinctFundIdsParsed = distinctFundIdss.map(id => parseInt(id));

      const response = await fond.findAll({
        where: {
          id: req.params.id,
          // ...
        },
        order: [['id', 'DESC']]
      });

      const commonDates = await vl.findAll({
        attributes: ['date'],
        where: {
          fund_id: distinctFundIdsParsed
        },
        group: ['date'],
        having: Sequelize.literal(`COUNT(DISTINCT fund_id) = ${distinctFundIdsParsed.length}`),
        order: [['date', 'DESC']],
        limit: 1,
        raw: true
      });
      const commonDate = commonDates.length > 0 ? commonDates[0].date : new Date();;

      const response1 = await vl.findAll({
        where: {
          fund_id: req.params.id,
          date: {
            [Sequelize.Op.lte]: commonDate
          }
        },
        order: [
          ['date', 'ASC']
        ]
      });


      const values = response1.map((data) => data.value);
      const values_eur = response1.map((data) => data.value_EUR);
      const values_usd = response1.map((data) => data.value_USD);


      const lastValue = values[response1.length - 1];
      const lastValue_EUR = values_eur[response1.length - 1];
      const lastValue_USD = values_usd[response1.length - 1];

      const funds = response.map(data => ({
        id: data.id,
        lastValue: lastValue,
        lastValue_EUR: lastValue_EUR,
        lastValue_USD: lastValue_USD,
        nom_fond: data.nom_fond.toString(),
        code_ISIN: data.dev_libelle,
        categorie_libelle: data.categorie_libelle,
        categorie_national: data.categorie_national,
        devise: data.dev_libelle,
        datejour: commonDate,
        active: data.active,
        code_ISIN: data.code_ISIN
      }));
      const baseUrl = urll; // Remplacez par votre URL de base

      const lastValResponse = await fetch(`${baseUrl}/api/performances/fond/${req.params.id}`);

      if (!lastValResponse.ok) {
        return res.status(404).json({ message: 'Fonds introuvable' });
      }

      const lastValData = await lastValResponse.json();
      res.json({
        code: 200,
        data: {
          funds,
          performances: lastValData
        }
      });
    } catch (error) {
      console.error("Une erreur s'est produite :", error);
      res.status(500).json({ message: 'Erreur interne du serveur' });
    }
  });
  app.get('/api/getsocieterecherche', (req, res) => {
    // Première requête pour récupérer toutes les sociétés de gestion
    societe.findAll({
      group: ['nom'],
      order: [['nom', 'ASC']]
    }).then(societes => {
      const societesGestion = societes.map(societe => societe.nom);

      // Pour chaque société de gestion, effectuez une deuxième requête pour compter le nombre de fonds associés
      const promises = societesGestion.map(societeGestion => {
        return fond.count({
          where: {
            societe_gestion: societeGestion
          }
        });
      });

      // Attendez que toutes les promesses soient résolues
      return Promise.all(promises)
        .then(counts => {
          const societesAvecCounts = societesGestion.map((societeGestion, index) => ({
            ...societes.find(societe => societe.nom === societeGestion).toJSON(), // Ajouter toutes les colonnes de la société
            nbre_fonds: counts[index]
          }));
          return societesAvecCounts;
        });
    })
      .then(societesAvecCounts => {
        res.json({
          code: 200,
          data: {
            societes: societesAvecCounts
          }
        });
      })
      .catch(error => {
        console.error('Error:', error);
        res.status(500).json({ error: 'Une erreur est survenue lors de la récupération des données.' });
      });
  });

  app.get('/api/getsocieteidmeta/:id', (req, res) => {
    const societeId = req.params.id;
    societe.findOne({
      where: { nom: societeId }
    }).then(societe => {
      if (!societe) {
        return res.status(404).json({ error: "Societe not found" });
      }
      res.json({
        code: 200,
        data: {
          societe: societe
        }
      });
    })
    .catch(error => {
      console.error('Error:', error);
      res.status(500).json({ error: 'Une erreur est survenue lors de la récupération des données.' });
    });
  });

  app.get('/api/getpaysidmeta/:id', (req, res) => {
    const societeId = req.params.id;
    pays_regulateurs.findOne({
      where: { pays: societeId }
    }).then(pays => {
      if (!pays) {
        return res.status(404).json({ error: "Pays not found" });
      }
      res.json({
        code: 200,
        data: {
          pays: pays
        }
      });
    })
    .catch(error => {
      console.error('Error:', error);
      res.status(500).json({ error: 'Une erreur est survenue lors de la récupération des données.' });
    });
  });

  app.get('/api/getData', (req, res) => {
    pays_regulateurs.findAll({
      where: {
        //  id: searchTerm
        /* id: {
           //  [Sequelize.Op.like]: `%${searchTerm}%`
         }*/
      },
      order: [
        ['created', 'ASC']
      ]
    })
      .then(response => {
        const funds = response.map((data) => data.id);


        res.json({
          code: 200,
          data: {



          }
        })

      })
  })
  app.get('/api/fondscharge/:id', async (req, res) => {
    try {
      const id = req.params.id;

      // Recherchez le personnel dans la base de données en fonction de son ID
      const existingPersonnel = await fond.findOne({ where: { id } });

      if (!existingPersonnel) {
        return res.status(404).json({ error: "Personnel not found" });
      }

      // Envoyez les données du personnel trouvé
      res.status(200).json(existingPersonnel);
    } catch (error) {
      console.error("Error fetching personnel:", error);
      res.status(500).json({ error: 'An error occurred while fetching personnel data.' });
    }
  });
  app.post('/api/postfond', async (req, res) => {
    try {
      /* const {
         nomDuFonds,
         numeroDagrement,
         codeISIN,
         dateDeLaPremiereVL,
         deviseDeValorisation,
         regulateur,
         periodicitevalorisation,
         pays,
         societe
       } = req.body;*/

      const {
        nom_fond,
        pays,
        periodicite,
        structure_fond,
        code_ISIN,
        date_creation,
        dev_libelle,
        societe_gestion,
        categorie_libelle,
        classification,
        type_investissement,
        nom_gerant,
        categorie_globale,
        categorie_national,
        categorie_regional,
        frais_gestion,
        frais_souscription,
        frais_entree,
        frais_sortie,
        minimum_investissement,
        affectation,
        frais_rachat,
        description,
        strategie_politique_invest,
        philosophie_fond,
        //  horizonplacement,
        date_agrement,
        date_premiere_vl,
        active,
        depositaire,
        teneur_registre,
        valorisateur,
        centralisateur,
        agent_transfert,
        agent_payeur,
        numero_agrement,
        montant_premier_vl,
        montant_actif_net,
        duree_investissement_recommande,
        date_cloture,
        heure_cutt_off,
        delai_reglement,
        souscripteur,
        datejour
      } = req.body;

      //  const convertedDate = convertDateFormat(dateDeLaPremiereVL);
      fond.create({
        nom_fond,
        pays,
        periodicite,
        structure_fond,
        code_ISIN,
        date_creation,
        dev_libelle,
        societe_gestion,
        categorie_libelle,
        classification,
        type_investissement,
        nom_gerant,
        categorie_globale,
        categorie_national,
        categorie_regional,
        frais_gestion,
        frais_souscription,
        frais_entree,
        frais_sortie,
        minimum_investissement,
        affectation,
        frais_rachat,
        description,
        strategie_politique_invest,
        philosophie_fond,
        //  horizonplacement,
        date_agrement,
        date_premiere_vl,
        active,
        depositaire,
        teneur_registre,
        valorisateur,
        centralisateur,
        agent_transfert,
        agent_payeur,
        numero_agrement,
        montant_premier_vl,
        montant_actif_net,
        duree_investissement_recommande,
        date_cloture,
        heure_cutt_off,
        delai_reglement,
        souscripteur,
        datejour
      })



      // Répondez avec un message de succès ou autre réponse appropriée
      res.status(200).json({ message: 'Données insérées avec succès' });
    } catch (error) {
      // Gérez les erreurs ici
      console.error('Erreur lors de l\'insertion en base de données :', error);
      res.status(500).json({ message: 'Erreur lors de l\'insertion en base de données' });
    }
  });
  app.post('/api/updatefondmodif/:id', async (req, res) => {
    try {
      const {
        nom_fond,
        pays,
        periodicite,
        structure_fond,
        code_ISIN,
        date_creation,
        dev_libelle,
        societe_gestion,
        categorie_libelle,
        classification,
        type_investissement,
        nom_gerant,
        categorie_globale,
        categorie_national,
        categorie_regional,
        frais_gestion,
        frais_souscription,
        frais_entree,
        frais_sortie,
        minimum_investissement,
        affectation,
        frais_rachat,
        description,
        strategie_politique_invest,
        philosophie_fond,
        horizonplacement,
        date_agrement,
        date_premiere_vl,
        active,
        depositaire,
        teneur_registre,
        valorisateur,
        centralisateur,
        agent_transfert,
        agent_payeur,
        numero_agrement,
        montant_premier_vl,
        montant_actif_net,
        duree_investissement_recommande,
        date_cloture,
        heure_cutt_off,
        delai_reglement,
        souscripteur,
        datejour
      } = req.body;

      // Vérifiez si un fond avec le même identifiant existe déjà
      const existingFond = await fond.findOne({ where: { id: parseInt(req.params.id) } });

      if (existingFond) {
        // Si le fond existe déjà, mettez à jour ses informations
        const updatedValues = {};

        Object.keys(existingFond.toJSON()).forEach(key => {
          if (key in {
            nom_fond, pays, periodicite, structure_fond, code_ISIN, date_creation, dev_libelle,
            societe_gestion, categorie_libelle, classification, type_investissement, nom_gerant,
            categorie_globale, categorie_national, categorie_regional, frais_gestion, frais_souscription,
            frais_entree, frais_sortie, minimum_investissement, affectation, frais_rachat, description,
            strategie_politique_invest, philosophie_fond, date_agrement, date_premiere_vl, active,
            depositaire, teneur_registre, valorisateur, centralisateur, agent_transfert, agent_payeur,
            numero_agrement, montant_premier_vl, montant_actif_net, duree_investissement_recommande,
            date_cloture, heure_cutt_off, delai_reglement, souscripteur, datejour, horizonplacement
          }) {
            const value = eval(key);
            if (value !== '' && value !== undefined) {
              updatedValues[key] = value;
            }
          }
        });

        await existingFond.update(updatedValues);

        // Répondez avec un message de succès ou autre réponse appropriée
        res.status(200).json({ message: 'Données mises à jour avec succès' });
      } else {
        // Si aucun fond avec cet identifiant n'existe
        res.status(404).json({ message: 'Fond non trouvé' });
      }
    } catch (error) {
      // Gérez les erreurs ici
      console.error('Erreur lors de la mise à jour en base de données :', error);
      res.status(500).json({ message: 'Erreur lors de la mise à jour en base de données' });
    }
  });


  app.post('/api/ajoutVL/:id', async (req, res) => {
    try {
      const vlEntries = req.body; // This should be an array of Vl entries
      let fonds = await fond.findOne({
        where: {
          id: parseInt(req.params.id)
        },

      });
      const paireEUR = "EUR" + "/" + fonds.dev_libelle
      const paireUSD = "USD" + "/" + fonds.dev_libelle


      let vlEntriesNEW = [];

      // Update each vlEntry and add to vlEntriesNEW
      for (let i = 0; i < vlEntries.length; i++) {
        const vlEntry = vlEntries[i];
        let exchangeRatesEUR = await devisedechanges.findOne({
          where: {
            date: { [Op.lte]: vlEntry.date }, // Chercher la date la plus proche inférieure ou égale
            paire: paireEUR,
          },
          order: [['date', 'DESC']], // Tri par date descendant pour obtenir la date la plus proche
        });
        let exchangeRatesUSD = await devisedechanges.findOne({
          where: {
            date: { [Op.lte]: vlEntry.date }, // Chercher la date la plus proche inférieure ou égale
            paire: paireUSD,
          },
          order: [['date', 'DESC']] // Tri par date descendant
        });
        const vlEntryNEW = {
          fund_id: vlEntry.fund_id,
          date: vlEntry.date,
          value: parseFloat(vlEntry.value),
          value_EUR: exchangeRatesEUR ? parseFloat(vlEntry.value) * exchangeRatesEUR.value : null,
          value_USD: exchangeRatesUSD ? parseFloat(vlEntry.value) * exchangeRatesUSD.value : null,
          actif_net: parseFloat(vlEntry.actif_net),
          actif_net_EUR: exchangeRatesEUR ? parseFloat(vlEntry.actif_net) * exchangeRatesEUR.value : null,
          actif_net_USD: exchangeRatesUSD ? parseFloat(vlEntry.actif_net) * exchangeRatesUSD.value : null,
          indRef: vlEntry.indRef != undefined ? parseFloat(vlEntry.indRef) : null,
          indRef_EUR: vlEntry.indRef != undefined ? parseFloat(vlEntry.indRef) * exchangeRatesEUR.value : null,
          indRef_USD: vlEntry.indRef != undefined ? parseFloat(vlEntry.indRef) * exchangeRatesUSD.value : null
        };
        const existingEntry = await vl.findOne({
          where: {
            date: vlEntry.date,
            fund_id: parseInt(req.params.id)
          }
        });

        if (existingEntry) {
          // If an existing entry is found, update it
          await vl.update(vlEntryNEW, {
            where: {
              date: vlEntry.date,
              fund_id: parseInt(req.params.id)
            }
          });
        } else {
          // If no existing entry is found, create a new one
          vlEntriesNEW.push(vlEntryNEW);
        }
      }
      if (vlEntriesNEW.length > 0) {
        await vl.bulkCreate(vlEntriesNEW);
      }
      // Assuming you have a Sequelize model named 'vl', you can create multiple Vl entries as follows:



      // Respond with a success message or appropriate response
      res.status(200).json({ message: 'Data inserted successfully' });
    } catch (error) {
      // Handle errors here
      console.error('Error inserting data into the database:', error);
      res.status(500).json({ message: 'Error inserting data into the database' });
    }
  });

  app.post('/api/ajoutIndice/:id', async (req, res) => {
    try {
      const vlEntries = req.body; // This should be an array of Vl entries
      let fonds = await fond.findOne({
        where: {
          id: parseInt(req.params.id)
        },

      });
      const paireEUR = "EUR" + "/" + fonds.dev_libelle
      const paireUSD = "USD" + "/" + fonds.dev_libelle


      let vlEntriesNEW = [];
      let indiceEntriesNEW = [];

      // Update each vlEntry and add to vlEntriesNEW
      for (let i = 0; i < vlEntries.length; i++) {
        const vlEntry = vlEntries[i];
        let exchangeRatesEUR = await devisedechanges.findOne({
          where: {
            date: { [Op.lte]: vlEntry.date }, // Chercher la date la plus proche inférieure ou égale
            paire: paireEUR,
          },
          order: [['date', 'DESC']] // Tri par date descendant
        });
        let exchangeRatesUSD = await devisedechanges.findOne({
          where: {
            date: { [Op.lte]: vlEntry.date }, // Chercher la date la plus proche inférieure ou égale
            paire: paireUSD,
          },
          order: [['date', 'DESC']] // Tri par date descendant
        });
        const vlEntryNEW = {
          fund_id: vlEntry.fund_id,
          date: vlEntry.date,
          indRef: vlEntry.value != undefined ? parseFloat(vlEntry.value) : null,
          indRef_EUR: vlEntry.value != undefined ? parseFloat(vlEntry.value) * exchangeRatesEUR.value : null,
          indRef_USD: vlEntry.value != undefined ? parseFloat(vlEntry.value) * exchangeRatesUSD.value : null
        };
        const indiceEntryNEW = {
          date: vlEntry.date,
          valeur: parseFloat(vlEntry.value),
          id_indice: vlEntry.nom,
          type_indice_id: 1

        };
        const existingEntry = await vl.findOne({
          where: {
            date: vlEntryNEW.date,
            fund_id: parseInt(req.params.id)
          }
        });

        if (existingEntry) {
          // If an existing entry is found, update it
          await vl.update(vlEntryNEW, {
            where: {
              date: vlEntryNEW.date,
              fund_id: parseInt(req.params.id)
            }
          });
        } else {
          // If no existing entry is found, create a new one
          vlEntriesNEW.push(vlEntryNEW);
        }

        const existingEntry1 = await indice.findOne({
          where: {
            date: indiceEntryNEW.date,
            id_indice: indiceEntryNEW.id_indice
          }
        });

        if (existingEntry1) {
          // If an existing entry is found, update it
          await indice.update(indiceEntryNEW, {
            where: {
              date: indiceEntryNEW.date,
              id_indice: indiceEntryNEW.id_indice
            }
          });
        } else {
          // If no existing entry is found, create a new one
          indiceEntriesNEW.push(indiceEntryNEW);
        }
      }

      // Assuming you have a Sequelize model named 'vl', you can create multiple Vl entries as follows:
      if (vlEntriesNEW.length > 0)
        await vl.bulkCreate(vlEntriesNEW);


      if (indiceEntriesNEW.length > 0)
        await indice.bulkCreate(indiceEntriesNEW);



      // Respond with a success message or appropriate response
      res.status(200).json({ message: 'Data inserted successfully' });
    } catch (error) {
      // Handle errors here
      console.error('Error inserting data into the database:', error);
      res.status(500).json({ message: 'Error inserting data into the database' });
    }
  });


  app.post('/api/uploadsfilevl/:id', upload.single('file'), async (req, res) => {
    if (!req.file) {
      res.status(400).send('No file uploaded.');
      return;
    }

    if (req.file.mimetype !== 'text/csv' && req.file.mimetype !== 'application/vnd.ms-excel') {
      res.status(400).send('Uploaded file is not a CSV.');
      return;
    }

    const vlEntries = [];
    const promises = [];

    fs.createReadStream(req.file.path)
      .pipe(csv({ separator: ';' })) // Utilisez le séparateur correct pour le fichier CSV
      .on('headers', (headers) => {
        console.log('Headers:', headers); // Affiche les en-têtes pour vérifier leur structure
      })
      .on('data', (row) => {
        const promise = (async () => {
          console.log('Row:', row); // Affichez chaque ligne pour le débogage

          let fonds = await fond.findOne({
            where: {
              id: parseInt(req.params.id)
            },
          });

          if (!fonds) {
            console.error('Fund not found for id:', req.params.id);
            return;
          }

          const paireEUR = "EUR" + "/" + fonds.dev_libelle;
          const paireUSD = "USD" + "/" + fonds.dev_libelle;

          let exchangeRatesEUR = await devisedechanges.findOne({
            where: {
              date: { [Op.lte]: row.date }, // Chercher la date la plus proche inférieure ou égale
              paire: paireEUR,
            },
            order: [['date', 'DESC']] // Tri par date descendant
          });

          let exchangeRatesUSD = await devisedechanges.findOne({
            where: {
              date: { [Op.lte]: row.date }, // Chercher la date la plus proche inférieure ou égale
              paire: paireUSD,
            },
            order: [['date', 'DESC']] // Tri par date descendant
          });

          let vlEntry = {
            fund_id: parseInt(req.params.id),
            date: row.date,
            value: null,
            value_EUR: null,
            value_USD: null,
            actif_net: null,
            actif_net_EUR: null,
            actif_net_USD: null,
            indRef: null,
            indRef_EUR: null,
            indRef_USD: null
          };

          if ('value' in row && exchangeRatesEUR && exchangeRatesUSD) {
            vlEntry.value = parseFloat(row.value);
            vlEntry.value_EUR = parseFloat(row.value) * exchangeRatesEUR.value;
            vlEntry.value_USD = parseFloat(row.value) * exchangeRatesUSD.value;
          }

          if ('actif_net' in row && exchangeRatesEUR && exchangeRatesUSD) {
            vlEntry.actif_net = parseFloat(row.actif_net);
            vlEntry.actif_net_EUR = parseFloat(row.actif_net) * exchangeRatesEUR.value;
            vlEntry.actif_net_USD = parseFloat(row.actif_net) * exchangeRatesUSD.value;
          }

          if ('indRef' in row && exchangeRatesEUR && exchangeRatesUSD) {
            vlEntry.indRef = parseFloat(row.indRef);
            vlEntry.indRef_EUR = parseFloat(row.indRef) * exchangeRatesEUR.value;
            vlEntry.indRef_USD = parseFloat(row.indRef) * exchangeRatesUSD.value;
          }

          console.log(vlEntry); // Affichez l'entrée VL pour le débogage

          const existingEntry = await vl.findOne({
            where: {
              date: row.date,
              fund_id: parseInt(req.params.id)
            }
          });

          if (existingEntry) {
            // Si une entrée existante est trouvée, mettez-la à jour
            await vl.update(vlEntry, {
              where: {
                date: row.date,
                fund_id: parseInt(req.params.id)
              }
            });
          } else {
            // Si aucune entrée existante n'est trouvée, créez-en une nouvelle
            vlEntries.push(vlEntry);
          }
        })();

        promises.push(promise);
      })
      .on('end', async () => {
        try {
          // Attendre que toutes les promesses soient résolues
          await Promise.all(promises);

          // Sauvegardez les entrées VL dans la base de données
          if (vlEntries.length > 0) {
            await vl.bulkCreate(vlEntries);
          }

          // Supprimez le fichier temporaire
          fs.unlinkSync(req.file.path);

          res.status(200).send('File uploaded and data saved successfully.');
        } catch (error) {
          console.error('Database error:', error);
          res.status(500).send('Error saving data to the database.');
        }
      })
      .on('error', (error) => {
        console.error('Error reading CSV file:', error);
        res.status(500).send('Error processing the file.');
      });
  });

  app.post('/api/uploadsfileindice/:id', upload.single('file'), async (req, res) => {
    if (!req.file) {
      res.status(400).send('No file uploaded.');
      return;
    }

    if (req.file.mimetype !== 'text/csv') {
      res.status(400).send('Uploaded file is not a CSV.');
      return;
    }

    const vlEntries = []; // Initialize an array to store vl entries
    const indices = []; // Initialize an array to store indice entries
    const promises = []; // Initialize an array to store promises

    fs.createReadStream(req.file.path)
      .pipe(csv({ separator: ';' })) // Utilisez le séparateur correct pour le fichier CSV
      .on('headers', (headers) => {
        console.log('Headers:', headers); // Affiche les en-têtes pour vérifier leur structure
      })
      .on('data', (row) => {
        const promise = (async () => {
          console.log('Row:', row); // Affichez chaque ligne pour le débogage

          let fonds = await fond.findOne({
            where: {
              id: parseInt(req.params.id)
            },
          });

          if (!fonds) {
            console.error('Fund not found for id:', req.params.id);
            return;
          }

          const paireEUR = "EUR" + "/" + fonds.dev_libelle;
          const paireUSD = "USD" + "/" + fonds.dev_libelle;

          let exchangeRatesEUR = await devisedechanges.findOne({
            where: {
              date: { [Op.lte]: row.date }, // Chercher la date la plus proche inférieure ou égale
              paire: paireEUR,
            },
            order: [['date', 'DESC']] // Tri par date descendant
          });

          let exchangeRatesUSD = await devisedechanges.findOne({
            where: {
              date: { [Op.lte]: row.date }, // Chercher la date la plus proche inférieure ou égale
              paire: paireUSD,
            },
            order: [['date', 'DESC']] // Tri par date descendant
          });

          let vlEntry = {
            fund_id: parseInt(req.params.id),
            date: row.date,
            indRef: null,
            indRef_EUR: null,
            indRef_USD: null
          };

          let indiceEntry = {
            date: row.date,
            valeur: null,
            id_indice: row.nom,
            type_indice_id: 1,
          };

          if ('value' in row && exchangeRatesEUR && exchangeRatesUSD) {
            indiceEntry.valeur = parseFloat(row.value);
            vlEntry.indRef = parseFloat(row.value) * exchangeRatesEUR.value;
            vlEntry.indRef_EUR = parseFloat(row.value) * exchangeRatesEUR.value;
            vlEntry.indRef_USD = parseFloat(row.value) * exchangeRatesUSD.value;
          }

          console.log(vlEntry); // Affichez l'entrée VL pour le débogage

          const existingVLEntry = await vl.findOne({
            where: {
              date: row.date,
              fund_id: parseInt(req.params.id)
            }
          });

          if (existingVLEntry) {
            // Si une entrée existante est trouvée, mettez-la à jour
            await vl.update(vlEntry, {
              where: {
                date: row.date,
                fund_id: parseInt(req.params.id)
              }
            });
          } else {
            // Si aucune entrée existante n'est trouvée, créez-en une nouvelle
            vlEntries.push(vlEntry);
          }

          const existingIndiceEntry = await indice.findOne({
            where: {
              date: row.date,
              id_indice: row.nom,
            }
          });

          if (existingIndiceEntry) {
            // Si une entrée existante est trouvée, mettez-la à jour
            await indice.update(indiceEntry, {
              where: {
                date: row.date,
                id_indice: row.nom,
              }
            });
          } else {
            // Si aucune entrée existante n'est trouvée, créez-en une nouvelle
            indices.push(indiceEntry);
          }
        })();

        promises.push(promise);
      })
      .on('end', async () => {
        try {
          // Attendre que toutes les promesses soient résolues
          await Promise.all(promises);

          // Sauvegardez les entrées VL et indices dans la base de données
          if (vlEntries.length > 0) {
            await vl.bulkCreate(vlEntries);
          }
          if (indices.length > 0) {
            await indice.bulkCreate(indices);
          }

          // Supprimez le fichier temporaire
          fs.unlinkSync(req.file.path);

          res.status(200).send('File uploaded and data saved successfully.');
        } catch (error) {
          console.error('Database error:', error);
          res.status(500).send('Error saving data to the database.');
        }
      })
      .on('error', (error) => {
        console.error('Error reading CSV file:', error);
        res.status(500).send('Error processing the file.');
      });
  });

  /**
  * @swagger
  * /api/comparaison/{fund_id}:
  *   get:
  *     tags:
  *       - Derniere Valeur Liquidative
  *     summary: Retrieve the last value and date for a specific record.
  *     description: Retrieve the last liquidation value and date for a specific record.
  *     parameters:
  *       - name: fund_id
  *         in: path
  *         description: The fund_id of the record.
  *         required: true
  *         schema:
  *           type: string
  *     responses:
  *       200:
  *         description: Successful response containing the last value and date.
  *         content:
  *           application/json:
  *             schema:
  *               type: object
  *               properties:
  *                 code:
  *                   type: integer
  *                   example: 200
  *                 data:
  *                   type: object
  *                   properties:
  *                     lastValue:
  *                       type: number
  *                       format: double
  *                       example: 123.45
  *                       description: The last liquidation value.
  *                     lastDate:
  *                       type: string
  *                       format: date
  *                       example: "2023-09-02"
  *                       description: The date corresponding to the last value.
  */
  app.get('/api/comparaison', async (req, res) => {
    const selectedValues = req.query.query;

    if (!selectedValues) {
      return res.status(400).json({ error: 'Le paramètre query est manquant.' });
    }


    const valuesArray = selectedValues.split(',');
    const promessesDB = valuesArray.map((value) => {
      return fond.findByPk(value)
        .then((fond) => {
          if (fond) {
            return fond.toJSON();
          } else {
            return { error: `Aucun élément trouvé pour l'ID ${value}` };
          }
        })
        .catch((error) => {
          console.error('Erreur lors de la recherche en base de données :', error);
          return { error: 'Erreur lors de la recherche en base de données.' };
        });
    });
    // Créez un tableau de promesses pour les appels à l'API externe initiale
    const promessesAPI = valuesArray.map((value) => {
      // Effectuez une requête à l'API externe initiale pour chaque élément
      return fetch(`${urll}/api/performancescomparaison/fond/${value}`)
        .then((response) => response.json())
        .catch((error) => {
          console.error('Erreur lors de l\'appel à l\'API externe :', error);
          // Vous pouvez gérer l'erreur ici si nécessaire
          return { error: 'Erreur lors de l\'appel à l\'API externe.' };
        });
    });

    // Utilisez Promise.all pour attendre que toutes les requêtes se terminent
    Promise.all([Promise.all(promessesDB), Promise.all(promessesAPI)])
      .then(async ([dbResults, apiResults]) => {
        // dbResults contient les éléments trouvés en base de données
        // apiResults contient les réponses de l'API externe initiale

        // Vous pouvez maintenant combiner les données des deux sources comme nécessaire
        const funds = valuesArray.map((value, index) => ({
          id: value,
          fundData: dbResults[index],
          firstData: apiResults[index],
        }));





        const fundsWithGraphData = await Promise.all(funds.map(async (fund) => {
          const response = await vl.findAll({
            where: {
              fund_id: fund.id,
            },
            order: [['date', 'ASC']],
          });

          /* const graphs = response.map((data) => ({
             dates: moment(data.date).format('YYYY-MM-DD'),
             values: data.value, // Remplacez avec la propriété correcte de l'objet
             valuesInd: data.indRef,
           }));*/
          const graphs = response.map(data => {
            if (data.value !== null && data.indRef !== null) {
              return {
                dates: moment(data.date).format('YYYY-MM-DD'), // Remplacez avec la propriété correcte de l'objet
                values: data.value, // Remplacez avec la propriété correcte de l'objet
                valuesInd: data.indRef,
              };
            } else {
              return null; // Ignorer les lignes où la condition n'est pas satisfaite
            }
          }).filter(Boolean); // Supprimer les valeurs nulles de l'array

          // Ajoutez la propriété graphData à l'objet fund
          return {
            ...fund,
            graphData: graphs,
          };
        }));
        // Effectuez une nouvelle série d'appels à une deuxième API pour chaque élément
        const promessesAPI2 = funds.map((fund) => {
          // Effectuez une requête à la deuxième API pour chaque élément
          return fetch(`${urll}/api/ratios/1/${fund.id}`)
            .then((response) => response.json())
            .catch((error) => {
              console.error('Erreur lors de l\'appel à la deuxième API :', error);
              // Vous pouvez gérer l'erreur ici si nécessaire
              return { error: 'Erreur lors de l\'appel à la deuxième API.' };
            });
        });

        // Utilisez Promise.all pour attendre que toutes les requêtes à la deuxième API se terminent
        Promise.all(promessesAPI2)
          .then((results2) => {
            // Combinez les données de l'API externe initiale avec les données de la deuxième API
            const fundsWithSecondData = fundsWithGraphData.map((fund, index) => ({
              ...fund,
              secondData: results2[index], // Données de la deuxième API
              graphData: fund.graphData, // Conservez la propriété graphData
            }));

            // Effectuez une nouvelle série d'appels à une troisième API pour chaque élément
            const promessesAPI3 = fundsWithSecondData.map((fund) => {
              // Effectuez une requête à la troisième API pour chaque élément
              return fetch(`${urll}/api/ratios/3/${fund.id}`)
                .then((response) => response.json())
                .catch((error) => {
                  console.error('Erreur lors de l\'appel à la troisième API :', error);
                  // Vous pouvez gérer l'erreur ici si nécessaire
                  return { error: 'Erreur lors de l\'appel à la troisième API.' };
                });
            });

            // Utilisez Promise.all pour attendre que toutes les requêtes à la troisième API se terminent
            Promise.all(promessesAPI3)
              .then((results3) => {
                // Combinez les données des API précédentes avec les données de la troisième API
                const fundsWithThirdData = fundsWithSecondData.map((fund, index) => ({
                  ...fund,
                  thirdData: results3[index], // Données de la troisième API
                  graphData: fund.graphData, // Conservez la propriété graphData
                }));

                // Effectuez une nouvelle série d'appels à une quatrième API pour chaque élément
                const promessesAPI4 = fundsWithThirdData.map((fund) => {
                  // Effectuez une requête à la quatrième API pour chaque élément
                  return fetch(`${urll}/api/ratios/5/${fund.id}`)
                    .then((response) => response.json())
                    .catch((error) => {
                      console.error('Erreur lors de l\'appel à la quatrième API :', error);
                      // Vous pouvez gérer l'erreur ici si nécessaire
                      return { error: 'Erreur lors de l\'appel à la quatrième API.' };
                    });
                });

                // Utilisez Promise.all pour attendre que toutes les requêtes à la quatrième API se terminent
                Promise.all(promessesAPI4)
                  .then((results4) => {
                    // Combinez les données des API précédentes avec les données de la quatrième API
                    const fundsWithFourthData = fundsWithThirdData.map((fund, index) => ({
                      ...fund,
                      fourthData: results4[index], // Données de la quatrième API
                      graphData: fund.graphData, // Conservez la propriété graphData
                    }));
                    console.log(fundsWithGraphData);
                    console.log(fundsWithSecondData);
                    console.log(fundsWithThirdData);

                    // console.log(fundsWithFourthData);
                    res.json({
                      code: 200,
                      data: {
                        funds: fundsWithFourthData,
                      },
                    });
                  });
              });
          })
      })


      .catch((error) => {
        console.error('Erreur lors de la récupération des données :', error);
        res.status(500).json({ error: 'Une erreur est survenue lors de la récupération des données.' });
      });
  });





  /**
   * @swagger
   * /api/performances/fond/{fund_id}:
   *  get:
   *     tags:
   *       - Performance Data
   *     summary: Retrieve performance data for a specific fund.
   *     description: Retrieve various performance metrics for a specific fund based on its ID.
   *     parameters:
   *       - name: fund_id
   *         in: path
   *         description: The fund_id of the fund.
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Successful response containing various performance metrics.
   *         content:
   *           application/json:
   *             schema:
   *               type: object
   *               properties:
   *                 code:
   *                   type: integer
   *                   example: 200
   *                 data:
   *                   type: object
   *                   properties:
   *                     perfVeille:
   *                       type: number
   *                       format: double
   *                       description: Performance for the previous day.
   *                     perf4Semaines:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 4 weeks.
   *                     perf1erJanvier:
   *                       type: number
   *                       format: double
   *                       description: Performance since January 1st of the current year.
   *                     perf3Mois:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 3 months.
   *                     perf6Mois:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 6 months.
   *                     perf1An:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 1 year.
   *                     perf3Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 3 years.
   *                     perf5Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 5 years.
   *                     perf8Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 8 years.
   *                     perf10Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 10 years.
   *                     perf12Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 12 years.
   *                     perf15Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 15 years.
   *                     perf20Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 20 years.
   *                     perfOrigine:
   *                       type: number
   *                       format: double
   *                       description: Performance since the fund's inception.
   *                     perfFindeMois1An:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (1 year).
   *                     perfFindeMois3Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (3 years).
   *                     perfFindeMois5Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (5 years).
   *                     perfFindeMois8Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (8 years).
   *                     perfFindeMois10Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (10 years).
   *                     perfFindeMois12Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (12 years).
   *                     perfFindeMois15Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (15 years).
   *                     perfFindeMois20Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (20 years).
   *                     perfAnnualized1An:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 1 year.
   *                     perfAnnualized3Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 3 years.
   *                     perfAnnualized5Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 5 years.
   *                     perfAnnualized8Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 8 years.
   *                     perfAnnualized10Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 10 years.
   *                     perfAnnualized12Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 12 years.
   *                     perfAnnualized15Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 15 years.
   *                     perfAnnualized20Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 20 years.
   *                     perfAnnualizedOrigine:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance since the fund's inception.
   */
  app.get('/api/performances/fond/:id', async (req, res) => {
    const dateee = req.query.date;
    const resultat = await fond.findOne({
      attributes: ['categorie_libelle', 'categorie_national'],
      where: {
        id: req.params.id,
      },
    });
    const categorie = resultat.categorie_libelle;
    const categorie_national = resultat.categorie_national;
    let performancesCategorie;
    if (dateee) {
      performancesCategorie = await getPerformancesByCategorynow(categorie_national, dateee);
    }
    vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        const values = response.map((data) => data.vl_ajuste); //todo
        const actif_nets = response.map((data) => data.actif_net);
        const lastValueactif_net = actif_nets[actif_nets.length - 1];

        const lastValue = values[values.length - 1];
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const lastDate = dates[dates.length - 1]

        const targetYear = groupDatesByYear(dates).length

        const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);
        const perf3Moisactif_net = calculatePerformance(lastValueactif_net, actif_nets[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);

        // Calcul des performances glissantes
        const previousValue = values[values.length - 2];
        const perfVeille = calculatePerformance(lastValue, previousValue);
        const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
        const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
        const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
        const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
        const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
        const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
        const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
        const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
        const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
        const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
        const perf15Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]);
        const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
        const perfOrigine = calculatePerformance(lastValue, values[0]);

        //Performances fin de mois
        const targetDate1An = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
        console.log(values[dates.indexOf(targetDate1An)])

        const targetDate3Ans = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
        const targetDate5Ans = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
        const targetDate8Ans = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
        const targetDate10Ans = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
        const targetDate12Ans = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
        const targetDate15Ans = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
        const targetDate20Ans = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
        const targetDateOrigine = groupDatesByMonth(dates)[0]
        const perfFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])



        //Performances annualizées fin de mois
        const perfFindeMoisAnnualized1An = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
        const perfFindeMoisAnnualized3Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
        const perfFindeMoisAnnualized5Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
        const perfFindeMoisAnnualized8Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
        const perfFindeMoisAnnualized10Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
        const perfFindeMoisAnnualized12Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
        const perfFindeMoisAnnualized15Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates)))], 15);
        const perfFindeMoisAnnualized20Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates)))], 20);
        const perfFindeMoisAnnualizedOrigine = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);


        //Performances cumulées fin de mois
        const perfCumuleeFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfCumuleeFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfCumuleeFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfCumuleeFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfCumuleeFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfCumuleeFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfCumuleeFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfCumuleeFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfCumuleeFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        //Performances annualizées à date
        const perfAnnualizedtodate1An = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1);
        const perfAnnualizedtodate3Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3);
        const perfAnnualizedtodate5Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5);
        const perfAnnualizedtodate8Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8);
        const perfAnnualizedtodate10Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10);
        const perfAnnualizedtodate12Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12);
        const perfAnnualizedtodate15Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15);
        const perfAnnualizedtodate20Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20);
        const perfAnnualizedtodateOrigine = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);
        //Performances  annee calendaire
        const ArrayDates = groupDatesByYear(dates);
        const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
        const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
        const multipliedValues = adaptValues1.map(item => {
          const year = item[0];
          const value1 = item[1];
          const value3 = item[2] * 100; // Multipliez la troisième position par 100

          return [year, value1, value3];
        });


        console.log(multipliedValues);
        res.json({
          code: 200,
          data: {
            fund_id: req.params.id,
            lastdatepreviousmonth: lastdatepreviousmonth,
            category: categorie,
            perf3Moisactif_net: perf3Moisactif_net,
            perfVeille: perfVeille,
            perf4Semaines: perf4Semaines,
            perf1erJanvier: perf1erJanvier,
            perf3Mois: perf3Mois,
            perf6Mois: perf6Mois,
            perf1An: perf1An,
            perf3Ans: perf3Ans,
            perf5Ans: perf5Ans,
            perf8Ans: perf8Ans,
            perf10Ans: perf10Ans,
            perf12Ans: perf12Ans,
            perf15Ans: perf15Ans,
            perf20Ans: perf20Ans,
            perfOrigine: perfOrigine,
            perfFindeMois1An: perfFindeMois1An,
            perfFindeMois3Ans: perfFindeMois3Ans,
            perfFindeMois5Ans: perfFindeMois5Ans,
            perfFindeMois8Ans: perfFindeMois8Ans,
            perfFindeMois10Ans: perfFindeMois10Ans,
            perfFindeMois12Ans: perfFindeMois12Ans,
            perfFindeMois15Ans: perfFindeMois15Ans,
            perfFindeMois20Ans: perfFindeMois20Ans,
            perfFindeMoisOrigine: perfFindeMoisOrigine,
            perfFindeMoisAnnualized1An: perfFindeMoisAnnualized1An,
            perfFindeMoisAnnualized3An: perfFindeMoisAnnualized3Ans,
            perfFindeMoisAnnualized5Ans: perfFindeMoisAnnualized5Ans,
            perfFindeMoisAnnualized8Ans: perfFindeMoisAnnualized8Ans,
            perfFindeMoisAnnualized10Ans: perfFindeMoisAnnualized10Ans,
            perfFindeMoisAnnualized12Ans: perfFindeMoisAnnualized12Ans,
            perfFindeMoisAnnualized15Ans: perfFindeMoisAnnualized15Ans,
            perfFindeMoisAnnualized20Ans: perfFindeMoisAnnualized20Ans,
            perfFindeMoisAnnualizedOrigine: perfFindeMoisAnnualizedOrigine,
            perfCumuleeFindeMois1An: perfCumuleeFindeMois1An,
            perfCumuleeFindeMois3Ans: perfCumuleeFindeMois3Ans,
            perfCumuleeFindeMois5Ans: perfCumuleeFindeMois5Ans,
            perfCumuleeFindeMois8Ans: perfCumuleeFindeMois8Ans,
            perfCumuleeFindeMois10Ans: perfCumuleeFindeMois10Ans,
            perfCumuleeFindeMois12Ans: perfCumuleeFindeMois12Ans,
            perfCumuleeFindeMois15Ans: perfCumuleeFindeMois15Ans,
            perfCumuleeFindeMois20Ans: perfCumuleeFindeMois20Ans,
            perfCumuleeFindeMoisOrigine: perfCumuleeFindeMoisOrigine,
            perfAnnualizedtodate1An: perfAnnualizedtodate1An,
            perfAnnualizedtodate3Ans: perfAnnualizedtodate3Ans,
            perfAnnualizedtodate5Ans: perfAnnualizedtodate5Ans,
            perfAnnualizedtodate8Ans: perfAnnualizedtodate8Ans,
            perfAnnualizedtodate10Ans: perfAnnualizedtodate10Ans,
            perfAnnualizedtodate12Ans: perfAnnualizedtodate12Ans,
            perfAnnualizedtodate15Ans: perfAnnualizedtodate15Ans,
            perfAnnualizedtodate20Ans: perfAnnualizedtodate20Ans,
            perfAnnualizedtodateOrigine: perfAnnualizedtodateOrigine,
            adaptValues1: multipliedValues,
            performancesCategorie: dateee ? performancesCategorie : null
          }
        })

      })
  })
  app.get('/api/performancescomparaison/fond/:id', async (req, res) => {
    const dateee = req.query.date;
    const resultat = await fond.findOne({
      attributes: ['categorie_libelle', 'categorie_national'],
      where: {
        id: req.params.id,
      },
    });
    const categorie = resultat.categorie_libelle;
    const categorie_national = resultat.categorie_national;

    // const performancesCategorie = await getPerformancesByCategorynow(categorie_national, dateee);

    vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        const values = response.map((data) => data.value);
        const actif_nets = response.map((data) => data.actif_net);
        const lastValueactif_net = actif_nets[actif_nets.length - 1];

        const lastValue = values[values.length - 1];
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const lastDate = dates[dates.length - 1]

        const targetYear = groupDatesByYear(dates).length

        const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);
        const perf3Moisactif_net = calculatePerformance(lastValueactif_net, actif_nets[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);

        // Calcul des performances glissantes
        const previousValue = values[values.length - 2];
        const perfVeille = calculatePerformance(lastValue, previousValue);
        const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
        const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
        const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
        const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
        const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
        const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
        const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
        const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
        const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
        const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
        const perf15Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]);
        const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
        const perfOrigine = calculatePerformance(lastValue, values[0]);

        //Performances fin de mois
        const targetDate1An = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
        console.log(values[dates.indexOf(targetDate1An)])

        const targetDate3Ans = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
        const targetDate5Ans = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
        const targetDate8Ans = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
        const targetDate10Ans = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
        const targetDate12Ans = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
        const targetDate15Ans = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
        const targetDate20Ans = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
        const targetDateOrigine = groupDatesByMonth(dates)[0]
        const perfFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])



        //Performances annualizées fin de mois
        const perfFindeMoisAnnualized1An = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
        const perfFindeMoisAnnualized3Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
        const perfFindeMoisAnnualized5Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
        const perfFindeMoisAnnualized8Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
        const perfFindeMoisAnnualized10Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
        const perfFindeMoisAnnualized12Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
        const perfFindeMoisAnnualized15Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates)))], 15);
        const perfFindeMoisAnnualized20Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates)))], 20);
        const perfFindeMoisAnnualizedOrigine = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);


        //Performances cumulées fin de mois
        const perfCumuleeFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfCumuleeFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfCumuleeFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfCumuleeFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfCumuleeFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfCumuleeFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfCumuleeFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfCumuleeFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfCumuleeFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        //Performances annualizées à date
        const perfAnnualizedtodate1An = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1);
        const perfAnnualizedtodate3Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3);
        const perfAnnualizedtodate5Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5);
        const perfAnnualizedtodate8Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8);
        const perfAnnualizedtodate10Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10);
        const perfAnnualizedtodate12Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12);
        const perfAnnualizedtodate15Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15);
        const perfAnnualizedtodate20Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20);
        const perfAnnualizedtodateOrigine = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);
        //Performances  annee calendaire
        const ArrayDates = groupDatesByYear(dates);
        const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
        const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
        const multipliedValues = adaptValues1.map(item => {
          const year = item[0];
          const value1 = item[1];
          const value3 = item[2] * 100; // Multipliez la troisième position par 100

          return [year, value1, value3];
        });


        console.log(multipliedValues);
        res.json({
          code: 200,
          data: {
            fund_id: req.params.id,
            lastdatepreviousmonth: lastdatepreviousmonth,
            category: categorie,
            perf3Moisactif_net: perf3Moisactif_net,
            perfVeille: perfVeille,
            perf4Semaines: perf4Semaines,
            perf1erJanvier: perf1erJanvier,
            perf3Mois: perf3Mois,
            perf6Mois: perf6Mois,
            perf1An: perf1An,
            perf3Ans: perf3Ans,
            perf5Ans: perf5Ans,
            perf8Ans: perf8Ans,
            perf10Ans: perf10Ans,
            perf12Ans: perf12Ans,
            perf15Ans: perf15Ans,
            perf20Ans: perf20Ans,
            perfOrigine: perfOrigine,
            perfFindeMois1An: perfFindeMois1An,
            perfFindeMois3Ans: perfFindeMois3Ans,
            perfFindeMois5Ans: perfFindeMois5Ans,
            perfFindeMois8Ans: perfFindeMois8Ans,
            perfFindeMois10Ans: perfFindeMois10Ans,
            perfFindeMois12Ans: perfFindeMois12Ans,
            perfFindeMois15Ans: perfFindeMois15Ans,
            perfFindeMois20Ans: perfFindeMois20Ans,
            perfFindeMoisOrigine: perfFindeMoisOrigine,
            perfFindeMoisAnnualized1An: perfFindeMoisAnnualized1An,
            perfFindeMoisAnnualized3An: perfFindeMoisAnnualized3Ans,
            perfFindeMoisAnnualized5Ans: perfFindeMoisAnnualized5Ans,
            perfFindeMoisAnnualized8Ans: perfFindeMoisAnnualized8Ans,
            perfFindeMoisAnnualized10Ans: perfFindeMoisAnnualized10Ans,
            perfFindeMoisAnnualized12Ans: perfFindeMoisAnnualized12Ans,
            perfFindeMoisAnnualized15Ans: perfFindeMoisAnnualized15Ans,
            perfFindeMoisAnnualized20Ans: perfFindeMoisAnnualized20Ans,
            perfFindeMoisAnnualizedOrigine: perfFindeMoisAnnualizedOrigine,
            perfCumuleeFindeMois1An: perfCumuleeFindeMois1An,
            perfCumuleeFindeMois3Ans: perfCumuleeFindeMois3Ans,
            perfCumuleeFindeMois5Ans: perfCumuleeFindeMois5Ans,
            perfCumuleeFindeMois8Ans: perfCumuleeFindeMois8Ans,
            perfCumuleeFindeMois10Ans: perfCumuleeFindeMois10Ans,
            perfCumuleeFindeMois12Ans: perfCumuleeFindeMois12Ans,
            perfCumuleeFindeMois15Ans: perfCumuleeFindeMois15Ans,
            perfCumuleeFindeMois20Ans: perfCumuleeFindeMois20Ans,
            perfCumuleeFindeMoisOrigine: perfCumuleeFindeMoisOrigine,
            perfAnnualizedtodate1An: perfAnnualizedtodate1An,
            perfAnnualizedtodate3Ans: perfAnnualizedtodate3Ans,
            perfAnnualizedtodate5Ans: perfAnnualizedtodate5Ans,
            perfAnnualizedtodate8Ans: perfAnnualizedtodate8Ans,
            perfAnnualizedtodate10Ans: perfAnnualizedtodate10Ans,
            perfAnnualizedtodate12Ans: perfAnnualizedtodate12Ans,
            perfAnnualizedtodate15Ans: perfAnnualizedtodate15Ans,
            perfAnnualizedtodate20Ans: perfAnnualizedtodate20Ans,
            perfAnnualizedtodateOrigine: perfAnnualizedtodateOrigine,
            adaptValues1: multipliedValues,
            //  performancesCategorie: performancesCategorie
          }
        })

      })
  })
  /////revoir
  app.get('/api/performanceswithdate/fond/:id/:date', async (req, res) => {
    try {
      const fondResult = await fond.findOne({
        attributes: ['categorie_libelle', 'categorie_national'],
        where: { id: req.params.id },
      });

      if (!fondResult) {
        return res.status(404).json({ code: 404, message: 'Fond non trouvé' });
      }

      const categorie = fondResult.categorie_libelle;
      const categorie_national = fondResult.categorie_national;
      //   const performancesCategorie = await getPerformancesByCategory(categorie_national);

      const response = await vl.findAll({
        where: {
          fund_id: req.params.id,
          date: { [Op.lte]: req.params.date },
        },
        order: [['date', 'ASC']],
      });

      if (!response.length) {
        return res.status(404).json({ code: 404, message: 'Données de valeur liquidative non trouvées' });
      }

      const values = response.map(data => data.value);
      const actif_nets = response.map(data => data.actif_net);
      const lastValue = values[values.length - 1];
      const lastValueactif_net = actif_nets[actif_nets.length - 1];
      const dates = response.map(data => moment(data.date).format('YYYY-MM-DD'));
      const lastDate = dates[dates.length - 1];
      const targetYear = groupDatesByYear(dates).length;

      const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);

      // Calcul des performances glissantes
      const perfVeille = calculatePerformance(lastValue, values[values.length - 2]);
      const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
      const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
      const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
      const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
      const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
      const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
      const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
      const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
      const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
      const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
      const perf15Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]);
      const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
      const perfOrigine = calculatePerformance(lastValue, values[0]);


      //Calcul performances glissante fin du mois
      const perfVeillem = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[values.length - 2]);
      const perf4Semainesm = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(findNearestDateWeek(dates))]);
      const perf1erJanvierm = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(findNearestDateJanuary(dates))]);
      const perf3Moism = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
      const perf6Moism = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
      const perf1Anm = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(findNearestDatemois(dates, 1))]);
      const perf3Ansm = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(findNearestDatemois(dates, 3))]);
      const perf5Ansm = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(findNearestDatemois(dates, 5))]);
      const perf8Ansm = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(findNearestDatemois(dates, 8))]);
      const perf10Ansm = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(findNearestDatemois(dates, 10))]);


      const perf3Moisactif_net = calculatePerformance(lastValueactif_net, actif_nets[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);

      const performancesFinDeMois = calculateMonthlyPerformances(dates, values, lastdatepreviousmonth, targetYear);

      // Performances annualisées à date
      const perfAnnualizedToDate = calculateAnnualizedToDate(dates, values, lastValue, targetYear);

      // Performances annuelles par année calendaire
      const ArrayDates = groupDatesByYear(dates);
      const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
      const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates).map(item => [item[0], item[1], item[2] * 100]);

      res.json({
        code: 200,
        data: {
          fund_id: req.params.id,
          lastdatepreviousmonth,
          category: categorie,
          perf3Moisactif_net,
          perfVeille,
          perfVeillem,
          perf4Semaines,
          perf4Semainesm,
          perf1erJanvier,
          perf1erJanvierm,
          perf3Mois,
          perf3Moism,
          perf6Mois,
          perf6Moism,
          perf1An,
          perf1Anm,
          perf3Ans,
          perf3Ansm,
          perf5Ans,
          perf5Ansm,
          perf8Ans,
          perf8Ansm,
          perf10Ans,
          perf10Ansm,
          perf12Ans,
          perf15Ans,
          perf20Ans,
          perfOrigine,
          ...performancesFinDeMois,
          ...perfAnnualizedToDate,
          adaptValues1,
          //  performancesCategorie,
        },
      });
    } catch (error) {
      console.error('Erreur lors du traitement des performances:', error);
      res.status(500).json({ code: 500, message: 'Erreur interne du serveur' });
    }
  });
  function calculateMonthlyPerformances(dates, values, lastdatepreviousmonth, targetYear) {
    const periods = [1, 3, 5, 8, 10, 12, 15, 20];
    const performances = {};

    periods.forEach(period => {
      const targetDate = findNearestDateAnnualized(dates, period, lastdatepreviousmonth);
      const key = `perfFindeMois${period}Ans`;
      const annualizedKey = `perfFindeMoisAnnualized${period}Ans`;
      const cumulativeKey = `perfCumuleeFindeMois${period}Ans`;

      performances[key] = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(targetDate)]);
      performances[annualizedKey] = calculateAnnualizedPerformanceper100(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(targetDate)], period);
      performances[cumulativeKey] = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(targetDate)]);
    });

    const targetDateOrigine = groupDatesByMonth(dates)[0];
    performances.perfFindeMoisOrigine = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])]);
    performances.perfFindeMoisAnnualizedOrigine = calculateAnnualizedPerformanceper100(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);
    performances.perfCumuleeFindeMoisOrigine = calculatePerformance(values[dates.indexOf(lastdatepreviousmonth)], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])]);

    return performances;
  }

  function calculateAnnualizedToDate(dates, values, lastValue, targetYear) {
    const periods = [1, 3, 5, 8, 10, 12, 15, 20];
    const annualizedToDate = {};

    periods.forEach(period => {
      const key = `perfAnnualizedtodate${period}Ans`;
      annualizedToDate[key] = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, period))], period);
    });

    annualizedToDate.perfAnnualizedtodateOrigine = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);

    return annualizedToDate;
  }
  ///////
  //////////////////////////////////
  app.get('/api/performanceswithdate1/fond/:id/:date', async (req, res) => {
    const resultat = await fond.findOne({
      attributes: ['categorie_libelle', 'categorie_national'],
      where: {
        id: req.params.id,
      },
    });
    const categorie = resultat.categorie_libelle;
    const categorie_national = resultat.categorie_national;

    const performancesCategorie = await getPerformancesByCategory(categorie_national);

    const date = new Date(req.params.date); // Convertir la chaîne de date en objet Date

    vl.findAll({
      where: {
        fund_id: req.params.id,
        date: { [Op.lte]: req.params.date } // Filtrer les valeurs inférieures ou égales à la date fournie
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        const values = response.map((data) => data.value);
        const actif_nets = response.map((data) => data.actif_net);
        const lastValueactif_net = actif_nets[actif_nets.length - 1];

        const lastValue = values[values.length - 1];
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const lastDate = dates[dates.length - 1]

        const targetYear = groupDatesByYear(dates).length

        const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);
        const perf3Moisactif_net = calculatePerformance(lastValueactif_net, actif_nets[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);

        // Calcul des performances glissantes
        const previousValue = values[values.length - 2];
        const perfVeille = calculatePerformance(lastValue, previousValue);
        const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
        const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
        const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
        const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
        const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
        const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
        const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
        const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
        const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
        const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
        const perf15Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]);
        const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
        const perfOrigine = calculatePerformance(lastValue, values[0]);

        //Performances fin de mois
        const targetDate1An = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
        console.log(values[dates.indexOf(targetDate1An)])

        const targetDate3Ans = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
        const targetDate5Ans = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
        const targetDate8Ans = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
        const targetDate10Ans = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
        const targetDate12Ans = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
        const targetDate15Ans = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
        const targetDate20Ans = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
        const targetDateOrigine = groupDatesByMonth(dates)[0]
        const perfFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])



        //Performances annualizées fin de mois
        const perfFindeMoisAnnualized1An = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
        const perfFindeMoisAnnualized3Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
        const perfFindeMoisAnnualized5Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
        const perfFindeMoisAnnualized8Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
        const perfFindeMoisAnnualized10Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
        const perfFindeMoisAnnualized12Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
        const perfFindeMoisAnnualized15Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates)))], 15);
        const perfFindeMoisAnnualized20Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates)))], 20);
        const perfFindeMoisAnnualizedOrigine = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);


        //Performances cumulées fin de mois
        const perfCumuleeFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfCumuleeFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfCumuleeFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfCumuleeFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfCumuleeFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfCumuleeFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfCumuleeFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfCumuleeFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfCumuleeFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        //Performances annualizées à date
        const perfAnnualizedtodate1An = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1);
        const perfAnnualizedtodate3Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3);
        const perfAnnualizedtodate5Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5);
        const perfAnnualizedtodate8Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8);
        const perfAnnualizedtodate10Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10);
        const perfAnnualizedtodate12Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12);
        const perfAnnualizedtodate15Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15);
        const perfAnnualizedtodate20Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20);
        const perfAnnualizedtodateOrigine = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);
        //Performances  annee calendaire
        const ArrayDates = groupDatesByYear(dates);
        const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
        const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
        const multipliedValues = adaptValues1.map(item => {
          const year = item[0];
          const value1 = item[1];
          const value3 = item[2] * 100; // Multipliez la troisième position par 100

          return [year, value1, value3];
        });


        console.log(multipliedValues);
        res.json({
          code: 200,
          data: {
            fund_id: req.params.id,
            lastdatepreviousmonth: lastdatepreviousmonth,
            category: categorie,
            perf3Moisactif_net: perf3Moisactif_net,
            perfVeille: perfVeille,
            perf4Semaines: perf4Semaines,
            perf1erJanvier: perf1erJanvier,
            perf3Mois: perf3Mois,
            perf6Mois: perf6Mois,
            perf1An: perf1An,
            perf3Ans: perf3Ans,
            perf5Ans: perf5Ans,
            perf8Ans: perf8Ans,
            perf10Ans: perf10Ans,
            perf12Ans: perf12Ans,
            perf15Ans: perf15Ans,
            perf20Ans: perf20Ans,
            perfOrigine: perfOrigine,
            perfFindeMois1An: perfFindeMois1An,
            perfFindeMois3Ans: perfFindeMois3Ans,
            perfFindeMois5Ans: perfFindeMois5Ans,
            perfFindeMois8Ans: perfFindeMois8Ans,
            perfFindeMois10Ans: perfFindeMois10Ans,
            perfFindeMois12Ans: perfFindeMois12Ans,
            perfFindeMois15Ans: perfFindeMois15Ans,
            perfFindeMois20Ans: perfFindeMois20Ans,
            perfFindeMoisOrigine: perfFindeMoisOrigine,
            perfFindeMoisAnnualized1An: perfFindeMoisAnnualized1An,
            perfFindeMoisAnnualized3An: perfFindeMoisAnnualized3Ans,
            perfFindeMoisAnnualized5Ans: perfFindeMoisAnnualized5Ans,
            perfFindeMoisAnnualized8Ans: perfFindeMoisAnnualized8Ans,
            perfFindeMoisAnnualized10Ans: perfFindeMoisAnnualized10Ans,
            perfFindeMoisAnnualized12Ans: perfFindeMoisAnnualized12Ans,
            perfFindeMoisAnnualized15Ans: perfFindeMoisAnnualized15Ans,
            perfFindeMoisAnnualized20Ans: perfFindeMoisAnnualized20Ans,
            perfFindeMoisAnnualizedOrigine: perfFindeMoisAnnualizedOrigine,
            perfCumuleeFindeMois1An: perfCumuleeFindeMois1An,
            perfCumuleeFindeMois3Ans: perfCumuleeFindeMois3Ans,
            perfCumuleeFindeMois5Ans: perfCumuleeFindeMois5Ans,
            perfCumuleeFindeMois8Ans: perfCumuleeFindeMois8Ans,
            perfCumuleeFindeMois10Ans: perfCumuleeFindeMois10Ans,
            perfCumuleeFindeMois12Ans: perfCumuleeFindeMois12Ans,
            perfCumuleeFindeMois15Ans: perfCumuleeFindeMois15Ans,
            perfCumuleeFindeMois20Ans: perfCumuleeFindeMois20Ans,
            perfCumuleeFindeMoisOrigine: perfCumuleeFindeMoisOrigine,
            perfAnnualizedtodate1An: perfAnnualizedtodate1An,
            perfAnnualizedtodate3Ans: perfAnnualizedtodate3Ans,
            perfAnnualizedtodate5Ans: perfAnnualizedtodate5Ans,
            perfAnnualizedtodate8Ans: perfAnnualizedtodate8Ans,
            perfAnnualizedtodate10Ans: perfAnnualizedtodate10Ans,
            perfAnnualizedtodate12Ans: perfAnnualizedtodate12Ans,
            perfAnnualizedtodate15Ans: perfAnnualizedtodate15Ans,
            perfAnnualizedtodate20Ans: perfAnnualizedtodate20Ans,
            perfAnnualizedtodateOrigine: perfAnnualizedtodateOrigine,
            adaptValues1: multipliedValues,
            performancesCategorie: performancesCategorie
          }
        })

      })
  })
  //////////////////////////////////
  app.get('/api/performancesindice/fond/:id', async (req, res) => {
    const selectedValues = req.query.query;
    const resultat = await fond.findOne({
      attributes: ['categorie_libelle', 'categorie_national'],
      where: {
        id: req.params.id,
      },
    });
    const categorie = resultat.categorie_libelle;
    const categorie_national = resultat.categorie_national;

    // const performancesCategorie = await getPerformancesByCategory(categorie_national);

    vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        const values = response.map(data => {
          switch (selectedValues) {
            case 'USD':
              return data.indRef_USD; // Assurez-vous d'avoir les valeurs en USD dans votre base de données
            case 'EUR':
              return data.indRef_EUR; // Assurez-vous d'avoir les valeurs en USD dans votre base de données
            default:
              return data.indRef;
          }
        });
        const actif_nets = response.map(data => {
          switch (selectedValues) {
            case 'USD':
              return data.actif_net_USD; // Assurez-vous d'avoir les valeurs en USD dans votre base de données
            case 'EUR':
              return data.actif_net_EUR; // Assurez-vous d'avoir les valeurs en USD dans votre base de données
            default:
              return data.actif_net;
          }
        });
        const lastValueactif_net = actif_nets[actif_nets.length - 1];

        const lastValue = values[values.length - 1];
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const lastDate = dates[dates.length - 1]

        const targetYear = groupDatesByYear(dates).length

        const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);
        const perf3Moisactif_net = calculatePerformance(lastValueactif_net, actif_nets[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);

        // Calcul des performances glissantes
        const previousValue = values[values.length - 2];
        const perfVeille = calculatePerformance(lastValue, previousValue);
        const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
        const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
        const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
        const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
        const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
        const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
        const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
        const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
        const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
        const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
        const perf15Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]);
        const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
        const perfOrigine = calculatePerformance(lastValue, values[0]);

        //Performances fin de mois
        const targetDate1An = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
        console.log(values[dates.indexOf(targetDate1An)])

        const targetDate3Ans = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
        const targetDate5Ans = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
        const targetDate8Ans = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
        const targetDate10Ans = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
        const targetDate12Ans = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
        const targetDate15Ans = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
        const targetDate20Ans = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
        const targetDateOrigine = groupDatesByMonth(dates)[0]
        const perfFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])



        //Performances annualizées fin de mois
        const perfFindeMoisAnnualized1An = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
        const perfFindeMoisAnnualized3Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
        const perfFindeMoisAnnualized5Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
        const perfFindeMoisAnnualized8Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
        const perfFindeMoisAnnualized10Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
        const perfFindeMoisAnnualized12Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
        const perfFindeMoisAnnualized15Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates)))], 15);
        const perfFindeMoisAnnualized20Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates)))], 20);
        const perfFindeMoisAnnualizedOrigine = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);


        //Performances cumulées fin de mois
        const perfCumuleeFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfCumuleeFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfCumuleeFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfCumuleeFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfCumuleeFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfCumuleeFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfCumuleeFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfCumuleeFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfCumuleeFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        //Performances annualizées à date
        const perfAnnualizedtodate1An = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1);
        const perfAnnualizedtodate3Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3);
        const perfAnnualizedtodate5Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5);
        const perfAnnualizedtodate8Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8);
        const perfAnnualizedtodate10Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10);
        const perfAnnualizedtodate12Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12);
        const perfAnnualizedtodate15Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15);
        const perfAnnualizedtodate20Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20);
        const perfAnnualizedtodateOrigine = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);
        //Performances  annee calendaire
        const ArrayDates = groupDatesByYear(dates);
        const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
        const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
        const multipliedValues = adaptValues1.map(item => {
          const year = item[0];
          const value1 = item[1];
          const value3 = item[2] * 100; // Multipliez la troisième position par 100

          return [year, value1, value3];
        });


        console.log(multipliedValues);
        res.json({
          code: 200,
          data: {
            fund_id: req.params.id,
            lastdatepreviousmonth: lastdatepreviousmonth,
            category: categorie,
            perf3Moisactif_net: perf3Moisactif_net,
            perfVeille: perfVeille,
            perf4Semaines: perf4Semaines,
            perf1erJanvier: perf1erJanvier,
            perf3Mois: perf3Mois,
            perf6Mois: perf6Mois,
            perf1An: perf1An,
            perf3Ans: perf3Ans,
            perf5Ans: perf5Ans,
            perf8Ans: perf8Ans,
            perf10Ans: perf10Ans,
            perf12Ans: perf12Ans,
            perf15Ans: perf15Ans,
            perf20Ans: perf20Ans,
            perfOrigine: perfOrigine,
            perfFindeMois1An: perfFindeMois1An,
            perfFindeMois3Ans: perfFindeMois3Ans,
            perfFindeMois5Ans: perfFindeMois5Ans,
            perfFindeMois8Ans: perfFindeMois8Ans,
            perfFindeMois10Ans: perfFindeMois10Ans,
            perfFindeMois12Ans: perfFindeMois12Ans,
            perfFindeMois15Ans: perfFindeMois15Ans,
            perfFindeMois20Ans: perfFindeMois20Ans,
            perfFindeMoisOrigine: perfFindeMoisOrigine,
            perfFindeMoisAnnualized1An: perfFindeMoisAnnualized1An,
            perfFindeMoisAnnualized3An: perfFindeMoisAnnualized3Ans,
            perfFindeMoisAnnualized5Ans: perfFindeMoisAnnualized5Ans,
            perfFindeMoisAnnualized8Ans: perfFindeMoisAnnualized8Ans,
            perfFindeMoisAnnualized10Ans: perfFindeMoisAnnualized10Ans,
            perfFindeMoisAnnualized12Ans: perfFindeMoisAnnualized12Ans,
            perfFindeMoisAnnualized15Ans: perfFindeMoisAnnualized15Ans,
            perfFindeMoisAnnualized20Ans: perfFindeMoisAnnualized20Ans,
            perfFindeMoisAnnualizedOrigine: perfFindeMoisAnnualizedOrigine,
            perfCumuleeFindeMois1An: perfCumuleeFindeMois1An,
            perfCumuleeFindeMois3Ans: perfCumuleeFindeMois3Ans,
            perfCumuleeFindeMois5Ans: perfCumuleeFindeMois5Ans,
            perfCumuleeFindeMois8Ans: perfCumuleeFindeMois8Ans,
            perfCumuleeFindeMois10Ans: perfCumuleeFindeMois10Ans,
            perfCumuleeFindeMois12Ans: perfCumuleeFindeMois12Ans,
            perfCumuleeFindeMois15Ans: perfCumuleeFindeMois15Ans,
            perfCumuleeFindeMois20Ans: perfCumuleeFindeMois20Ans,
            perfCumuleeFindeMoisOrigine: perfCumuleeFindeMoisOrigine,
            perfAnnualizedtodate1An: perfAnnualizedtodate1An,
            perfAnnualizedtodate3Ans: perfAnnualizedtodate3Ans,
            perfAnnualizedtodate5Ans: perfAnnualizedtodate5Ans,
            perfAnnualizedtodate8Ans: perfAnnualizedtodate8Ans,
            perfAnnualizedtodate10Ans: perfAnnualizedtodate10Ans,
            perfAnnualizedtodate12Ans: perfAnnualizedtodate12Ans,
            perfAnnualizedtodate15Ans: perfAnnualizedtodate15Ans,
            perfAnnualizedtodate20Ans: perfAnnualizedtodate20Ans,
            perfAnnualizedtodateOrigine: perfAnnualizedtodateOrigine,
            adaptValues1: multipliedValues,
            //    performancesCategorie: performancesCategorie
          }
        })

      })
  })

  app.get('/api/performancescategorie/fond/:id', async (req, res) => {
    const resultat = await fond.findOne({
      attributes: ['categorie_libelle', 'categorie_national'],
      where: {
        id: req.params.id,
      },
    });
    const categorie = resultat.categorie_libelle;
    const categorie_national = resultat.categorie_national;
    // Recherche des fonds ayant la même catégorie nationale
    const fondsMemeCategorie = await fond.findAll({
      attributes: ['id'],
      where: { categorie_national: categorie_national },
    });
    const fondIds = fondsMemeCategorie.map(f => f.id);


    const selectedValues = req.query.query; // Récupérer la devise à partir des paramètres de la requête

    let valueColumn;
    if (selectedValues === 'EUR') {
      valueColumn = 'value_EUR';
    } else if (selectedValues === 'USD') {
      valueColumn = 'value_USD';
    } else {
      valueColumn = 'value'; // Valeur par défaut
    }

    // Requête pour récupérer les valorisations avec la colonne de valeur appropriée
    const valorisationss = await vl.findAll({
      attributes: [
        'fund_id',
        [Sequelize.fn('MAX', Sequelize.col('date')), 'latest_date'],
        [Sequelize.col(valueColumn), 'value'],
        [Sequelize.fn('YEAR', Sequelize.col('date')), 'year']
      ],
      where: {
        fund_id: fondIds,
      },
      group: ['fund_id', 'year'],
      order: [
        ['fund_id', 'ASC'],
        ['year', 'DESC'],
        ['latest_date', 'DESC']
      ],
    });
    // Transform the result to calculate performance
    let fundPerformances = {};
    valorisationss.forEach(val => {
      const { fund_id, year, value, latest_date } = val.dataValues;
      if (!fundPerformances[fund_id]) {
        fundPerformances[fund_id] = {};
      }
      fundPerformances[fund_id][year] = { value, date: latest_date };
    });

    let annualPerformances = {};
    for (let fund_id in fundPerformances) {
      let years = Object.keys(fundPerformances[fund_id]).sort((a, b) => b - a);
      for (let i = 0; i < years.length - 1; i++) {
        let currentYear = years[i];
        let previousYear = years[i + 1];
        let currentValue = fundPerformances[fund_id][currentYear].value;
        let previousValue = fundPerformances[fund_id][previousYear].value;
        let performance = (currentValue - previousValue) / previousValue;
        if (previousValue == 0) {
          performance = 0

        }
        if (!annualPerformances[currentYear]) {
          annualPerformances[currentYear] = [];
        }
        annualPerformances[currentYear].push(performance);
      }
    }

    let multipliedValues = [];
    for (let year in annualPerformances) {
      let averagePerformance = annualPerformances[year].reduce((a, b) => a + b, 0) / annualPerformances[year].length;
      multipliedValues.push([parseInt(year), averagePerformance * 100]);
    }


    multipliedValues.reverse();
    res.json({
      code: 200,
      data: {
        multipliedValues
      }
    });

  })
  app.get('/api/performancesdevcategorie/fond/:id/:devise', async (req, res) => {
    const resultat = await fond.findOne({
      attributes: ['categorie_libelle', 'categorie_national'],
      where: {
        id: req.params.id,
      },
    });
    const categorie = resultat.categorie_libelle;
    const categorie_national = resultat.categorie_national;
    // Recherche des fonds ayant la même catégorie nationale
    const fondsMemeCategorie = await fond.findAll({
      attributes: ['id'],
      where: { categorie_national: categorie_national },
    });
    let valorisationss;
    if (req.params.devise == "USD") {
      valorisationss = await vl.findAll({
        attributes: [
          [Sequelize.fn('AVG', Sequelize.col('value_USD')), 'moyenne_vl'],
          'date'
        ],
        where: { fund_id: fondsMemeCategorie.map(fond => fond.id) },
        group: ['date']
      });
    } else {
      valorisationss = await vl.findAll({
        attributes: [
          [Sequelize.fn('AVG', Sequelize.col('value_EUR')), 'moyenne_vl'],
          'date'
        ],
        where: { fund_id: fondsMemeCategorie.map(fond => fond.id) },
        group: ['date']
      });
    }

    const values = valorisationss.map((data) => data.dataValues.moyenne_vl);
    const dates = valorisationss.map((data) => moment(data.dataValues.date).format('YYYY-MM-DD'));
    //Performances  annee calendaire
    const ArrayDates = groupDatesByYear(dates);
    const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
    const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
    const multipliedValues = adaptValues1.map(item => {
      const year = item[0];
      const value1 = item[1];
      const value3 = item[2] * 100; // Multipliez la troisième position par 100

      return [year, value1, value3];
    });
    res.json({
      code: 200,
      data: {
        multipliedValues
      }
    });

  })
  app.get('/api/performancesdev/fond/:id/:devise', async (req, res) => {
    const dateee = req.query.date;

    const resultat = await fond.findOne({
      attributes: ['categorie_libelle', 'categorie_national'],
      where: {
        id: req.params.id,
      },
    });
    const categorie = resultat.categorie_libelle;
    const categorie_national = resultat.categorie_national;

    if (dateee) {
      performancesCategorie = await getPerformancesByCategorynow(categorie_national, dateee);
    }
    vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        let values;
        let actif_nets;
        if (req.params.devise == "USD") {
          values = response.map((data) => data.value_USD);
          actif_nets = response.map((data) => data.actif_net_USD);

        } else {
          values = response.map((data) => data.value_EUR);
          actif_nets = response.map((data) => data.actif_net_USD);


        }

        // const values = response.map((data) => data.value);
        const lastValue = values[values.length - 1];
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const lastDate = dates[dates.length - 1]
        const lastValueactif_net = actif_nets[actif_nets.length - 1];

        const targetYear = groupDatesByYear(dates).length
        const perf3Moisactif_net = calculatePerformance(lastValueactif_net, actif_nets[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);

        const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);

        // Calcul des performances glissantes
        const previousValue = values[values.length - 2];
        const perfVeille = calculatePerformance(lastValue, previousValue);
        const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
        const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
        const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
        const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
        const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
        const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
        const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
        const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
        const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
        const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
        const perf15Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]);
        const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
        const perfOrigine = calculatePerformance(lastValue, values[0]);

        //Performances fin de mois
        const targetDate1An = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
        console.log(values[dates.indexOf(targetDate1An)])

        const targetDate3Ans = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
        const targetDate5Ans = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
        const targetDate8Ans = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
        const targetDate10Ans = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
        const targetDate12Ans = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
        const targetDate15Ans = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
        const targetDate20Ans = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
        const targetDateOrigine = groupDatesByMonth(dates)[0]
        const perfFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])



        //Performances annualizées fin de mois
        const perfFindeMoisAnnualized1An = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
        const perfFindeMoisAnnualized3Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
        const perfFindeMoisAnnualized5Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
        const perfFindeMoisAnnualized8Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
        const perfFindeMoisAnnualized10Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
        const perfFindeMoisAnnualized12Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
        const perfFindeMoisAnnualized15Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates)))], 15);
        const perfFindeMoisAnnualized20Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates)))], 20);
        const perfFindeMoisAnnualizedOrigine = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);


        //Performances cumulées fin de mois
        const perfCumuleeFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfCumuleeFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfCumuleeFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfCumuleeFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfCumuleeFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfCumuleeFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfCumuleeFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfCumuleeFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfCumuleeFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        //Performances annualizées à date
        const perfAnnualizedtodate1An = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1);
        const perfAnnualizedtodate3Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3);
        const perfAnnualizedtodate5Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5);
        const perfAnnualizedtodate8Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8);
        const perfAnnualizedtodate10Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10);
        const perfAnnualizedtodate12Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12);
        const perfAnnualizedtodate15Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15);
        const perfAnnualizedtodate20Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20);
        const perfAnnualizedtodateOrigine = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);
        //Performances  annee calendaire
        const ArrayDates = groupDatesByYear(dates);
        const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
        const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
        const multipliedValues = adaptValues1.map(item => {
          const year = item[0];
          const value1 = item[1];
          const value3 = item[2] * 100; // Multipliez la troisième position par 100

          return [year, value1, value3];
        });


        console.log(multipliedValues);
        res.json({
          code: 200,
          data: {
            fund_id: req.params.id,
            lastdatepreviousmonth: lastdatepreviousmonth,
            perf3Moisactif_net: perf3Moisactif_net,
            category: categorie,
            perfVeille: perfVeille,
            perf4Semaines: perf4Semaines,
            perf1erJanvier: perf1erJanvier,
            perf3Mois: perf3Mois,
            perf6Mois: perf6Mois,
            perf1An: perf1An,
            perf3Ans: perf3Ans,
            perf5Ans: perf5Ans,
            perf8Ans: perf8Ans,
            perf10Ans: perf10Ans,
            perf12Ans: perf12Ans,
            perf15Ans: perf15Ans,
            perf20Ans: perf20Ans,
            perfOrigine: perfOrigine,
            perfFindeMois1An: perfFindeMois1An,
            perfFindeMois3Ans: perfFindeMois3Ans,
            perfFindeMois5Ans: perfFindeMois5Ans,
            perfFindeMois8Ans: perfFindeMois8Ans,
            perfFindeMois10Ans: perfFindeMois10Ans,
            perfFindeMois12Ans: perfFindeMois12Ans,
            perfFindeMois15Ans: perfFindeMois15Ans,
            perfFindeMois20Ans: perfFindeMois20Ans,
            perfFindeMoisOrigine: perfFindeMoisOrigine,
            perfFindeMoisAnnualized1An: perfFindeMoisAnnualized1An,
            perfFindeMoisAnnualized3An: perfFindeMoisAnnualized3Ans,
            perfFindeMoisAnnualized5Ans: perfFindeMoisAnnualized5Ans,
            perfFindeMoisAnnualized8Ans: perfFindeMoisAnnualized8Ans,
            perfFindeMoisAnnualized10Ans: perfFindeMoisAnnualized10Ans,
            perfFindeMoisAnnualized12Ans: perfFindeMoisAnnualized12Ans,
            perfFindeMoisAnnualized15Ans: perfFindeMoisAnnualized15Ans,
            perfFindeMoisAnnualized20Ans: perfFindeMoisAnnualized20Ans,
            perfFindeMoisAnnualizedOrigine: perfFindeMoisAnnualizedOrigine,
            perfCumuleeFindeMois1An: perfCumuleeFindeMois1An,
            perfCumuleeFindeMois3Ans: perfCumuleeFindeMois3Ans,
            perfCumuleeFindeMois5Ans: perfCumuleeFindeMois5Ans,
            perfCumuleeFindeMois8Ans: perfCumuleeFindeMois8Ans,
            perfCumuleeFindeMois10Ans: perfCumuleeFindeMois10Ans,
            perfCumuleeFindeMois12Ans: perfCumuleeFindeMois12Ans,
            perfCumuleeFindeMois15Ans: perfCumuleeFindeMois15Ans,
            perfCumuleeFindeMois20Ans: perfCumuleeFindeMois20Ans,
            perfCumuleeFindeMoisOrigine: perfCumuleeFindeMoisOrigine,
            perfAnnualizedtodate1An: perfAnnualizedtodate1An,
            perfAnnualizedtodate3Ans: perfAnnualizedtodate3Ans,
            perfAnnualizedtodate5Ans: perfAnnualizedtodate5Ans,
            perfAnnualizedtodate8Ans: perfAnnualizedtodate8Ans,
            perfAnnualizedtodate10Ans: perfAnnualizedtodate10Ans,
            perfAnnualizedtodate12Ans: perfAnnualizedtodate12Ans,
            perfAnnualizedtodate15Ans: perfAnnualizedtodate15Ans,
            perfAnnualizedtodate20Ans: perfAnnualizedtodate20Ans,
            perfAnnualizedtodateOrigine: perfAnnualizedtodateOrigine,
            adaptValues1: multipliedValues,
            performancesCategorie: dateee ? performancesCategorie : null
          }
        })

      })
  })
  app.get('/api/performancesdevwithdate/fond/:id/:devise/:date', async (req, res) => {

    const resultat = await fond.findOne({
      attributes: ['categorie_libelle', 'categorie_national'],
      where: {
        id: req.params.id,
      },
    });
    const categorie = resultat.categorie_libelle;
    const categorie_national = resultat.categorie_national;

    //const performancesCategorie = await getPerformancesByCategory(categorie_national);

    vl.findAll({
      where: {
        fund_id: req.params.id,
        date: { [Op.lte]: req.params.date } // Filtrer les valeurs inférieures ou égales à la date fournie
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        let values;
        let actif_nets;
        if (req.params.devise == "USD") {
          values = response.map((data) => data.value_USD);
          actif_nets = response.map((data) => data.actif_net_USD);

        } else {
          values = response.map((data) => data.value_EUR);
          actif_nets = response.map((data) => data.actif_net_USD);


        }

        // const values = response.map((data) => data.value);
        const lastValue = values[values.length - 1];
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const lastDate = dates[dates.length - 1]
        const lastValueactif_net = actif_nets[actif_nets.length - 1];

        const targetYear = groupDatesByYear(dates).length
        const perf3Moisactif_net = calculatePerformance(lastValueactif_net, actif_nets[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);

        const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);

        // Calcul des performances glissantes
        const previousValue = values[values.length - 2];
        const perfVeille = calculatePerformance(lastValue, previousValue);
        const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
        const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
        const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
        const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
        const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
        const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
        const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
        const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
        const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
        const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
        const perf15Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]);
        const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
        const perfOrigine = calculatePerformance(lastValue, values[0]);

        //Performances fin de mois
        const targetDate1An = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
        console.log(values[dates.indexOf(targetDate1An)])

        const targetDate3Ans = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
        const targetDate5Ans = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
        const targetDate8Ans = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
        const targetDate10Ans = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
        const targetDate12Ans = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
        const targetDate15Ans = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
        const targetDate20Ans = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
        const targetDateOrigine = groupDatesByMonth(dates)[0]
        const perfFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])



        //Performances annualizées fin de mois
        const perfFindeMoisAnnualized1An = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
        const perfFindeMoisAnnualized3Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
        const perfFindeMoisAnnualized5Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
        const perfFindeMoisAnnualized8Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
        const perfFindeMoisAnnualized10Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
        const perfFindeMoisAnnualized12Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
        const perfFindeMoisAnnualized15Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates)))], 15);
        const perfFindeMoisAnnualized20Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates)))], 20);
        const perfFindeMoisAnnualizedOrigine = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);


        //Performances cumulées fin de mois
        const perfCumuleeFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfCumuleeFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfCumuleeFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfCumuleeFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfCumuleeFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfCumuleeFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfCumuleeFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfCumuleeFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfCumuleeFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        //Performances annualizées à date
        const perfAnnualizedtodate1An = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1);
        const perfAnnualizedtodate3Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3);
        const perfAnnualizedtodate5Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5);
        const perfAnnualizedtodate8Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8);
        const perfAnnualizedtodate10Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10);
        const perfAnnualizedtodate12Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12);
        const perfAnnualizedtodate15Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15);
        const perfAnnualizedtodate20Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20);
        const perfAnnualizedtodateOrigine = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);
        //Performances  annee calendaire
        const ArrayDates = groupDatesByYear(dates);
        const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
        const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
        const multipliedValues = adaptValues1.map(item => {
          const year = item[0];
          const value1 = item[1];
          const value3 = item[2] * 100; // Multipliez la troisième position par 100

          return [year, value1, value3];
        });


        console.log(multipliedValues);
        res.json({
          code: 200,
          data: {
            fund_id: req.params.id,
            lastdatepreviousmonth: lastdatepreviousmonth,
            perf3Moisactif_net: perf3Moisactif_net,
            category: categorie,
            perfVeille: perfVeille,
            perf4Semaines: perf4Semaines,
            perf1erJanvier: perf1erJanvier,
            perf3Mois: perf3Mois,
            perf6Mois: perf6Mois,
            perf1An: perf1An,
            perf3Ans: perf3Ans,
            perf5Ans: perf5Ans,
            perf8Ans: perf8Ans,
            perf10Ans: perf10Ans,
            perf12Ans: perf12Ans,
            perf15Ans: perf15Ans,
            perf20Ans: perf20Ans,
            perfOrigine: perfOrigine,
            perfFindeMois1An: perfFindeMois1An,
            perfFindeMois3Ans: perfFindeMois3Ans,
            perfFindeMois5Ans: perfFindeMois5Ans,
            perfFindeMois8Ans: perfFindeMois8Ans,
            perfFindeMois10Ans: perfFindeMois10Ans,
            perfFindeMois12Ans: perfFindeMois12Ans,
            perfFindeMois15Ans: perfFindeMois15Ans,
            perfFindeMois20Ans: perfFindeMois20Ans,
            perfFindeMoisOrigine: perfFindeMoisOrigine,
            perfFindeMoisAnnualized1An: perfFindeMoisAnnualized1An,
            perfFindeMoisAnnualized3An: perfFindeMoisAnnualized3Ans,
            perfFindeMoisAnnualized5Ans: perfFindeMoisAnnualized5Ans,
            perfFindeMoisAnnualized8Ans: perfFindeMoisAnnualized8Ans,
            perfFindeMoisAnnualized10Ans: perfFindeMoisAnnualized10Ans,
            perfFindeMoisAnnualized12Ans: perfFindeMoisAnnualized12Ans,
            perfFindeMoisAnnualized15Ans: perfFindeMoisAnnualized15Ans,
            perfFindeMoisAnnualized20Ans: perfFindeMoisAnnualized20Ans,
            perfFindeMoisAnnualizedOrigine: perfFindeMoisAnnualizedOrigine,
            perfCumuleeFindeMois1An: perfCumuleeFindeMois1An,
            perfCumuleeFindeMois3Ans: perfCumuleeFindeMois3Ans,
            perfCumuleeFindeMois5Ans: perfCumuleeFindeMois5Ans,
            perfCumuleeFindeMois8Ans: perfCumuleeFindeMois8Ans,
            perfCumuleeFindeMois10Ans: perfCumuleeFindeMois10Ans,
            perfCumuleeFindeMois12Ans: perfCumuleeFindeMois12Ans,
            perfCumuleeFindeMois15Ans: perfCumuleeFindeMois15Ans,
            perfCumuleeFindeMois20Ans: perfCumuleeFindeMois20Ans,
            perfCumuleeFindeMoisOrigine: perfCumuleeFindeMoisOrigine,
            perfAnnualizedtodate1An: perfAnnualizedtodate1An,
            perfAnnualizedtodate3Ans: perfAnnualizedtodate3Ans,
            perfAnnualizedtodate5Ans: perfAnnualizedtodate5Ans,
            perfAnnualizedtodate8Ans: perfAnnualizedtodate8Ans,
            perfAnnualizedtodate10Ans: perfAnnualizedtodate10Ans,
            perfAnnualizedtodate12Ans: perfAnnualizedtodate12Ans,
            perfAnnualizedtodate15Ans: perfAnnualizedtodate15Ans,
            perfAnnualizedtodate20Ans: perfAnnualizedtodate20Ans,
            perfAnnualizedtodateOrigine: perfAnnualizedtodateOrigine,
            adaptValues1: multipliedValues,
            //  performancesCategorie: performancesCategorie
          }
        })

      })
  })
  app.get('/api/performancemonthyear/fond/:id', async (req, res) => {
    vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        const selectedValues = req.query.query;
        let values;
        let monthlyPerformance;
        let annualPerformance;
        let dates;
        if (selectedValues == "EUR") {
          values = response.map((data) => data.value_EUR);

          dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));

          monthlyPerformance = calculatemPerformance(values, dates);
          annualPerformance = calculateAnnualPerformance(values, dates);
        } else if (selectedValues == "USD") {
          values = response.map((data) => data.value_USD);

          dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));

          monthlyPerformance = calculatemPerformance(values, dates);
          annualPerformance = calculateAnnualPerformance(values, dates);
        } else {
          values = response.map((data) => data.value);

          dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));

          monthlyPerformance = calculatemPerformance(values, dates);
          annualPerformance = calculateAnnualPerformance(values, dates);
        }

        res.json({ monthlyPerformance, annualPerformance });

      });
  })

  app.get('/api/performanceindicemonthyear/fond/:id', async (req, res) => {
    vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        const selectedValues = req.query.query;
        let values;
        let monthlyPerformance;
        let annualPerformance;
        let dates;
        if (selectedValues == "EUR") {
          values = response.map((data) => data.indRef_EUR);

          dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));

          monthlyPerformance = calculatemPerformance(values, dates);
          annualPerformance = calculateAnnualPerformance(values, dates);
        } else if (selectedValues == "USD") {
          values = response.map((data) => data.indRef_USD);

          dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));

          monthlyPerformance = calculatemPerformance(values, dates);
          annualPerformance = calculateAnnualPerformance(values, dates);
        } else {
          values = response.map((data) => data.indRef);

          dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));

          monthlyPerformance = calculatemPerformance(values, dates);
          annualPerformance = calculateAnnualPerformance(values, dates);
        }

        res.json({ monthlyPerformance, annualPerformance });

      });
  })

  // Fonction pour calculer les performances mensuelles
  function calculatemPerformance(values, dates) {
    const monthlyPerformances = {};

    for (let i = 0; i < values.length; i++) {
      const month = moment(dates[i]).format('YYYY-MM');
      const value = values[i];

      // Si le mois n'existe pas encore dans les performances mensuelles,
      // ou si la date actuelle est après celle enregistrée pour ce mois,
      // alors mettez à jour la performance mensuelle.
      if (!monthlyPerformances[month] || moment(dates[i]).isAfter(moment(monthlyPerformances[month].date))) {
        monthlyPerformances[month] = { date: dates[i], value: value };
      }
    }

    // Construire un tableau de performances mensuelles
    const monthlyPerformanceValues = Object.values(monthlyPerformances).map(monthly => monthly.value);
    const monthlyPerformanceDates = Object.values(monthlyPerformances).map(monthly => monthly.date);

    const monthlyPerformancesResults = {};

    for (let i = 1; i < monthlyPerformanceValues.length; i++) {
      const performance = calculatePerformance(monthlyPerformanceValues[i], monthlyPerformanceValues[i - 1]);
      const month = moment(monthlyPerformanceDates[i]).format('YYYY-MM');
      monthlyPerformancesResults[month] = performance;
    }

    return monthlyPerformancesResults;
  }
  /*function calculatemPerformance(values, dates) {
    const monthlyPerformances = {};
   
    for (let i = 0; i < values.length; i++) {
      const month = moment(dates[i]).format('YYYY-MM');
      const value = values[i];
   
      // Si le mois n'existe pas encore dans les performances mensuelles,
      // ou si la date actuelle est après celle enregistrée pour ce mois,
      // alors mettez à jour la performance mensuelle.
      if (!monthlyPerformances[month] || moment(dates[i]).isAfter(moment(monthlyPerformances[month].date))) {
        monthlyPerformances[month] = { date: dates[i], value: value };
      }
    }
   
    // Construire un tableau de performances mensuelles
    const monthlyPerformanceValues = Object.values(monthlyPerformances).map(monthly => monthly.value);
    const monthlyPerformanceDates = Object.values(monthlyPerformances).map(monthly => monthly.date);
   
    return { values: monthlyPerformanceValues, dates: monthlyPerformanceDates };
  }
   
  function calculatemPerformance(values, dates) {
    const monthlyPerformances = {};
   
    for (let i = 1; i < values.length; i++) {
      const month = moment(dates[i]).format('YYYY-MM');
      if (!monthlyPerformances[month]) {
        const startValue = values[i - 1];
        const endValue = values[i];
        //    const performance = ((endValue - startValue) / startValue) * 100;
        const performance = calculatePerformance(endValue, startValue)
        monthlyPerformances[month] = performance;
      }
    }
   
    return monthlyPerformances;
  }*/

  // Fonction pour calculer les performances annuelles
  /*function calculateAnnualPerformance(values, dates) {
    const annualPerformances = {};
   
    for (let i = 1; i < values.length; i++) {
      const year = moment(dates[i]).format('YYYY');
      if (!annualPerformances[year]) {
        const startValue = values[i - 1];
        const endValue = values[i];
        //   const performance = ((endValue - startValue) / startValue) * 100;
        const performance = calculatePerformance(endValue, startValue)
        annualPerformances[year] = performance;
      }
    }
   
    return annualPerformances;
  }*/
  function calculateAnnualPerformance(values, dates) {
    const annualPerformances = {};

    for (let i = 0; i < values.length; i++) {
      const year = moment(dates[i]).format('YYYY');
      const value = values[i];

      // Si l'année n'existe pas encore dans les performances annuelles,
      // ou si la date actuelle est après celle enregistrée pour cette année,
      // alors mettez à jour la performance annuelle.
      if (!annualPerformances[year] || moment(dates[i]).isAfter(moment(annualPerformances[year].date))) {
        annualPerformances[year] = { date: dates[i], value: value };
      }
    }

    // Construire un tableau de performances annuelles
    const annualPerformanceValues = Object.values(annualPerformances).map(annual => annual.value);
    const annualPerformanceDates = Object.values(annualPerformances).map(annual => annual.date);

    const annualPerformancesResults = {};

    for (let i = 1; i < annualPerformanceValues.length; i++) {
      const performance = calculatePerformance(annualPerformanceValues[i], annualPerformanceValues[i - 1]);
      const year = moment(annualPerformanceDates[i]).format('YYYY');
      annualPerformancesResults[year] = performance;
    }

    return annualPerformancesResults;
  }



  const getPerformancesByCategory = async (categorie) => {
    /* const performancesCategorie = await sequelize.query(`
       SELECT
         categorie_nationale,
         AVG(CAST(ytd AS DECIMAL(10,2))) AS moyenne_ytd,
         AVG(CAST(perfveille AS DECIMAL(10,2))) AS moyenne_perfveille,
         AVG(CAST(perf1an AS DECIMAL(10,2))) AS moyenne_perf1an,
         AVG(CAST(perf3ans AS DECIMAL(10,2))) AS moyenne_perf3ans,
         AVG(CAST(perf5ans AS DECIMAL(10,2))) AS moyenne_perf5ans,
         AVG(CAST(perf8ans AS DECIMAL(10,2))) AS moyenne_perf8ans,
         AVG(CAST(perf10ans AS DECIMAL(10,2))) AS moyenne_perf10ans,
         AVG(CAST(perf4s AS DECIMAL(10,2))) AS moyenne_perf4s,
         AVG(CAST(perf3m AS DECIMAL(10,2))) AS moyenne_perf3m,
         AVG(CAST(perf6m AS DECIMAL(10,2))) AS moyenne_perf6m,
         AVG(CAST(perfannu1an AS DECIMAL(10,2))) AS moyenne_perfannu1an,
         AVG(CAST(perfannu3an AS DECIMAL(10,2))) AS moyenne_perfannu3an,
         AVG(CAST(perfannu5an AS DECIMAL(10,2))) AS moyenne_perfannu5an,
         AVG(CAST(volatility1an AS DECIMAL(10,2))) AS moyenne_volatility1an,
         AVG(CAST(volatility3an AS DECIMAL(10,2))) AS moyenne_volatility3an,
         AVG(CAST(volatility5an AS DECIMAL(10,2))) AS moyenne_volatility5an,
         AVG(CAST(ratiosharpe3an AS DECIMAL(10,2))) AS moyenne_ratiosharpe3an,
         AVG(CAST(pertemax1an AS DECIMAL(10,2))) AS moyenne_pertemax1an,
         AVG(CAST(pertemax3an AS DECIMAL(10,2))) AS moyenne_pertemax3an,
         AVG(CAST(pertemax5an AS DECIMAL(10,2))) AS moyenne_pertemax5an,
         AVG(CAST(sortino3an AS DECIMAL(10,2))) AS moyenne_sortino3an,
         AVG(CAST(info3an AS DECIMAL(10,2))) AS moyenne_info3an,
         AVG(CAST(calamar3an AS DECIMAL(10,2))) AS moyenne_calamar3an,
         AVG(CAST(var993an AS DECIMAL(10,2))) AS moyenne_var993an,
         AVG(CAST(var953an AS DECIMAL(10,2))) AS moyenne_var953an
       FROM performences
       WHERE 
         categorie_nationale = :categorie
         AND (
         ytd IS NOT NULL AND ytd <> '-' OR
         perfveille IS NOT NULL AND perfveille <> '-' OR
         perf1an IS NOT NULL AND perf1an <> '-' OR
         perf3ans IS NOT NULL AND perf3ans <> '-' OR
         perf5ans IS NOT NULL AND perf5ans <> '-' OR
         perf8ans IS NOT NULL AND perf8ans <> '-' OR
         perf10ans IS NOT NULL AND perf10ans <> '-' OR
         perf4s IS NOT NULL AND perf4s <> '-' OR
         perf3m IS NOT NULL AND perf3m <> '-' OR
         perf6m IS NOT NULL AND perf6m <> '-' OR
         perfannu3an IS NOT NULL AND perfannu3an <> '-' OR
         volatility3an IS NOT NULL AND volatility3an <> '-' OR
         ratiosharpe3an IS NOT NULL AND ratiosharpe3an <> '-' OR
         pertemax3an IS NOT NULL AND pertemax3an <> '-' OR
         sortino3an IS NOT NULL AND sortino3an <> '-' OR
         info3an IS NOT NULL AND info3an <> '-' OR
         calamar3an IS NOT NULL AND calamar3an <> '-' OR
         var993an IS NOT NULL AND var993an <> '-' OR
         var953an IS NOT NULL AND var953an <> '-'
     )
       GROUP BY categorie_nationale
     `, {
       replacements: { categorie: categorie },
       type: sequelize.QueryTypes.SELECT,
     });*/

    const performancesCategorie = await sequelize.query(`

  SELECT
    categorie_nationale,
    AVG(CAST(ytd AS DECIMAL(10,2))) AS moyenne_ytd,
    AVG(CAST(perfveille AS DECIMAL(10,2))) AS moyenne_perfveille,
    AVG(CAST(perf1an AS DECIMAL(10,2))) AS moyenne_perf1an,
    AVG(CAST(perf3ans AS DECIMAL(10,2))) AS moyenne_perf3ans,
    AVG(CAST(perf5ans AS DECIMAL(10,2))) AS moyenne_perf5ans,
    AVG(CAST(perf8ans AS DECIMAL(10,2))) AS moyenne_perf8ans,
    AVG(CAST(perf10ans AS DECIMAL(10,2))) AS moyenne_perf10ans,
    AVG(CAST(perf4s AS DECIMAL(10,2))) AS moyenne_perf4s,
    AVG(CAST(perf3m AS DECIMAL(10,2))) AS moyenne_perf3m,
    AVG(CAST(perf6m AS DECIMAL(10,2))) AS moyenne_perf6m,
    AVG(CAST(perfannu1an AS DECIMAL(10,2))) AS moyenne_perfannu1an,
    AVG(CAST(perfannu3an AS DECIMAL(10,2))) AS moyenne_perfannu3an,
    AVG(CAST(perfannu5an AS DECIMAL(10,2))) AS moyenne_perfannu5an,
    AVG(CAST(volatility1an AS DECIMAL(10,2))) AS moyenne_volatility1an,
    AVG(CAST(volatility3an AS DECIMAL(10,2))) AS moyenne_volatility3an,
    AVG(CAST(volatility5an AS DECIMAL(10,2))) AS moyenne_volatility5an,
    AVG(CAST(ratiosharpe3an AS DECIMAL(10,2))) AS moyenne_ratiosharpe3an,
    AVG(CAST(pertemax1an AS DECIMAL(10,2))) AS moyenne_pertemax1an,
    AVG(CAST(pertemax3an AS DECIMAL(10,2))) AS moyenne_pertemax3an,
    AVG(CAST(pertemax5an AS DECIMAL(10,2))) AS moyenne_pertemax5an,
    AVG(CAST(sortino3an AS DECIMAL(10,2))) AS moyenne_sortino3an,
    AVG(CAST(info3an AS DECIMAL(10,2))) AS moyenne_info3an,
    AVG(CAST(calamar3an AS DECIMAL(10,2))) AS moyenne_calamar3an,
    AVG(CAST(var993an AS DECIMAL(10,2))) AS moyenne_var993an,
    AVG(CAST(var953an AS DECIMAL(10,2))) AS moyenne_var953an
FROM (
    SELECT
        p1.*
    FROM
        performences p1
    INNER JOIN (
        SELECT
            fond_id,
            MAX(date) AS latest_date
        FROM
            performences
        GROUP BY
            fond_id
    ) p2 ON p1.fond_id = p2.fond_id AND p1.date = p2.latest_date
) AS latest_performance
WHERE
    categorie_nationale = :categorie
    AND (
        ytd IS NOT NULL AND ytd <> '-' OR
        perfveille IS NOT NULL AND perfveille <> '-' OR
        perf1an IS NOT NULL AND perf1an <> '-' OR
        perf3ans IS NOT NULL AND perf3ans <> '-' OR
        perf5ans IS NOT NULL AND perf5ans <> '-' OR
        perf8ans IS NOT NULL AND perf8ans <> '-' OR
        perf10ans IS NOT NULL AND perf10ans <> '-' OR
        perf4s IS NOT NULL AND perf4s <> '-' OR
        perf3m IS NOT NULL AND perf3m <> '-' OR
        perf6m IS NOT NULL AND perf6m <> '-' OR
        perfannu1an IS NOT NULL AND perfannu1an <> '-' OR
        perfannu3an IS NOT NULL AND perfannu3an <> '-' OR
        perfannu5an IS NOT NULL AND perfannu5an <> '-' OR
        volatility1an IS NOT NULL AND volatility1an <> '-' OR
        volatility3an IS NOT NULL AND volatility3an <> '-' OR
        volatility5an IS NOT NULL AND volatility5an <> '-' OR
        ratiosharpe3an IS NOT NULL AND ratiosharpe3an <> '-' OR
        pertemax1an IS NOT NULL AND pertemax1an <> '-' OR
        pertemax3an IS NOT NULL AND pertemax3an <> '-' OR
        pertemax5an IS NOT NULL AND pertemax5an <> '-' OR
        sortino3an IS NOT NULL AND sortino3an <> '-' OR
        info3an IS NOT NULL AND info3an <> '-' OR
        calamar3an IS NOT NULL AND calamar3an <> '-' OR
        var993an IS NOT NULL AND var993an <> '-' OR
        var953an IS NOT NULL AND var953an <> '-'
    )
GROUP BY
    categorie_nationale;

    `, {
      replacements: { categorie: categorie },
      type: sequelize.QueryTypes.SELECT,
    });
    return performancesCategorie;
  };

  const getPerformancesByCategorynow = async (categorie, datedebut) => {


    // Convertir datefin au format YYYY-MM-DD
    const performancesCategorie = await sequelize.query(`
 SELECT
    categorie_nationale,
    AVG(CASE WHEN ytd IS NOT NULL AND ytd != '-' THEN CAST(ytd AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_ytd,
    AVG(CASE WHEN perfveille IS NOT NULL AND perfveille != '-' THEN CAST(perfveille AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perfveille,
    AVG(CASE WHEN perf1an IS NOT NULL AND perf1an != '-' THEN CAST(perf1an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perf1an,
    AVG(CASE WHEN perf3ans IS NOT NULL AND perf3ans != '-' THEN CAST(perf3ans AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perf3ans,
    AVG(CASE WHEN perf5ans IS NOT NULL AND perf5ans != '-' THEN CAST(perf5ans AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perf5ans,
    AVG(CASE WHEN perf8ans IS NOT NULL AND perf8ans != '-' THEN CAST(perf8ans AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perf8ans,
    AVG(CASE WHEN perf10ans IS NOT NULL AND perf10ans != '-' THEN CAST(perf10ans AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perf10ans,
    AVG(CASE WHEN perf4s IS NOT NULL AND perf4s != '-' THEN CAST(perf4s AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perf4s,
    AVG(CASE WHEN perf3m IS NOT NULL AND perf3m != '-' THEN CAST(perf3m AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perf3m,
    AVG(CASE WHEN perf6m IS NOT NULL AND perf6m != '-' THEN CAST(perf6m AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perf6m,
    AVG(CASE WHEN perfannu1an IS NOT NULL AND perfannu1an != '-' THEN CAST(perfannu1an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perfannu1an,
    AVG(CASE WHEN perfannu3an IS NOT NULL AND perfannu3an != '-' THEN CAST(perfannu3an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perfannu3an,
    AVG(CASE WHEN perfannu5an IS NOT NULL AND perfannu5an != '-' THEN CAST(perfannu5an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_perfannu5an,
    AVG(CASE WHEN volatility1an IS NOT NULL AND volatility1an != '-' THEN CAST(volatility1an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_volatility1an,
    AVG(CASE WHEN volatility3an IS NOT NULL AND volatility3an != '-' THEN CAST(volatility3an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_volatility3an,
    AVG(CASE WHEN volatility5an IS NOT NULL AND volatility5an != '-' THEN CAST(volatility5an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_volatility5an,
    AVG(CASE WHEN ratiosharpe3an IS NOT NULL AND ratiosharpe3an != '-' THEN CAST(ratiosharpe3an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_ratiosharpe3an,
    AVG(CASE WHEN pertemax1an IS NOT NULL AND pertemax1an != '-' THEN CAST(pertemax1an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_pertemax1an,
    AVG(CASE WHEN pertemax3an IS NOT NULL AND pertemax3an != '-' THEN CAST(pertemax3an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_pertemax3an,
    AVG(CASE WHEN pertemax5an IS NOT NULL AND pertemax5an != '-' THEN CAST(pertemax5an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_pertemax5an,
    AVG(CASE WHEN sortino3an IS NOT NULL AND sortino3an != '-' THEN CAST(sortino3an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_sortino3an,
    AVG(CASE WHEN info3an IS NOT NULL AND info3an != '-' THEN CAST(info3an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_info3an,
    AVG(CASE WHEN calamar3an IS NOT NULL AND calamar3an != '-' THEN CAST(calamar3an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_calamar3an,
    AVG(CASE WHEN var993an IS NOT NULL AND var993an != '-' THEN CAST(var993an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_var993an,
    AVG(CASE WHEN var953an IS NOT NULL AND var953an != '-' THEN CAST(var953an AS DECIMAL(10,2)) ELSE NULL END) AS moyenne_var953an
FROM 
    performences
WHERE
    categorie_nationale = :categorie
    AND date = :datedebut
GROUP BY
    categorie_nationale;

  `, {
      replacements: { categorie: categorie, datedebut: datedebut },
      type: sequelize.QueryTypes.SELECT,
    });
    return performancesCategorie;
  };





  app.get('/api/performancesportefeuille/fond/:id', async (req, res) => {



    portefeuille_vl_cumul.findAll({
      where: {
        portefeuille_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        let lastValuep = response[response.length - 1].base_100_bis; // Dernière valeur


        // Valeurs liquidatives
        const values = response.map((data) => data.base_100_bis);
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));

        //  const values = response.map((data) => data.value);
        const lastValue = lastValuep;
        //  const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const lastDate = dates[dates.length - 1]

        const targetYear = groupDatesByYear(dates).length

        const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);

        // Calcul des performances glissantes
        const previousValue = values[values.length - 2];
        const perfVeille = calculatePerformance(lastValue, previousValue);
        const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
        const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
        const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
        const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
        const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
        const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
        const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
        const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
        const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
        const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
        const perf15Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]);
        const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
        const perfOrigine = calculatePerformance(lastValue, values[0]);

        //Performances fin de mois
        const targetDate1An = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
        const targetDate3Ans = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
        const targetDate5Ans = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
        const targetDate8Ans = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
        const targetDate10Ans = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
        const targetDate12Ans = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
        const targetDate15Ans = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
        const targetDate20Ans = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
        const targetDateOrigine = groupDatesByMonth(dates)[0]
        const perfFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        console.log(findLastDateOfPreviousMonth(dates))
        //Performances annualizées fin de mois
        const perfFindeMoisAnnualized1An = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
        const perfFindeMoisAnnualized3Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
        const perfFindeMoisAnnualized5Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
        const perfFindeMoisAnnualized8Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
        const perfFindeMoisAnnualized10Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
        const perfFindeMoisAnnualized12Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
        const perfFindeMoisAnnualized15Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates)))], 15);
        const perfFindeMoisAnnualized20Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates)))], 20);
        const perfFindeMoisAnnualizedOrigine = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);


        //Performances cumulées fin de mois
        const perfCumuleeFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfCumuleeFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfCumuleeFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfCumuleeFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfCumuleeFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfCumuleeFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfCumuleeFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfCumuleeFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfCumuleeFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        //Performances annualizées à date
        const perfAnnualizedtodate1An = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1);
        const perfAnnualizedtodate3Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3);
        const perfAnnualizedtodate5Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5);
        const perfAnnualizedtodate8Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8);
        const perfAnnualizedtodate10Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10);
        const perfAnnualizedtodate12Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12);
        const perfAnnualizedtodate15Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15);
        const perfAnnualizedtodate20Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20);
        const perfAnnualizedtodateOrigine = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);
        //Performances  annee calendaire
        const ArrayDates = groupDatesByYear(dates);
        const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
        const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
        const multipliedValues = adaptValues1.map(item => {
          const year = item[0];
          const value1 = item[1];
          const value3 = item[2] * 100; // Multipliez la troisième position par 100

          return [year, value1, value3];
        });


        console.log(multipliedValues);
        res.json({
          code: 200,
          data: {
            portefeuille: req.params.id,
            lastdatepreviousmonth: lastdatepreviousmonth,
            //    perf3Moisactif_net: perf3Moisactif_net,
            perfVeille: perfVeille,
            perf4Semaines: perf4Semaines,
            perf1erJanvier: perf1erJanvier,
            perf3Mois: perf3Mois,
            perf6Mois: perf6Mois,
            perf1An: perf1An,
            perf3Ans: perf3Ans,
            perf5Ans: perf5Ans,
            perf8Ans: perf8Ans,
            perf10Ans: perf10Ans,
            perf12Ans: perf12Ans,
            perf15Ans: perf15Ans,
            perf20Ans: perf20Ans,
            perfOrigine: perfOrigine,
            perfFindeMois1An: perfFindeMois1An,
            perfFindeMois3Ans: perfFindeMois3Ans,
            perfFindeMois5Ans: perfFindeMois5Ans,
            perfFindeMois8Ans: perfFindeMois8Ans,
            perfFindeMois10Ans: perfFindeMois10Ans,
            perfFindeMois12Ans: perfFindeMois12Ans,
            perfFindeMois15Ans: perfFindeMois15Ans,
            perfFindeMois20Ans: perfFindeMois20Ans,
            perfFindeMoisOrigine: perfFindeMoisOrigine,
            perfFindeMoisAnnualized1An: perfFindeMoisAnnualized1An,
            perfFindeMoisAnnualized3An: perfFindeMoisAnnualized3Ans,
            perfFindeMoisAnnualized5Ans: perfFindeMoisAnnualized5Ans,
            perfFindeMoisAnnualized8Ans: perfFindeMoisAnnualized8Ans,
            perfFindeMoisAnnualized10Ans: perfFindeMoisAnnualized10Ans,
            perfFindeMoisAnnualized12Ans: perfFindeMoisAnnualized12Ans,
            perfFindeMoisAnnualized15Ans: perfFindeMoisAnnualized15Ans,
            perfFindeMoisAnnualized20Ans: perfFindeMoisAnnualized20Ans,
            perfFindeMoisAnnualizedOrigine: perfFindeMoisAnnualizedOrigine,
            perfCumuleeFindeMois1An: perfCumuleeFindeMois1An,
            perfCumuleeFindeMois3Ans: perfCumuleeFindeMois3Ans,
            perfCumuleeFindeMois5Ans: perfCumuleeFindeMois5Ans,
            perfCumuleeFindeMois8Ans: perfCumuleeFindeMois8Ans,
            perfCumuleeFindeMois10Ans: perfCumuleeFindeMois10Ans,
            perfCumuleeFindeMois12Ans: perfCumuleeFindeMois12Ans,
            perfCumuleeFindeMois15Ans: perfCumuleeFindeMois15Ans,
            perfCumuleeFindeMois20Ans: perfCumuleeFindeMois20Ans,
            perfCumuleeFindeMoisOrigine: perfCumuleeFindeMoisOrigine,
            perfAnnualizedtodate1An: perfAnnualizedtodate1An,
            perfAnnualizedtodate3Ans: perfAnnualizedtodate3Ans,
            perfAnnualizedtodate5Ans: perfAnnualizedtodate5Ans,
            perfAnnualizedtodate8Ans: perfAnnualizedtodate8Ans,
            perfAnnualizedtodate10Ans: perfAnnualizedtodate10Ans,
            perfAnnualizedtodate12Ans: perfAnnualizedtodate12Ans,
            perfAnnualizedtodate15Ans: perfAnnualizedtodate15Ans,
            perfAnnualizedtodate20Ans: perfAnnualizedtodate20Ans,
            perfAnnualizedtodateOrigine: perfAnnualizedtodateOrigine,
            adaptValues1: multipliedValues,
            //  performancesCategorie:performancesCategorie
          }
        })

      })
  })

  app.get('/api/performancesportefeuilledev/fond/:id/:devise', async (req, res) => {



    portefeuille_vl_cumul.findAll({
      where: {
        portefeuille_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        let baseProperty;
        if (req.params.devise === 'EUR') {
          baseProperty = 'base_100_bis_EUR';
        } else if (req.params.devise === 'USD') {
          baseProperty = 'base_100_bis_USD';
        } else {
          // Handle other cases or set a default property
          baseProperty = 'base_100_bis';
        }
        let lastValuep = response[response.length - 1][baseProperty]; // Dernière valeur

        // const tauxsr=0.03;-0.0116;-0,0234
        const tauxsr = -0.0234;
        // Valeurs liquidatives
        const values = response.map((data) => data[baseProperty]);
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));

        //  const values = response.map((data) => data.value);
        const lastValue = lastValuep;
        //  const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const lastDate = dates[dates.length - 1]

        const targetYear = groupDatesByYear(dates).length

        const lastdatepreviousmonth = findLastDateOfPreviousMonth(dates);

        // Calcul des performances glissantes
        const previousValue = values[values.length - 2];
        const perfVeille = calculatePerformance(lastValue, previousValue);
        const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
        const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
        const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
        const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
        const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
        const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
        const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
        const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
        const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
        const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
        const perf15Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]);
        const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
        const perfOrigine = calculatePerformance(lastValue, values[0]);

        //Performances fin de mois
        const targetDate1An = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
        const targetDate3Ans = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
        const targetDate5Ans = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
        const targetDate8Ans = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
        const targetDate10Ans = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
        const targetDate12Ans = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
        const targetDate15Ans = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
        const targetDate20Ans = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
        const targetDateOrigine = groupDatesByMonth(dates)[0]
        const perfFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        console.log(findLastDateOfPreviousMonth(dates))
        //Performances annualizées fin de mois
        const perfFindeMoisAnnualized1An = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
        const perfFindeMoisAnnualized3Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
        const perfFindeMoisAnnualized5Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
        const perfFindeMoisAnnualized8Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
        const perfFindeMoisAnnualized10Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
        const perfFindeMoisAnnualized12Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
        const perfFindeMoisAnnualized15Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates)))], 15);
        const perfFindeMoisAnnualized20Ans = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates)))], 20);
        const perfFindeMoisAnnualizedOrigine = calculateAnnualizedPerformanceper100(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);


        //Performances cumulées fin de mois
        const perfCumuleeFindeMois1An = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate1An)])
        const perfCumuleeFindeMois3Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate3Ans)])
        const perfCumuleeFindeMois5Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate5Ans)])
        const perfCumuleeFindeMois8Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate8Ans)])
        const perfCumuleeFindeMois10Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate10Ans)])
        const perfCumuleeFindeMois12Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate12Ans)])
        const perfCumuleeFindeMois15Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate15Ans)])
        const perfCumuleeFindeMois20Ans = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDate20Ans)])
        const perfCumuleeFindeMoisOrigine = calculatePerformance(values[dates.indexOf(findLastDateOfPreviousMonth(dates))], values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])

        //Performances annualizées à date
        const perfAnnualizedtodate1An = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1);
        const perfAnnualizedtodate3Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3);
        const perfAnnualizedtodate5Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5);
        const perfAnnualizedtodate8Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8);
        const perfAnnualizedtodate10Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10);
        const perfAnnualizedtodate12Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12);
        const perfAnnualizedtodate15Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15);
        const perfAnnualizedtodate20Ans = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20);
        const perfAnnualizedtodateOrigine = calculateAnnualizedPerformanceper100(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);
        //Performances  annee calendaire
        const ArrayDates = groupDatesByYear(dates);
        const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
        const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
        const multipliedValues = adaptValues1.map(item => {
          const year = item[0];
          const value1 = item[1];
          const value3 = item[2] * 100; // Multipliez la troisième position par 100

          return [year, value1, value3];
        });


        console.log(multipliedValues);
        res.json({
          code: 200,
          data: {
            portefeuille: req.params.id,
            lastdatepreviousmonth: lastdatepreviousmonth,
            perfVeille: perfVeille,
            perf4Semaines: perf4Semaines,
            perf1erJanvier: perf1erJanvier,
            perf3Mois: perf3Mois,
            perf6Mois: perf6Mois,
            perf1An: perf1An,
            perf3Ans: perf3Ans,
            perf5Ans: perf5Ans,
            perf8Ans: perf8Ans,
            perf10Ans: perf10Ans,
            perf12Ans: perf12Ans,
            perf15Ans: perf15Ans,
            perf20Ans: perf20Ans,
            perfOrigine: perfOrigine,
            perfFindeMois1An: perfFindeMois1An,
            perfFindeMois3Ans: perfFindeMois3Ans,
            perfFindeMois5Ans: perfFindeMois5Ans,
            perfFindeMois8Ans: perfFindeMois8Ans,
            perfFindeMois10Ans: perfFindeMois10Ans,
            perfFindeMois12Ans: perfFindeMois12Ans,
            perfFindeMois15Ans: perfFindeMois15Ans,
            perfFindeMois20Ans: perfFindeMois20Ans,
            perfFindeMoisOrigine: perfFindeMoisOrigine,
            perfFindeMoisAnnualized1An: perfFindeMoisAnnualized1An,
            perfFindeMoisAnnualized3An: perfFindeMoisAnnualized3Ans,
            perfFindeMoisAnnualized5Ans: perfFindeMoisAnnualized5Ans,
            perfFindeMoisAnnualized8Ans: perfFindeMoisAnnualized8Ans,
            perfFindeMoisAnnualized10Ans: perfFindeMoisAnnualized10Ans,
            perfFindeMoisAnnualized12Ans: perfFindeMoisAnnualized12Ans,
            perfFindeMoisAnnualized15Ans: perfFindeMoisAnnualized15Ans,
            perfFindeMoisAnnualized20Ans: perfFindeMoisAnnualized20Ans,
            perfFindeMoisAnnualizedOrigine: perfFindeMoisAnnualizedOrigine,
            perfCumuleeFindeMois1An: perfCumuleeFindeMois1An,
            perfCumuleeFindeMois3Ans: perfCumuleeFindeMois3Ans,
            perfCumuleeFindeMois5Ans: perfCumuleeFindeMois5Ans,
            perfCumuleeFindeMois8Ans: perfCumuleeFindeMois8Ans,
            perfCumuleeFindeMois10Ans: perfCumuleeFindeMois10Ans,
            perfCumuleeFindeMois12Ans: perfCumuleeFindeMois12Ans,
            perfCumuleeFindeMois15Ans: perfCumuleeFindeMois15Ans,
            perfCumuleeFindeMois20Ans: perfCumuleeFindeMois20Ans,
            perfCumuleeFindeMoisOrigine: perfCumuleeFindeMoisOrigine,
            perfAnnualizedtodate1An: perfAnnualizedtodate1An,
            perfAnnualizedtodate3Ans: perfAnnualizedtodate3Ans,
            perfAnnualizedtodate5Ans: perfAnnualizedtodate5Ans,
            perfAnnualizedtodate8Ans: perfAnnualizedtodate8Ans,
            perfAnnualizedtodate10Ans: perfAnnualizedtodate10Ans,
            perfAnnualizedtodate12Ans: perfAnnualizedtodate12Ans,
            perfAnnualizedtodate15Ans: perfAnnualizedtodate15Ans,
            perfAnnualizedtodate20Ans: perfAnnualizedtodate20Ans,
            perfAnnualizedtodateOrigine: perfAnnualizedtodateOrigine,
            adaptValues1: multipliedValues,
            //  performancesCategorie:performancesCategorie
          }
        })

      })
  })


  /**
   * @swagger
   * /api/performances/indice/{ind_id}:
   *  get:
   *     tags:
   *       - Performance Data
   *     summary: Retrieve performance data for a specific indice.
   *     description: Retrieve various performance metrics for a specific fund based on its ind_id.
   *     parameters:
   *       - name: ind_id
   *         in: path
   *         description: The ind_id of the indice.
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Successful response containing various performance metrics.
   *         content:
   *           application/json:
   *             schema:
   *               type: object
   *               properties:
   *                 code:
   *                   type: integer
   *                   example: 200
   *                 data:
   *                   type: object
   *                   properties:
   *                     perfVeille:
   *                       type: number
   *                       format: double
   *                       description: Performance for the previous day.
   *                     perf4Semaines:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 4 weeks.
   *                     perf1erJanvier:
   *                       type: number
   *                       format: double
   *                       description: Performance since January 1st of the current year.
   *                     perf3Mois:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 3 months.
   *                     perf6Mois:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 6 months.
   *                     perf1An:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 1 year.
   *                     perf3Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 3 years.
   *                     perf5Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 5 years.
   *                     perf8Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 8 years.
   *                     perf10Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 10 years.
   *                     perf12Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 12 years.
   *                     perf15Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 15 years.
   *                     perf20Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 20 years.
   *                     perfOrigine:
   *                       type: number
   *                       format: double
   *                       description: Performance since the fund's inception.
   *                     perfFindeMois1An:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (1 year).
   *                     perfFindeMois3Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (3 years).
   *                     perfFindeMois5Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (5 years).
   *                     perfFindeMois8Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (8 years).
   *                     perfFindeMois10Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (10 years).
   *                     perfFindeMois12Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (12 years).
   *                     perfFindeMois15Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (15 years).
   *                     perfFindeMois20Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (20 years).
   *                     perfAnnualized1An:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 1 year.
   *                     perfAnnualized3Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 3 years.
   *                     perfAnnualized5Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 5 years.
   *                     perfAnnualized8Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 8 years.
   *                     perfAnnualized10Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 10 years.
   *                     perfAnnualized12Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 12 years.
   *                     perfAnnualized15Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 15 years.
   *                     perfAnnualized20Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 20 years.
   *                     perfAnnualizedOrigine:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance since the fund's inception.
   */
  app.get('/api/performances/indice/:id/:type', (req, res) => {
    indice.findAll({
      where: {
        id_indice: req.params.id,
        type_indice_id: req.params.type
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(response => {
        const values = response.map((data) => data.valeur);
        const lastValue = values[response.length - 1];
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const lastDate = dates[dates.length - 1]


        // Calcul des performances glissantes
        const previousValue = values[values.length - 2];
        const perfVeille = calculatePerformance(lastValue, previousValue);
        const perf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]);
        const perf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
        const perf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
        const perf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
        const perf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]);
        const perf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]);
        const perf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]);
        const perf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]);
        const perf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]);
        const perf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]);
        const perf18Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 18))]);
        const perf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]);
        const perfOrigine = calculatePerformance(lastValue, values[0]);



        ///Performances fin de mois
        const targetDate1An = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
        const targetDate3Ans = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
        const targetDate5Ans = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
        const targetDate8Ans = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
        const targetDate10Ans = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
        const targetDate12Ans = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
        const targetDate15Ans = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
        const targetDate20Ans = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
        const targetDateOrigine = groupDatesByMonth(dates)[0]
        const perfFindeMois1An = calculatePerformance(lastValue, values[dates.indexOf(targetDate1An)])
        const perfFindeMois3Ans = calculatePerformance(lastValue, values[dates.indexOf(targetDate3Ans)])
        const perfFindeMois5Ans = calculatePerformance(lastValue, values[dates.indexOf(targetDate5Ans)])
        const perfFindeMois8Ans = calculatePerformance(lastValue, values[dates.indexOf(targetDate8Ans)])
        const perfFindeMois10Ans = calculatePerformance(lastValue, values[dates.indexOf(targetDate10Ans)])
        const perfFindeMois12Ans = calculatePerformance(lastValue, values[dates.indexOf(targetDate12Ans)])
        const perfFindeMois15Ans = calculatePerformance(lastValue, values[dates.indexOf(targetDate15Ans)])
        const perfFindeMois20Ans = calculatePerformance(lastValue, values[dates.indexOf(targetDate20Ans)])
        const perfFindeMoisOrigine = calculatePerformance(lastValue, values[dates.indexOf(targetDateOrigine[targetDateOrigine.length - 1])])


        //Performances annualisée
        const perfAnnualized1An = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1);
        const perfAnnualized3Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3);
        const perfAnnualized5Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5);
        const perfAnnualized8Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8);
        const perfAnnualized10Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10);
        const perfAnnualized12Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12);
        const perfAnnualized15Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15);
        const perfAnnualized20Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20);
        const targetYear = groupDatesByYear(dates).length
        const perfAnnualizedOrigine = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear);

        res.json({
          code: 200,
          data: {
            perfVeille: perfVeille,
            perf4Semaines: perf4Semaines,
            perf1erJanvier: perf1erJanvier,
            perf3Mois: perf3Mois,
            perf6Mois: perf6Mois,
            perf1An: perf1An,
            perf3Ans: perf3Ans,
            perf5Ans: perf5Ans,
            perf8Ans: perf8Ans,
            perf10Ans: perf10Ans,
            perf12Ans: perf12Ans,
            perf18Ans: perf18Ans,
            perf20Ans: perf20Ans,
            perfOrigine: perfOrigine,
            perfFindeMois1An: perfFindeMois1An,
            perfFindeMois3Ans: perfFindeMois3Ans,
            perfFindeMois5Ans: perfFindeMois5Ans,
            perfFindeMois8Ans: perfFindeMois8Ans,
            perfFindeMois10Ans: perfFindeMois10Ans,
            perfFindeMois12Ans: perfFindeMois12Ans,
            perfFindeMois15Ans: perfFindeMois15Ans,
            perfFindeMois20Ans: perfFindeMois20Ans,
            perfFindeMoisOrigine: perfFindeMoisOrigine,
            perfAnnualized1An: perfAnnualized1An,
            perfAnnualized3Ans: perfAnnualized3Ans,
            perfAnnualized5Ans: perfAnnualized5Ans,
            perfAnnualized8Ans: perfAnnualized8Ans,
            perfAnnualized10Ans: perfAnnualized10Ans,
            perfAnnualized12Ans: perfAnnualized12Ans,
            perfAnnualized15Ans: perfAnnualized15Ans,
            perfAnnualized20Ans: perfAnnualized20Ans,
            perfAnnualizedOrigine: perfAnnualizedOrigine,
          }
        })

      })

  })







  /**
   * @swagger
   * /api/performances/ecart/{fund_id}:
   *  get:
   *     tags:
   *       - Performance Data
   *     summary: Retrieve performance gap data between fund and indice.
   *     description: Retrieve various performance metrics for a specific fund based on its fund_id.
   *     parameters:
   *       - name: fund_id
   *         in: path
   *         description: The fund_id of the fund.
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Successful response containing various performance metrics.
   *         content:
   *           application/json:
   *             schema:
   *               type: object
   *               properties:
   *                 code:
   *                   type: integer
   *                   example: 200
   *                 data:
   *                   type: object
   *                   properties:
   *                     perfVeille:
   *                       type: number
   *                       format: double
   *                       description: Performance for the previous day.
   *                     perf4Semaines:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 4 weeks.
   *                     perf1erJanvier:
   *                       type: number
   *                       format: double
   *                       description: Performance since January 1st of the current year.
   *                     perf3Mois:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 3 months.
   *                     perf6Mois:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 6 months.
   *                     perf1An:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 1 year.
   *                     perf3Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 3 years.
   *                     perf5Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 5 years.
   *                     perf8Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 8 years.
   *                     perf10Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 10 years.
   *                     perf12Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 12 years.
   *                     perf15Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 15 years.
   *                     perf20Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last 20 years.
   *                     perfOrigine:
   *                       type: number
   *                       format: double
   *                       description: Performance since the fund's inception.
   *                     perfFindeMois1An:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (1 year).
   *                     perfFindeMois3Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (3 years).
   *                     perfFindeMois5Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (5 years).
   *                     perfFindeMois8Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (8 years).
   *                     perfFindeMois10Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (10 years).
   *                     perfFindeMois12Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (12 years).
   *                     perfFindeMois15Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (15 years).
   *                     perfFindeMois20Ans:
   *                       type: number
   *                       format: double
   *                       description: Performance for the last month (20 years).
   *                     perfAnnualized1An:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 1 year.
   *                     perfAnnualized3Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 3 years.
   *                     perfAnnualized5Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 5 years.
   *                     perfAnnualized8Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 8 years.
   *                     perfAnnualized10Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 10 years.
   *                     perfAnnualized12Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 12 years.
   *                     perfAnnualized15Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 15 years.
   *                     perfAnnualized20Ans:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance for the last 20 years.
   *                     perfAnnualizedOrigine:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance since the fund's inception.
   */
  app.get('/api/performances/ecart/:id', async (req, res) => {
    let values = []
    let dates = []
    let valuesindifref = []
    let indref;

    await vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['created', 'ASC']
      ]
    }).then((t) => {
      values = t.map((data) => data.value);
      valuesindifref = t.map((data) => data.indRef);
      dates = t.map((data) => moment(data.created).format('YYYY-MM-DD'));
      indref = t[0].indRef
    })

    /* await indice.findAll({
         where: {
             fund_id: indref
         },
         order: [
             ['created', 'ASC']
         ]
     }).then((t) => {
         valuesindifref = t.map((data) => data.value);
         dates = t.map((data) => moment(data.created).format('YYYY-MM-DD'));
     })*/

    const lastValue = values[values.length - 1];
    const previousValue = values[values.length - 2]
    const lastValueInd = values[valuesindifref.length - 1];
    const previousValueInd = values[valuesindifref.length - 2]
    const lastDate = dates[dates.length - 1]

    //Ecart performances glissantes
    const EcartperfVeille = calculatePerformance(lastValue, previousValue) - calculatePerformance(lastValueInd, previousValueInd);
    const Ecartperf4Semaines = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateWeek(dates))]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateWeek(dates))])
    const Ecartperf1erJanvier = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateJanuary(dates))]);
    const Ecartperf3Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 3, lastDate))]);
    const Ecartperf6Mois = calculatePerformance(lastValue, values[dates.indexOf(findNearestDateMonthlized(dates, 6, lastDate))]);
    const Ecartperf1An = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 1))]);
    const Ecartperf3Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 3))]);
    const Ecartperf5Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 5))])
    const Ecartperf8Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 8))])
    const Ecartperf10Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 10))])
    const Ecartperf12Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 12))])
    const Ecartperf18Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 15))])
    const Ecartperf20Ans = calculatePerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 20))])
    const EcartperfOrigine = calculatePerformance(lastValue, values[0]) - calculatePerformance(lastValueInd, valuesindifref[0]);


    //Ecart performances fin de mois
    const targetDate1AnFond = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
    const targetDate3AnsFond = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
    const targetDate5AnsFond = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
    const targetDate8AnsFond = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
    const targetDate10AnsFond = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
    const targetDate12AnsFond = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
    const targetDate15AnsFond = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
    const targetDate20AnsFond = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
    const targetDateOrigineFond = groupDatesByMonth(dates)[0]

    const targetDate1AnIndice = findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))
    const targetDate3AnsIndice = findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))
    const targetDate5AnsIndice = findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))
    const targetDate8AnsIndice = findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates))
    const targetDate10AnsIndice = findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates))
    const targetDate12AnsIndice = findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates))
    const targetDate15AnsIndice = findNearestDateAnnualized(dates, 15, findLastDateOfPreviousMonth(dates))
    const targetDate20AnsIndice = findNearestDateAnnualized(dates, 20, findLastDateOfPreviousMonth(dates))
    const targetDateOrigineIndice = groupDatesByMonth(dates)[0]

    const EcartperfFindeMois1AnFond = calculatePerformance(lastValue, values[dates.indexOf(targetDate1AnFond)]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(targetDate1AnIndice)])
    const EcartperfFindeMois3AnsFond = calculatePerformance(lastValue, values[dates.indexOf(targetDate3AnsFond)]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(targetDate3AnsIndice)])
    const EcartperfFindeMois5AnsFond = calculatePerformance(lastValue, values[dates.indexOf(targetDate5AnsFond)]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(targetDate5AnsIndice)])
    const EcartperfFindeMois8AnsFond = calculatePerformance(lastValue, values[dates.indexOf(targetDate8AnsFond)]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(targetDate8AnsIndice)])
    const EcartperfFindeMois10AnsFond = calculatePerformance(lastValue, values[dates.indexOf(targetDate10AnsFond)]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(targetDate10AnsIndice)])
    const EcartperfFindeMois12AnsFond = calculatePerformance(lastValue, values[dates.indexOf(targetDate12AnsFond)]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(targetDate12AnsIndice)])
    const EcartperfFindeMois15AnsFond = calculatePerformance(lastValue, values[dates.indexOf(targetDate15AnsFond)]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(targetDate15AnsIndice)])
    const EcartperfFindeMois20AnsFond = calculatePerformance(lastValue, values[dates.indexOf(targetDate20AnsFond)]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(targetDate20AnsIndice)])
    const EcartperfFindeMoisOrigineFond = calculatePerformance(lastValue, values[dates.indexOf(targetDateOrigineFond[targetDateOrigineFond.length - 1])]) - calculatePerformance(lastValueInd, valuesindifref[dates.indexOf(targetDateOrigineIndice[targetDateOrigineIndice.length - 1])])


    //Ecart performances annualisées
    const EcartperfAnnualized1An = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 1))], 1) - calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 1))], 1)
    const EcartperfAnnualized3Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 3))], 3) - calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 3))], 3)
    const EcartperfAnnualized5Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 5))], 5) - calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 5))], 5)
    const EcartperfAnnualized8Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 8))], 8) - calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 8))], 8)
    const EcartperfAnnualized10Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 10))], 10) - calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 10))], 10)
    const EcartperfAnnualized12Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 12))], 12) - calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 12))], 12)
    const EcartperfAnnualized15Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 15))], 15) - calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 15))], 15)
    const EcartperfAnnualized20Ans = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, 20))], 20) - calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, 20))], 20)
    const targetYear = groupDatesByYear(dates).length
    const targetYearInd = groupDatesByYear(dates).length
    const EcartperfAnnualizedOrigine = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDate(dates, targetYear))], targetYear) - calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDate(dates, targetYearInd))], targetYearInd);

    res.json({
      code: 200,
      data: {
        // ecart perf glissantes
        EcartperfVeille: EcartperfVeille,
        Ecartperf4Semaines: Ecartperf4Semaines,
        Ecartperf1erJanvier: Ecartperf1erJanvier,
        Ecartperf3Mois: Ecartperf3Mois,
        Ecartperf6Mois: Ecartperf6Mois,
        Ecartperf1An: Ecartperf1An,
        Ecartperf3Ans: Ecartperf3Ans,
        Ecartperf5Ans: Ecartperf5Ans,
        Ecartperf8Ans: Ecartperf8Ans,
        Ecartperf10Ans: Ecartperf10Ans,
        Ecartperf12Ans: Ecartperf12Ans,
        Ecartperf18Ans: Ecartperf18Ans,
        Ecartperf20Ans: Ecartperf20Ans,
        EcartperfOrigine: EcartperfOrigine,

        // ecart perf fin de mois
        EcartperfFindeMois1AnFond: EcartperfFindeMois1AnFond,
        EcartperfFindeMois3AnsFond: EcartperfFindeMois3AnsFond,
        EcartperfFindeMois5AnsFond: EcartperfFindeMois5AnsFond,
        EcartperfFindeMois8AnsFond: EcartperfFindeMois8AnsFond,
        EcartperfFindeMois10AnsFond: EcartperfFindeMois10AnsFond,
        EcartperfFindeMois12AnsFond: EcartperfFindeMois12AnsFond,
        EcartperfFindeMois15AnsFond: EcartperfFindeMois15AnsFond,
        EcartperfFindeMois20AnsFond: EcartperfFindeMois20AnsFond,
        EcartperfFindeMoisOrigineFond: EcartperfFindeMoisOrigineFond,

        //ecart perf annualisée
        EcartperfAnnualized1An: EcartperfAnnualized1An,
        EcartperfAnnualized3Ans: EcartperfAnnualized3Ans,
        EcartperfAnnualized5Ans: EcartperfAnnualized5Ans,
        EcartperfAnnualized8Ans: EcartperfAnnualized8Ans,
        EcartperfAnnualized10Ans: EcartperfAnnualized10Ans,
        EcartperfAnnualized12Ans: EcartperfAnnualized12Ans,
        EcartperfAnnualized15Ans: EcartperfAnnualized15Ans,
        EcartperfAnnualized20Ans: EcartperfAnnualized20Ans,
        EcartperfAnnualizedOrigine: EcartperfAnnualizedOrigine
      }
    })

  })

  function calculateVolatility11(returns) {
    return math.std(returns);
  }

  // Cette fonction annualise la volatilité en supposant un certain nombre de périodes par an
  function annualizeVolatility(volatility, periodsPerYear) {
    return volatility * Math.sqrt(periodsPerYear);
  }

  // Fonction pour regrouper les rendements par période (journaliers, hebdomadaires, mensuels)
  function groupReturnsByPeriod(returns, period) {
    // Implémentez ici la logique pour regrouper les rendements
    // par exemple, si period est 'weekly', regroupez tous les rendements par semaine
  }

  // Calcul de la volatilité sur différentes périodes
  function calculateVolatilityOverPeriods(returns, periodsPerYear) {
    // const groupedReturns = groupReturnsByPeriod(returns, periodsPerYear);
    let volatilities;

    //  Object.keys(groupedReturns).forEach(period => {
    const volatility = calculateVolatility11(returns);
    const annualizedVolatility = annualizeVolatility(volatility, periodsPerYear);
    volatilities = annualizedVolatility;


    return volatilities;
  }




  /**
   * @swagger
   * /api/ratios/{year}/{fund_id}:
   *  get:
   *     tags:
   *       - Fund Ratios
   *     summary: Retrieve various financial ratios for a specific fund.
   *     description: Retrieve a variety of financial ratios for a specific fund based on the year and fund_id.
   *     parameters:
   *       - name: year
   *         in: path
   *         description: The year for which the ratios are being requested.
   *         required: true
   *         schema:
   *           type: integer
   *       - name: fund_id
   *         in: path
   *         description: The fund_id of the fund.
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Successful response containing various financial ratios.
   *         content:
   *           application/json:
   *             schema:
   *               type: object
   *               properties:
   *                 code:
   *                   type: integer
   *                   example: 200
   *                 data:
   *                   type: object
   *                   properties:
   *                     perfAnnualisee:
   *                       type: number
   *                       format: double
   *                       description: Annualized performance ratio.
   *                     perfAnnualiseeInd:
   *                       type: number
   *                       format: double
   *                       description: Individual annualized performance ratio.
   *                     info:
   *                       type: number
   *                       format: double
   *                       description: Information ratio.
   *                     beta:
   *                       type: number
   *                       format: double
   *                       description: Beta ratio.
   *                     r2:
   *                       type: number
   *                       format: double
   *                       description: R-squared ratio.
   *                     skewness:
   *                       type: number
   *                       format: double
   *                       description: Skewness ratio.
   *                     correlation:
   *                       type: number
   *                       format: double
   *                       description: Correlation ratio.
   *                     omega:
   *                       type: number
   *                       format: double
   *                       description: Omega ratio.
   *                     sortino:
   *                       type: number
   *                       format: double
   *                       description: Sortino ratio.
   *                     calmar:
   *                       type: number
   *                       format: double
   *                       description: Calmar ratio.
   *                     volatilityInd:
   *                       type: number
   *                       format: double
   *                       description: Individual volatility ratio.
   *                     volatility:
   *                       type: number
   *                       format: double
   *                       description: Volatility ratio.
   *                     maxDrawdown:
   *                       type: number
   *                       format: double
   *                       description: Maximum drawdown (negative value).
   *                     maxDrawdownInd:
   *                       type: number
   *                       format: double
   *                       description: Individual maximum drawdown (negative value).
   *                     dsr:
   *                       type: number
   *                       format: double
   *                       description: Downside risk ratio.
   *                     ratioSharpe:
   *                       type: number
   *                       format: double
   *                       description: Sharpe ratio.
   *                     kurtosis:
   *                       type: number
   *                       format: double
   *                       description: Kurtosis ratio.
   *                     betaHaussier:
   *                       type: number
   *                       format: double
   *                       description: Bullish beta ratio.
   *                     betaBaiss:
   *                       type: number
   *                       format: double
   *                       description: Bearish beta ratio.
   *                     VAR95:
   *                       type: number
   *                       format: double
   *                       description: Value at Risk (95% confidence level).
   *                     trackingError:
   *                       type: number
   *                       format: double
   *                       description: Tracking error ratio.
   *                     VAR99:
   *                       type: number
   *                       format: double
   *                       description: Value at Risk (99% confidence level).
   *                     delaiRecouvrement:
   *                       type: number
   *                       format: double
   *                       description: Recovery time ratio.
   *                     upCaptureRatio:
   *                       type: number
   *                       format: double
   *                       description: Up capture ratio.
   *                     downCaptureRatio:
   *                       type: number
   *                       format: double
   *                       description: Down capture ratio.
   */
  app.get('/api/ratiossold/:year/:id', async (req, res) => {
    await vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'ASC']
      ]
    })
      .then(async (response) => {

        //valeurs liquidatives
        const values = response.map((data) => data.value);
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const tsrValues = response.map((data) => data.tsr);
        const valuesindifref = response.map((data) => data.indRef);

        let refactoredValuesGl = [];
        let refactoredvaluesindifrefGl = [];

        dates.forEach((date, index) => {
          if (dates.includes(date)) {
            refactoredValuesGl.push(new Fond(new Date(date), values[index]))
            refactoredvaluesindifrefGl.push(new Indice(new Date(date), valuesindifref[index]))
          }
        });

        //derniere date du mois precedent
        const lastPreviousDate = findLastDateOfPreviousMonth(dates)
        const lastPreviousDateBench = findLastDateOfPreviousMonth(dates)

        //valeur de la derniere date du mois precedent
        const lastValue = values[dates.indexOf(findLastDateOfPreviousMonth(dates))];
        const lastValueInd = valuesindifref[dates.indexOf(findLastDateOfPreviousMonth(dates))];

        //si le nombre de rendements de l'indice
        if (req.params.year === "1") {

          //derniere date du mois precedent il y a 1 an
          const yDate = findNearestDateAnnualized(dates, 1, lastPreviousDate)

          // toutes les valeurs sur la periode de 3 ans
          const yArrayValues = values.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1));
          const adaptyArrayValuesinverse1 = yArrayValues.reverse();
          const yArrayDates = groupDatesByWeek(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));

          const adaptValues = adaptValuesToGroupedWeeks(yArrayValues, yArrayDates);
          const adaptValuesinverse1 = adaptValues.reverse();
          const yArrayDatesMonth = groupDatesByMonth(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));
          const adaptValuesMonth = adaptValuesToGroupedMonths(yArrayValues, yArrayDatesMonth);
          const adaptValuesMonthinverse1 = adaptValuesMonth.reverse();

          const rendementJour = CalculateRendJournalier(adaptyArrayValuesinverse1)
          const rendementHebdo = CalculateRendHebdo(adaptValuesinverse1, yArrayDates)
          // console.log(rendementHebdo.length)
          const rendementMonths = CalculateRendMensuel(adaptValuesMonthinverse1, yArrayDatesMonth)


          //taux sans risque à la date d'il y a 1 an
          const riskFreeRate = tsrValues[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))]
          // const moyenneTsr = quants.mean(y1ArrayValues)


          //indice de reference 3 ans
          const yArrayValuesBench = valuesindifref.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDateBench) + 1));
          const adaptyArrayValuesBenchinverse1 = yArrayValuesBench.reverse();

          const yArrayDatesBench = groupDatesByWeek(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDateBench) + 1)));

          const adaptValuesBench = adaptValuesToGroupedWeeks(yArrayValuesBench, yArrayDatesBench);
          const adaptValuesBenchinverse1 = adaptValuesBench.reverse();

          const yArrayDatesMonthBench = groupDatesByMonth(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));
          const adaptValuesMonthBench = adaptValuesToGroupedMonths(yArrayValuesBench, yArrayDatesMonthBench);
          const adaptValuesMonthBenchinverse1 = adaptValuesMonthBench.reverse();

          const rendementJourBench = CalculateRendJournalier(adaptyArrayValuesBenchinverse1)
          const rendementHebdoBench = CalculateRendHebdo(adaptValuesBenchinverse1, yArrayDatesBench)
          const rendementMonthBench = CalculateRendMensuel(adaptValuesMonthBenchinverse1, yArrayDatesMonthBench)


          // let refactoredValues = [];
          // let refactoredvaluesindifref = [];
          // let refactoredDatesAll = [];

          // yArrayDatesBench.forEach((date, index) => {
          //     if (yArrayDates.includes(date)) {
          //         // refactoredValues.push(new Fond(new Date(date), yArrayValues[index]))
          //         // refactoredvaluesindifref.push(new Indice(new Date(date), yArrayValuesBench[index]))
          //         refactoredValues.push(yArrayValues[index])
          //         refactoredvaluesindifref.push(yArrayValuesBench[index])
          //         refactoredDatesAll.push(date)
          //     }
          // });

          // const rendAdaptValuesJour = CalculateRendJournalier(refactoredValues)
          // const rendAdaptvaluesindifrefJour = CalculateRendJournalier(refactoredvaluesindifref)
          // const refactoredValuesWeek = groupDatesByWeek(refactoredDatesAll)
          // const refAdaptValuesWeek = adaptValuesToGroupedWeeks(refactoredValues, refactoredValuesWeek)
          // const refAdaptvaluesindifrefWeek = adaptValuesToGroupedWeeks(refactoredvaluesindifref, refactoredValuesWeek)
          // const rendAdaptValuesHebdo = CalculateRendHebdo(refAdaptValuesWeek)
          // const rendAdaptvaluesindifrefHebdo = CalculateRendHebdo(refAdaptvaluesindifrefWeek)
          //Resultats attendus

          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);

          const volatility = calculateVolatility([...rendementHebdo]);
          const volatilityInd = calculateVolatility([...rendementHebdoBench])


          const maxDrawdown = PortfolioAnalytics.maxDrawdown(values.slice(dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))), dates.indexOf(findLastDateOfPreviousMonth(dates)) + 1))
          const maxDrawdownInd = PortfolioAnalytics.maxDrawdown(valuesindifref.slice(dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))), dates.indexOf(findLastDateOfPreviousMonth(dates)) + 1))
          const dsr = calculateDSR([...rendementHebdo], 1)
          const omega = quants.omega([...rendementHebdo], 0);

          const calmar = socktrader.calmarRatio([...rendementJour], -0.0116 / 252, 252)
          const trackingError = quants.trackerr([...rendementHebdo], [...rendementHebdoBench]) * Math.sqrt(52)
          const VAR95 = calculateVAR95([...rendementHebdo], 0.95);
          const VAR99 = calculateVAR99([...rendementHebdo], 0.99);
          const delaiRecouvrement = calculerDelaiRecouvrement(refactoredValuesGl, new Date(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))), new Date(findLastDateOfPreviousMonth(dates)))


          // const upCaptureRatio = calculerUpCaptureRatio(refactoredValuesGl, refactoredvaluesindifrefGl, new Date(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))), new Date(findLastDateOfPreviousMonth(dates)))
          //  const downCaptureRatio = calculerDownCaptureRatio(refactoredValuesGl, refactoredvaluesindifrefGl, new Date(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates))), new Date(findLastDateOfPreviousMonth(dates)))
          // const delaiRecouvrementInd = calculateDelaiRecouvrement(refactoredValues,1)


          ////const stdFond = math.std([...rendementJour]) * Math.sqrt(252)
          const ratioSharpe = quants.sharpe([...rendementHebdo], 0.034 / 52)
          // calculateSharpeRatio(yArrayValues, 1, -0.0116, stdFond);
          const sortino = quants.sortino([...rendementHebdo], -0.0116, 0)
          // calculateSortinoRatio(yArrayValues, 1, -0.0116, dsr)
          const correlation = quants.corrcoef([...rendementHebdo], [...rendementHebdoBench], 0)



          const info = quants.inforatio([...rendementHebdo], [...rendementHebdoBench]) * Math.sqrt(52)
          // const info = calculateInformationRatio([...rendementHebdo], [...rendementHebdoBench], trackingError)

          // calculateInformationRatio([...rendementJour], [...rendementJourBench], trackingError)

          //covariance entre fond et benchmark / std du fond au carré
          //  const beta = calculateBetanew([...rendementJour], [...rendementJourBench])
          const varindice = calculateVariance([...rendementJourBench]);
          const cov = calculateCovariance([...rendementJour], [...rendementJourBench])
          const beta = calculateBetanewnew(varindice, cov)
          const betaHaussier = calculateBetaHaussier([...rendementJour], [...rendementJourBench])
          const betaBaiss = calculateBetaBaissier([...rendementHebdo], [...rendementHebdoBench])

          const r2 = quants.linreg([...rendementMonths], [...rendementMonthBench]).rsq
          // quants.skewness(rendementHebdo, 0)
          /* const skewness = ss.sampleSkewness([...rendementHebdo])  Math.cbrt(52) ;
           const kurtosis = ss.sampleKurtosis([...rendementHebdo]);*/


          res.json({
            code: 200,
            data: {
              volatility: volatility * 100,
              volatilityInd: volatilityInd * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              betaHaussier,
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        }
        else if (req.params.year === "3") {

          //derniere date du mois precedent il y a 3 ans
          const yDate = findNearestDateAnnualized(dates, 3, lastPreviousDate)

          console.log(values.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));

          // toutes les valeurs sur la periode de 3 ans
          const yArrayValues = values.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1));
          const yArrayDates = groupDatesByWeek(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));
          const yArrayDatesreverse = yArrayDates.reverse();
          const yArrayValuesinverse = yArrayValues.reverse();
          const adaptValues = adaptValuesToGroupedWeeks(yArrayValuesinverse, yArrayDatesreverse);
          //const adaptValuesinverse1 = adaptValues.reverse();
          const yArrayDatesMonth = groupDatesByMonth(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));
          const adaptValuesMonth = adaptValuesToGroupedMonths(yArrayValues, yArrayDatesMonth);
          const adaptValuesMonthinverse1 = adaptValuesMonth.reverse();

          const rendementJour = CalculateRendJournalier(yArrayValues)
          const rendementHebdo = CalculateRendHebdo(adaptValues)
          const rendementHebdoinverse = rendementHebdo.reverse();
          // console.log(rendementHebdo.length)
          const rendementMonths = CalculateRendMensuel(adaptValuesMonthinverse1, yArrayDatesMonth)



          //taux sans risque à la date d'il y a 3 ans
          const riskFreeRate = tsrValues[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))]
          // const moyenneTsr = quants.mean(y3ArrayValues)


          //indice de reference 3 ans
          const yArrayValuesBench = valuesindifref.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDateBench) + 1));
          const yArrayDatesBench = groupDatesByWeek(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDateBench) + 1)));

          const adaptValuesBenchinverse1 = yArrayValuesBench.reverse();
          const adaptValuesBench = adaptValuesToGroupedWeeks(yArrayValuesBench, yArrayDatesBench);

          const yArrayDatesMonthBench = groupDatesByMonth(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));
          const adaptValuesMonthBench = adaptValuesToGroupedMonths(yArrayValuesBench, yArrayDatesMonthBench);
          const adaptValuesMonthBenchinverse1 = adaptValuesMonthBench.reverse();

          const rendementJourBench = CalculateRendJournalier(yArrayValuesBench)
          const rendementHebdoBench = CalculateRendHebdo(adaptValuesBenchinverse1, yArrayDatesBench)
          const rendementMonthBench = CalculateRendMensuel(adaptValuesMonthBenchinverse1, yArrayDatesMonthBench)


          let refactoredValues = [];
          let refactoredvaluesindifref = [];

          yArrayDates.forEach((date, index) => {
            if (yArrayDatesBench.includes(date)) {
              refactoredValues.push(new Fond(new Date(date), yArrayValues[index]))
              refactoredvaluesindifref.push(new Indice(new Date(date), yArrayValuesBench[index]))
            }
          });



          // Supposons que vous avez un tableau de rendements journaliers
          const dailyReturns = [...rendementJour]
          const weeklyReturns = [...rendementHebdoinverse];
          const monthlyReturns = [...rendementMonths];

          // Calcul de la volatilité pour chaque type de rendement

          /*
                    const volatility = calculateVolatilityOverPeriods(
                      weeklyReturns,
                      52);
          
          
                    // Calcul de la moyenne des rendements hebdomadaires
                    const meanReturn = math.mean(weeklyReturns);
          
                    // Calcul de l'écart-type des rendements hebdomadaires
                    const standardDeviation = math.std(weeklyReturns);
          
                    // Calcul de la volatilité annuelle
                    const annualizedVolatility = Math.sqrt(52) * standardDeviation;
          
                    console.log('La volatilité annuelle est:', annualizedVolatility);*/
          //Resultats attendus
          const volatility = calculateVolatility([...rendementHebdo]);
          const volatilityInd = calculateVolatility([...rendementHebdoBench])
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);


          const VAR95 = calculateVAR95([...rendementHebdo], 0.95)
          const VAR99 = calculateVAR99([...rendementHebdo], 0.99)


          //const stdFond = math.std([...rendementJour]) * Math.sqrt(252)

          // const volatilityInd = calculateVolatility(rendementHebdoBench)


          const beta = calculateBetanew([...rendementHebdo], [...rendementHebdoBench])
          /* const varindice = calculateVariance([...rendementHebdoBench]);
           const cov = calculateCovariance([...rendementHebdoBench], [...rendementHebdo])
           const beta = calculateBetanewnew(varindice, cov)*/
          console.log(dates.indexOf(yDate));
          console.log((dates.indexOf(lastPreviousDate) + 1));

          const maxDrawdown = PortfolioAnalytics.maxDrawdown(values.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)))
          const maxDrawdownInd = PortfolioAnalytics.maxDrawdown(valuesindifref.slice(dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))), dates.indexOf(findLastDateOfPreviousMonth(dates)) + 1))
          const dsr = calculateDSR([...rendementHebdo], 3)
          const omega = quants.omega([...rendementHebdo], 0);
          const calmar = socktrader.calmarRatio([...rendementJour], -0.0116 / 252, 252)
          const trackingError = quants.trackerr([...rendementHebdo], [...rendementHebdoBench]) * Math.sqrt(52)

          // const delaiRecouvrementInd = calculateDelaiRecouvrement(refactoredValues,3)

          const ratioSharpe = quants.sharpe(rendementHebdo, 52, 0.03)
          const sortino = quants.sortino([...rendementHebdo], 0.03 / 52, 52)
          // calculateSortinoRatio(yArrayValues, 3, riskFreeRate, dsr)

          const correlation = quants.corrcoef([...rendementHebdo], [...rendementHebdoBench], 0)
          const info = quants.inforatio([...rendementHebdo], [...rendementHebdoBench]) * Math.sqrt(52)

          //covariance entre fond et benchmark / std du fond au carré

          const betaHaussier = calculateBetaHaussier([...rendementHebdo], [...rendementHebdoBench])
          const betaBaiss = calculateBetaBaissier([...rendementHebdo], [...rendementHebdoBench])
          // const r2 = quants.linreg([...rendementHebdo], [...rendementHebdoBench])

          // const m = [...rendementHebdo].map((e, index) => [e, rendementHebdoBench[index]])
          const r2 = quants.linreg([...rendementMonths], [...rendementMonthBench]).rsq

          // const r2 = regression.linear(m).r2

          //regression lineaire des données negatives

          const delaiRecouvrement = calculerDelaiRecouvrement(yArrayValues, new Date(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))), new Date(findLastDateOfPreviousMonth(dates)))
          //  const upCaptureRatio = calculerUpCaptureRatio(refactoredValues, refactoredvaluesindifref, new Date(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))), new Date(findLastDateOfPreviousMonth(dates)))
          //  const downCaptureRatio = calculerDownCaptureRatio(refactoredValues, refactoredvaluesindifref, new Date(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates))), new Date(findLastDateOfPreviousMonth(dates)))

          /*  const skewness = ss.sampleSkewness([...rendementHebdo]);
            const kurtosis = ss.sampleKurtosis([...rendementHebdo]);*/

          res.json({
            code: 200,
            data: {
              volatility: volatility * 100,
              volatilityInd: volatilityInd * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              betaHaussier,
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        }
        else if (req.params.year === "5") {
          //derniere date du mois precedent il y a 5 ans
          const yDate = findNearestDateAnnualized(dates, 5, lastPreviousDate)

          console.log(values.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));

          // toutes les valeurs sur la periode de 5 ans
          const yArrayValues = values.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1));
          const yArrayDates = groupDatesByWeek(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));
          const yArrayDatesreverse = yArrayDates.reverse();
          const yArrayValuesinverse = yArrayValues.reverse();
          const adaptValues = adaptValuesToGroupedWeeks(yArrayValuesinverse, yArrayDatesreverse);
          //  const adaptValuesinverse1 = adaptValues.reverse();
          const yArrayDatesMonth = groupDatesByMonth(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));
          const adaptValuesMonth = adaptValuesToGroupedMonths(yArrayValues, yArrayDatesMonth);
          const adaptValuesMonthinverse1 = adaptValuesMonth.reverse();

          const rendementJour = CalculateRendJournalier(yArrayValues)
          const rendementHebdo = CalculateRendHebdo(adaptValues)
          const rendementHebdoinverse = rendementHebdo.reverse();
          // console.log(rendementHebdo.length)
          const rendementMonths = CalculateRendMensuel(adaptValuesMonthinverse1, yArrayDatesMonth)
          //taux sans risque à la date d'il y a 5 ans
          const riskFreeRate = tsrValues[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))]
          // const moyenneTsr = quants.mean(y3ArrayValues)


          //indice de reference 5 ans
          const yArrayValuesBench = valuesindifref.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDateBench) + 1));
          const yArrayDatesBench = groupDatesByWeek(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDateBench) + 1)));

          const adaptValuesBenchinverse1 = yArrayValuesBench.reverse();
          const adaptValuesBench = adaptValuesToGroupedWeeks(yArrayValuesBench, yArrayDatesBench);

          const yArrayDatesMonthBench = groupDatesByMonth(dates.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)));
          const adaptValuesMonthBench = adaptValuesToGroupedMonths(yArrayValuesBench, yArrayDatesMonthBench);
          const adaptValuesMonthBenchinverse1 = adaptValuesMonthBench.reverse();

          const rendementJourBench = CalculateRendJournalier(yArrayValuesBench)
          const rendementHebdoBench = CalculateRendHebdo(adaptValuesBenchinverse1, yArrayDatesBench)
          const rendementMonthBench = CalculateRendMensuel(adaptValuesMonthBenchinverse1, yArrayDatesMonthBench)

          let refactoredValues = [];
          let refactoredvaluesindifref = [];

          yArrayDates.forEach((date, index) => {
            if (yArrayDatesBench.includes(date)) {
              refactoredValues.push(new Fond(new Date(date), yArrayValues[index]))
              refactoredvaluesindifref.push(new Indice(new Date(date), yArrayValuesBench[index]))
            }
          });



          //Resultats attendus
          const volatility = calculateVolatility([...rendementHebdo]);
          const volatilityInd = calculateVolatility([...rendementHebdoBench])
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(yDate)], 5);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 5);

          //const stdFond = math.std([...rendementJour]) * Math.sqrt(252)
          const VAR95 = calculateVAR95([...rendementHebdo], 0.95);
          const VAR99 = calculateVAR99([...rendementHebdo], 0.99)
          const maxDrawdown = PortfolioAnalytics.maxDrawdown(values.slice(dates.indexOf(yDate), (dates.indexOf(lastPreviousDate) + 1)))
          const maxDrawdownInd = PortfolioAnalytics.maxDrawdown(valuesindifref.slice(dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))), dates.indexOf(findLastDateOfPreviousMonth(dates)) + 1))
          const dsr = calculateDSR([...rendementHebdo], 5)
          const omega = quants.omega([...rendementHebdo], 0);
          const calmar = socktrader.calmarRatio([...rendementJour], 0, 252)

          const trackingError = quants.trackerr([...rendementHebdo], [...rendementHebdoBench]) * Math.sqrt(52)
          const delaiRecouvrement = calculerDelaiRecouvrement(yArrayValues, new Date(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))), new Date(findLastDateOfPreviousMonth(dates)))

          // const delaiRecouvrementInd = calculateDelaiRecouvrement(refactoredValues,5)
          //  const upCaptureRatio = calculerUpCaptureRatio(refactoredValues, refactoredvaluesindifref, new Date(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))), new Date(findLastDateOfPreviousMonth(dates)))
          // const downCaptureRatio = calculerDownCaptureRatio(refactoredValues, refactoredvaluesindifref, new Date(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates))), new Date(findLastDateOfPreviousMonth(dates)))
          // const delaiRecouvrementInd = calculateDelaiRecouvrement(refactoredValues,1)
          const betaHaussier = calculateBetaHaussier(refactoredValues, refactoredvaluesindifref)
          const betaBaiss = calculateBetaBaissier(refactoredValues, refactoredvaluesindifref)


          const ratioSharpe = quants.sharpe(rendementHebdo, 0.03716)
          const sortino = calculateSortinoRatio(yArrayValues, 5, -0.0116, dsr) //faux
          const correlation = quants.corrcoef([...rendementHebdo], [...rendementHebdoBench], 0)


          const info = socktrader.informationRatio([...rendementHebdo], [...rendementHebdoBench]) * Math.sqrt(52)


          //covariance entre fond et benchmark / std du fond au carré
          // const beta = calculateBetanew([...rendementHebdo], [...rendementHebdoBench])
          const varindice = calculateVariance([...rendementHebdoBench]);
          const cov = calculateCovariance([...rendementHebdoBench], [...rendementHebdo])
          const beta = calculateBetanewnew(varindice, cov)
          const r2 = quants.linreg([...rendementHebdo], [...rendementHebdoBench]).rsq

          //regression lineaire des données negatives
          //const betaBaiss = calculateBetaBaissier(values,valuesindifref)

          /* const skewness = ss.sampleSkewness([...rendementHebdo]);
           const kurtosis = ss.sampleKurtosis([...rendementHebdo]);*/

          res.json({
            code: 200,
            data: {
              volatility: volatility * 100,
              volatilityInd: volatilityInd * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              //   kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              betaHaussier,
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        }
        else if (req.params.year === "origine") {

          //fond
          const ArrayDates = groupDatesByWeek(dates);
          const adaptValues = adaptValuesToGroupedWeeks(values, ArrayDates);

          const ArrayDatesMonth = groupDatesByMonth(dates);
          const adaptValuesMonth = adaptValuesToGroupedMonths(values, ArrayDatesMonth);

          const rendementJour = CalculateRendJournalier(values)
          const rendementHebdo = CalculateRendHebdo(adaptValues)
          const rendementMonths = CalculateRendMensuel(adaptValuesMonth)


          //indice
          const ArrayDatesBench = groupDatesByWeek(dates);
          const adaptValuesBench = adaptValuesToGroupedWeeks(valuesindifref, ArrayDatesBench);

          const ArrayDatesMonthBench = groupDatesByMonth(dates);
          const adaptValuesMonthBench = adaptValuesToGroupedMonths(valuesindifref, ArrayDatesMonthBench);

          const rendementJourBench = CalculateRendJournalier(values)
          const rendementHebdoBench = CalculateRendHebdo(adaptValuesBench)
          const rendementMonthsBench = CalculateRendMensuel(adaptValuesMonthBench)


          const targetYear = groupDatesByYear(dates).length
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[0], targetYear);
          const volatility = calculateVolatility(rendementHebdo);
          const stdFond = math.std(rendementJour) * Math.sqrt(252)
          const volatilityInd = calculateVolatility(rendementHebdoBench)
          const VAR95 = calculateVAR95(rendementHebdo, 0.95);
          const maxDrawdown = PortfolioAnalytics.maxDrawdown(values)
          const maxDrawdownInd = PortfolioAnalytics.maxDrawdown(valuesindifref)
          const dsr = calculateDSR(rendementHebdo, targetYear)
          const omega = quants.omega(rendementHebdo, 0);
          const calmar = socktrader.calmarRatio(rendementJour, 0, 252)
          const trackingError = calculateTrackingError(rendementJour, rendementJourBench)
          const VAR99 = calculateVAR99(rendementHebdo, 0.99)
          const delaiRecouvrement = calculateDelaiRecouvrement(refactoredValues, refactoredValues.length)
          const delaiRecouvrementInd = calculateDelaiRecouvrement(refactoredValues, refactoredValues.length)
          // const betaHaussier = calculateBetaHaussier(refactoredValues,refactoredvaluesindifref)


          const ratioSharpe = calculateSharpeRatio(yArrayValues, targetYear, riskFreeRate, stdFond);
          const sortino = calculateSortinoRatio(yArrayValues, targetYear, riskFreeRate, dsr)
          const correlation = quants.corrcoef(rendementJour, rendementJourBench, 0)

          // console.log(rende)
          const info = quants.inforatio([...rendementHebdo], [...rendementHebdoBench])
          // calculateInformationRatio(rendementJour, rendementJourBench)

          //covariance entre fond et benchmark / std du fond au carré
          const beta = calculateBetanew(rendementJour, rendementJourBench)
          const r2 = quants.linreg(rendementJour, rendementJourBench).rsq


          //regression lineaire des données negatives
          //const betaBaiss = calculateBetaBaissier(values,valuesindifref)

          /*  const skewness = quants.skewness(rendementHebdo, 0) * Math.cbrt(52);
            const kurtosis = quants.kurtosis(rendementHebdo, 0) * Math.pow(52, 1 / 4);*/

          res.json({
            code: 200,
            data: {
              perfAnnualisee,
              info,
              beta,
              r2,
              //   skewness,
              correlation,
              omega,
              sortino,
              calmar,
              volatility,
              volatilityInd,
              maxDrawdown: -maxDrawdown,
              maxDrawdownInd: -maxDrawdownInd,
              dsr,
              ratioSharpe,
              //    kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95,
              trackingError,
              VAR99,
              delaiRecouvrement,
              delaiRecouvrementInd
            }
          })
        }
        else {
          res.json({ code: 400, message: "Paramètre non pris en compte" })
        }




      })
  })

  // Fonction pour calculer la volatilité
  function calculerVolatilite(rendements) {
    let moyenne = rendements.reduce((acc, r) => acc + r, 0) / rendements.length;
    let variance = rendements.reduce((acc, r) => acc + Math.pow(r - moyenne, 2), 0) / rendements.length;
    return Math.sqrt(variance) * Math.sqrt(52); // Annualisation
  }
  function calculerVolatilitejour(rendements) {
    let moyenne = rendements.reduce((acc, r) => acc + r, 0) / rendements.length;
    let variance = rendements.reduce((acc, r) => acc + Math.pow(r - moyenne, 2), 0) / rendements.length;
    return Math.sqrt(variance) * Math.sqrt(252); // Annualisation
  }
  function calculerVolatilitemois(rendements) {
    let moyenne = rendements.reduce((acc, r) => acc + r, 0) / rendements.length;
    let variance = rendements.reduce((acc, r) => acc + Math.pow(r - moyenne, 2), 0) / rendements.length;
    return Math.sqrt(variance) * Math.sqrt(12); // Annualisation
  }
  function trouverElementLePlusProche(array, dateRecherche) {
    // Filtrer les éléments avec une date non nulle
    const elementsAvecDateNonNull = array.filter(d => d.date !== null);

    // Trier les éléments par différence avec la date de recherche
    const elementsTries = _.sortBy(elementsAvecDateNonNull, d => Math.abs(new Date(d.date) - new Date(dateRecherche)));

    // Prendre le premier élément trié (le plus proche)
    const elementLePlusProche = elementsTries[0];

    return elementLePlusProche;
  }
  function trouverElementLePlusProcheavant(array, dateRecherche) {
    // Filtrer les éléments avec une date non nulle
    const elementsAvecDateNonNull = array.filter(d => d.date !== null);

    // Trier les éléments par différence avec la date de recherche en ordre décroissant
    const elementsTries = _.sortBy(elementsAvecDateNonNull, d => -(new Date(d.date) - new Date(dateRecherche)));

    // Prendre le premier élément trié (le plus proche en venant vers l'avant)
    const elementLePlusProche = elementsTries[0];

    return elementLePlusProche;
  }

  async function tsrhistos(datee, year) {

    // Récupérer la dernière valeur du mois précédent
    const lastValue = await tsrhisto.findOne({
      where: {
        date: {
          //  [Op.lt]: new Date(new Date().setDate(0))  // Dernier jour du mois précédent
          [Op.lt]: datee
        },
      },
      order: [['date', 'DESC']]
    });

    if (!lastValue) {
      throw new Error('No data found for the last month.');
    }

    const endDate = lastValue.date;
    const startDate = new Date(endDate);
    startDate.setFullYear(startDate.getFullYear() - parseInt(year));
    let values;
    if (parseInt(year) == 5 || parseInt(year) == 10) {
      // Récupérer les valeurs sur les 10 dernières années
      values = await tsrhisto.findAll({
        where: {
          date: {
            [Op.between]: [startDate, endDate]
          }, annee: parseInt(year)
        },
        order: [['date', 'ASC']]
      });
    } else {
      values = await tsrhisto.findAll({
        where: {
          date: {
            [Op.between]: [startDate, endDate]
          },
          indice: "MONIA"
        },
        order: [['date', 'ASC']]
      });
    }

    const valueArray = values.map(record => record.value);
    const annualYield = math.mean(valueArray)
    return annualYield;
  }
  app.get('/api/ratiosnew/:year/:id', async (req, res) => {
    const fonds = await fond.findOne({
      where: {
        id: req.params.id, // Supposons que vous récupériez l'ID du fond depuis les paramètres de l'URL
      },
    });

    if (!fonds) {
      return res.status(404).json({ message: "Fond non trouvé" });
    }

    // Maintenant, vous avez le pays du fond
    const paysFond = fonds.pays;



    await vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'DESC'] // Modification ici pour trier par date en ordre décroissant
      ]
    })
      .then(async (response) => {
        // const tauxsr=0.03;-0.0116;-0,0234
        // const tauxsr = -0.0234;
        let tauxsr;
        // Valeurs liquidatives
        const values = response.map((data) => data.vl_ajuste); //todo
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const tsrValues = response.map((data) => data.tsr);
        const valuesindifref = response.map((data) => data.indRef);


        const lastValue = values[dates.indexOf(findLastDateOfPreviousMonth(dates))];
        const lastValueInd = valuesindifref[dates.indexOf(findLastDateOfPreviousMonth(dates))];


        // Dernière date du mois précédent
        const lastPreviousDate = findLastDateOfPreviousMonth(dates)

        const yArrayValuesnew = values.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayDatesnew = dates.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayValuesindifrefnew = valuesindifref.slice(dates.indexOf(lastPreviousDate), dates.length - 1);

        const donneesarray = [];
        const donneesarrayindref = [];

        for (let i = 0; i < yArrayValuesnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesnew[i];

          donneesarray.push({ date, value });
        }

        for (let i = 0; i < yArrayValuesindifrefnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesindifrefnew[i];

          donneesarrayindref.push({ date, value });
        }


        //  const tauxGroupesParSemaine = grouperTauxParSemaine(tableauDonneestsr);
        /*   tableauDonneestsr.forEach((expObject) => {
       expObject.date = grouperTauxParSemaine(expObject.semaine);
     });*/
        //   let tauxsrannu = trouverElementLePlusProche(tableauDonneestsr, findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)));
        if (paysFond == "Maroc") {
          tauxsr = await tsrhistos(lastPreviousDate, req.params.year)
          tauxsr = tauxsr / 100;
        } else {
          tauxsr = -0.0234;
        }

        //  tauxsr = -0.0234; // Ou toute autre valeur par défaut que vous souhaitez

        //si le nombre de rendements de l'indice
        if (req.params.year === "1") {
          // Récupérer la dernière date dans la base de données
          const derniereDate = await tsr.max('date', { where: { pays: paysFond } });

          // Calculer la date un an en arrière à partir de la dernière date
          const dateUnAnAvant = new Date(derniereDate);
          dateUnAnAvant.setFullYear(dateUnAnAvant.getFullYear() - 1);

          // Rechercher le taux sans risque le plus proche à la fin du mois un an en arrière
          const tauxSansRisqueUnAnAvant = await tsr.findOne({
            where: {
              date: {
                [Sequelize.Op.lte]: dateUnAnAvant, // Date un an en arrière ou antérieure
                [Sequelize.Op.gte]: new Date(dateUnAnAvant.getFullYear(), dateUnAnAvant.getMonth() + 1, 0) // Dernier jour du mois
              },
              pays: paysFond,
            },
            order: [['date', 'DESC']], // Tri par date décroissante
          });

          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '1_an': findNearestDatetoyear(dates, 1, endDate),

          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSSjour);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;
          }

          if (rendementsTableau['1_an'].length > 0) {

            const yDate = findNearestDateAnnualized(dates, 1, lastPreviousDate)

            const portfolioReturns = rendementsTableau['1_an']

            const benchmarkReturns = rendementsTableauindice['1_an'];
            const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], lastValue, 1)

            //  const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
            //  const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])
            const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
            const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);

            const info = calculateInformationRatio([...rendementsTableau['1_an']], [...rendementsTableauindice['1_an']])
            const infojour = calculateInformationRatiojour([...rendementsTableaujour['1_an']], [...rendementsTableauindicejour['1_an']])
            const infomois = calculateInformationRatio([...rendementsTableaumois['1_an']], [...rendementsTableauindicemois['1_an']])

            // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
            const beta = calculateBetanew(rendementsTableau['1_an'], rendementsTableauindice['1_an'])
            const betajour = calculateBetanew(rendementsTableaujour['1_an'], rendementsTableauindicejour['1_an'])
            const betamois = calculateBetanew(rendementsTableaumois['1_an'], rendementsTableauindicemois['1_an'])

            const VAR95 = calculateVAR95([...rendementsTableau["1_an"]], 0.95);
            const VAR95jour = calculateVAR95([...rendementsTableaujour["1_an"]], 0.95);
            const VAR95mois = calculateVAR95([...rendementsTableaumois["1_an"]], 0.95);

            const VAR99 = calculateVAR99([...rendementsTableau["1_an"]], 0.99)
            const VAR99jour = calculateVAR99([...rendementsTableaujour["1_an"]], 0.99)
            const VAR99mois = calculateVAR99([...rendementsTableaumois["1_an"]], 0.99)

            const skewness = calculerSkewness([...rendementsTableau["1_an"]], volatilites["1_an"])
            const skewnessjour = calculerSkewness([...rendementsTableaujour["1_an"]], volatilitesjour["1_an"])
            const skewnessmois = calculerSkewness([...rendementsTableaumois["1_an"]], volatilitesmois["1_an"])


            const kurtosis = calculateKurtosis([...rendementsTableau["1_an"]])
            const kurtosisjour = calculateKurtosis([...rendementsTableaujour["1_an"]])
            const kurtosismois = calculateKurtosis([...rendementsTableaumois["1_an"]])

            const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
            const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
            const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0.01)
            const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["1_an"]], 0.01)
            const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["1_an"]], 0.01)

            const omega = calculateOmegaRatio([...rendementsTableau["1_an"]], 0);
            const omegajour = calculateOmegaRatio([...rendementsTableaujour["1_an"]], 0);
            const omegamois = calculateOmegaRatio([...rendementsTableaumois["1_an"]], 0);

            const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

            const sortino = calculateSortinoRatio([...rendementsTableau["1_an"]], -0.00473, 0.01);
            const sortinojour = calculateSortinoRatio([...rendementsTableaujour["1_an"]], -0.00473, 0.01);
            const sortinomois = calculateSortinoRatio([...rendementsTableaumois["1_an"]], -0.00473, 0.01);

            const betaBaiss = calculateDownsideBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const betaHaussier = calculateHaussierBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const trackingError = calculateTrackingError([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const trackingErrormois = calculateTrackingError([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            // const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0) 

            const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


            // const ratioSharpe = calculateSharpeRatio(rendementsTableau["1_an"], 0.000751923)
            const ratioSharpe = (CAGR - tauxsr) / volatilites["1_an"];
            const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["1_an"];
            const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["1_an"];

            const correlation = quants.corrcoef([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]], 0)
            const correlationjour = quants.corrcoef([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]], 0)
            const correlationmois = quants.corrcoef([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]], 0)

            // const r2 = quants.linreg([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]]).rsq
            const r2 = calculerR2([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const r2jour = calculerR2([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const r2mois = calculerR2([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])



            res.json({
              code: 200,
              data: {

                volatility: volatilites["1_an"] * 100,
                volatilityjour: volatilitesjour["1_an"] * 100,
                volatilitymois: volatilitesmois["1_an"] * 100,
                volatilityInd: volatilitesind["1_an"] * 100,
                volatilityIndjour: volatilitesindjour["1_an"] * 100,
                volatilityIndmois: volatilitesindmois["1_an"] * 100,
                beta,
                betajour,
                betamois,
                perfAnnualisee: perfAnnualisee * 100,
                CAGR,
                perfAnnualiseeInd: perfAnnualiseeInd * 100,
                info,
                infojour: infojour,
                infomois: infomois,
                r2,
                r2jour,
                r2mois,
                // skewness,
                correlation,
                correlationjour,
                correlationmois,
                omega,
                omegajour,
                omegamois,
                sortino,
                sortinojour,
                sortinomois,
                calmar,

                // volatilityInd,
                maxDrawdown: -maxDrawdown * 100,
                maxDrawdownInd: -maxDrawdownInd * 100,
                dsr,
                dsrjour,
                dsrmois,
                ratioSharpe,
                ratioSharpejour,
                ratioSharpemois,
                // kurtosis,
                // betaHaussier,
                // betaBaiss,
                VAR95: VAR95 * 100,
                VAR95jour: VAR95jour * 100,
                VAR95jour: VAR95mois * 100,
                trackingError: trackingError * 100,
                trackingErrorjour: trackingErrorjour * 100,
                trackingErrorjour: trackingErrormois * 100,

                VAR99: VAR99 * 100,
                VAR99jour: VAR99jour * 100,
                VAR99mois: VAR99mois * 100,

                delaiRecouvrement,
                betaHaussier,
                betaHaussierjour,
                betaHaussiermois,

                betaBaiss,
                betaBaissjour,
                betaBaissmois,

                UpCaptureRatio,
                UpCaptureRatiojour,
                UpCaptureRatiomois,

                DownCaptureRatio,
                DownCaptureRatiojour,
                DownCaptureRatiomois,

                skewness,
                skewnessjour,
                skewnessmois,

                kurtosis,
                kurtosisjour,
                kurtosismois,


                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          } else {
            res.json({
              code: 200,
              data: {
                volatility: '-',
                volatilityInd: '-',
                beta: '-',
                perfAnnualisee: '-',
                perfAnnualiseeInd: '-',
                info: '-',
                r2: '-',
                // skewness,
                correlation: '-',
                omega: '-',
                sortino: '-',
                calmar: '-',
                // volatilityInd,
                maxDrawdown: '-',
                maxDrawdownInd: '-',
                dsr: '-',
                ratioSharpe: '-',
                // kurtosis,
                betaHaussier: '-',
                betaBaiss: '-',
                VAR95: '-',
                trackingError: '-',
                VAR99: '-',
                /* delaiRecouvrement,
                 betaHaussier,*/
                // betaBaiss:'-',
                /*  upCaptureRatio,
                  downCaptureRatio,*/
                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          }
        } else if (req.params.year === "3") {
          // Récupérer la dernière date dans la base de données
          const derniereDate = await tsr.max('date', { where: { pays: paysFond } });

          // Calculer la date un an en arrière à partir de la dernière date
          const dateUnAnAvant = new Date(derniereDate);
          dateUnAnAvant.setFullYear(dateUnAnAvant.getFullYear() - 3);

          // Rechercher le taux sans risque le plus proche à la fin du mois un an en arrière
          const tauxSansRisqueUnAnAvant = await tsr.findOne({
            where: {
              date: {
                [Sequelize.Op.lte]: dateUnAnAvant, // Date un an en arrière ou antérieure
                [Sequelize.Op.gte]: new Date(dateUnAnAvant.getFullYear(), dateUnAnAvant.getMonth() + 1, 0) // Dernier jour du mois
              },
              pays: paysFond,
            },
            order: [['date', 'DESC']], // Tri par date décroissante
          });

          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '3_ans': findNearestDatetoyear(dates, 3, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};


          let Vls = [];
          let Vlsindice = [];

          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //   if(rendementsTableau['3_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 3, lastPreviousDate)
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], lastValue, 3)
          const portfolioReturns = rendementsTableau['3_ans']

          const benchmarkReturns = rendementsTableauindice['3_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);

          const info = calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['3_ans']], [...rendementsTableauindicemois['3_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['3_ans'], rendementsTableauindicejour['3_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['3_ans'], rendementsTableauindicemois['3_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["3_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["3_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["3_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["3_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["3_ans"]], volatilites["3_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["3_ans"]], volatilitesjour["3_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["3_ans"]], volatilitesmois["3_ans"])

          const kurtosis = calculateKurtosis([...rendementsTableau["3_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["3_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["3_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["3_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["3_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["3_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["3_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["3_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["3_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["3_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["3_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["3_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["3_ans"] * 100,
              volatilityjour: volatilitesjour["3_ans"] * 100,
              volatilitymois: volatilitesmois["3_ans"] * 100,
              volatilityInd: volatilitesind["3_ans"] * 100,
              volatilityIndjour: volatilitesindjour["3_ans"] * 100,
              volatilityIndmois: volatilitesindmois["3_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,

              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*   }else{
               res.json({
                 code: 200,
                 data: {
                   volatility: '-',
                   volatilityInd: '-',
                   beta:'-',
                   perfAnnualisee: '-',
                   perfAnnualiseeInd: '-',
                   info:'-',
                   r2:'-',
                   // skewness,
                   correlation:'-',
                   omega:'-',
                   sortino:'-',
                   calmar:'-',
                   // volatilityInd,
                   maxDrawdown: '-',
                   maxDrawdownInd: '-',
                   dsr:'-',
                   ratioSharpe:'-',
                   // kurtosis,
                   // betaHaussier,
                   // betaBaiss,
                   VAR95: '-',
                   trackingError: '-',
                   VAR99: '-',
                 
                  
                   betaBaiss:'-',
                  
                   // dd: (perfAnnualisee - perfAnnualiseeInd)
                   // delaiRecouvrementInd
                 }
               })
             }*/
        } else if (req.params.year === "5") {
          // Récupérer la dernière date dans la base de données
          const derniereDate = await tsr.max('date', { where: { pays: paysFond } });

          // Calculer la date un an en arrière à partir de la dernière date
          const dateUnAnAvant = new Date(derniereDate);
          dateUnAnAvant.setFullYear(dateUnAnAvant.getFullYear() - 5);

          // Rechercher le taux sans risque le plus proche à la fin du mois un an en arrière
          const tauxSansRisqueUnAnAvant = await tsr.findOne({
            where: {
              date: {
                [Sequelize.Op.lte]: dateUnAnAvant, // Date un an en arrière ou antérieure
                [Sequelize.Op.gte]: new Date(dateUnAnAvant.getFullYear(), dateUnAnAvant.getMonth() + 1, 0) // Dernier jour du mois
              },
              pays: paysFond,
            },
            order: [['date', 'DESC']], // Tri par date décroissante
          });

          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          console.log(donneesarray);
          console.log(donneesGroupéesSS)

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '5_ans': findNearestDatetoyear(dates, 5, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            //  console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            console.log(donneesPeriodesemaine);

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //     if(rendementsTableau['5_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 5, lastPreviousDate)

          const portfolioReturns = rendementsTableau['5_ans']
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], lastValue, 5)
          const benchmarkReturns = rendementsTableauindice['5_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          //    const varindice = calculateVariance([...rendementsTableauindice['5_ans']]);
          //    const cov = calculateCovariance(rendementsTableau['5_ans'], [...rendementsTableauindice['5_ans']])
          const info = calculateInformationRatio([...rendementsTableau['5_ans']], [...rendementsTableauindice['5_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['5_ans']], [...rendementsTableauindicejour['5_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['5_ans']], [...rendementsTableauindicemois['5_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['5_ans'], rendementsTableauindice['5_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['5_ans'], rendementsTableauindicejour['5_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['5_ans'], rendementsTableauindicemois['5_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["5_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["5_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["5_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["5_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["5_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["5_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["5_ans"]], volatilites["5_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["5_ans"]], volatilitesjour["5_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["5_ans"]], volatilitesmois["5_ans"])
          const kurtosis = calculateKurtosis([...rendementsTableau["5_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["5_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["5_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["5_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["5_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["5_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["5_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["5_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["5_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["5_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["5_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["5_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["5_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["5_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["5_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["5_ans"] * 100,
              volatilityjour: volatilitesjour["5_ans"] * 100,
              volatilitymois: volatilitesmois["5_ans"] * 100,
              volatilityInd: volatilitesind["5_ans"] * 100,
              volatilityIndjour: volatilitesindjour["5_ans"] * 100,
              volatilityIndmois: volatilitesindmois["5_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*  }else{
              res.json({
                code: 200,
                data: {
                  volatility: '-',
                  volatilityInd: '-',
                  beta:'-',
                  perfAnnualisee: '-',
                  perfAnnualiseeInd: '-',
                  info:'-',
                  r2:'-',
                  // skewness,
                  correlation:'-',
                  omega:'-',
                  sortino:'-',
                  calmar:'-',
                  // volatilityInd,
                  maxDrawdown: '-',
                  maxDrawdownInd: '-',
                  dsr:'-',
                  ratioSharpe:'-',
                  // kurtosis,
                  // betaHaussier,
                  // betaBaiss,
                  VAR95: '-',
                  trackingError: '-',
                  VAR99: '-',
               
                  betaBaiss:'-',
                  
                  // dd: (perfAnnualisee - perfAnnualiseeInd)
                  // delaiRecouvrementInd
                }
              })
            }*/
        } else if (req.params.year === "8") {
          // Récupérer la dernière date dans la base de données
          const derniereDate = await tsr.max('date', { where: { pays: paysFond } });

          // Calculer la date un an en arrière à partir de la dernière date
          const dateUnAnAvant = new Date(derniereDate);
          dateUnAnAvant.setFullYear(dateUnAnAvant.getFullYear() - 8);

          // Rechercher le taux sans risque le plus proche à la fin du mois un an en arrière
          const tauxSansRisqueUnAnAvant = await tsr.findOne({
            where: {
              date: {
                [Sequelize.Op.lte]: dateUnAnAvant, // Date un an en arrière ou antérieure
                [Sequelize.Op.gte]: new Date(dateUnAnAvant.getFullYear(), dateUnAnAvant.getMonth() + 1, 0) // Dernier jour du mois
              },
              pays: paysFond,
            },
            order: [['date', 'DESC']], // Tri par date décroissante
          });

          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '8_ans': findNearestDatetoyear(dates, 8, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 8, lastPreviousDate)

          const portfolioReturns = rendementsTableau['8_ans']

          const benchmarkReturns = rendementsTableauindice['8_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['8_ans']], [...rendementsTableauindice['8_ans']])
          const beta = calculateBeta(rendementsTableau['8_ans'], rendementsTableauindice['8_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["8_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["8_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["8_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["8_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["8_ans"]], 8)
          const sortino = calculateSortinoRatio([...rendementsTableau["8_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["8_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["8_ans"] * 100,
              volatilityInd: volatilitesind["8_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "10") {
          // Récupérer la dernière date dans la base de données
          const derniereDate = await tsr.max('date', { where: { pays: paysFond } });

          // Calculer la date un an en arrière à partir de la dernière date
          const dateUnAnAvant = new Date(derniereDate);
          dateUnAnAvant.setFullYear(dateUnAnAvant.getFullYear() - 10);

          // Rechercher le taux sans risque le plus proche à la fin du mois un an en arrière
          const tauxSansRisqueUnAnAvant = await tsr.findOne({
            where: {
              date: {
                [Sequelize.Op.lte]: dateUnAnAvant, // Date un an en arrière ou antérieure
                [Sequelize.Op.gte]: new Date(dateUnAnAvant.getFullYear(), dateUnAnAvant.getMonth() + 1, 0) // Dernier jour du mois
              },
              pays: paysFond,
            },
            order: [['date', 'DESC']], // Tri par date décroissante
          });

          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '10_ans': findNearestDatetoyear(dates, 10, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 10, lastPreviousDate)

          const portfolioReturns = rendementsTableau['10_ans']

          const benchmarkReturns = rendementsTableauindice['10_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatiojour([...rendementsTableaujour['10_ans']], [...rendementsTableauindicejour['10_ans']])
          const beta = calculateBeta(rendementsTableau['10_ans'], rendementsTableauindice['10_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["10_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["10_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["10_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["10_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["10_ans"]], 10)
          const sortino = calculateSortinoRatio([...rendementsTableau["10_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["10_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["10_ans"] * 100,
              volatilityInd: volatilitesind["10_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*  betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "12") {
          // Récupérer la dernière date dans la base de données
          const derniereDate = await tsr.max('date', { where: { pays: paysFond } });

          // Calculer la date un an en arrière à partir de la dernière date
          const dateUnAnAvant = new Date(derniereDate);
          dateUnAnAvant.setFullYear(dateUnAnAvant.getFullYear() - 12);

          // Rechercher le taux sans risque le plus proche à la fin du mois un an en arrière
          const tauxSansRisqueUnAnAvant = await tsr.findOne({
            where: {
              date: {
                [Sequelize.Op.lte]: dateUnAnAvant, // Date un an en arrière ou antérieure
                [Sequelize.Op.gte]: new Date(dateUnAnAvant.getFullYear(), dateUnAnAvant.getMonth() + 1, 0) // Dernier jour du mois
              },
              pays: paysFond,
            },
            order: [['date', 'DESC']], // Tri par date décroissante
          });

          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '12_ans': findNearestDatetoyear(dates, 12, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 12, lastPreviousDate)

          const portfolioReturns = rendementsTableau['12_ans']

          const benchmarkReturns = rendementsTableauindice['12_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['12_ans']], [...rendementsTableauindice['12_ans']])
          const beta = calculateBeta(rendementsTableau['12_ans'], rendementsTableauindice['12_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["12_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["12_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["12_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["12_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["12_ans"]], 12)
          const sortino = calculateSortinoRatio([...rendementsTableau["12_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["12_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]], 0)

          //const r2 = quants.linreg([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["12_ans"] * 100,
              volatilityInd: volatilitesind["12_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /* betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "origine") {
          // Récupérer la dernière date dans la base de données
          const derniereDate = await tsr.max('date', { where: { pays: paysFond } });

          // Calculer la date un an en arrière à partir de la dernière date
          const dateUnAnAvant = new Date(derniereDate);
          dateUnAnAvant.setFullYear(dateUnAnAvant.getFullYear() - 1);

          // Rechercher le taux sans risque le plus proche à la fin du mois un an en arrière
          const tauxSansRisqueUnAnAvant = await tsr.findOne({
            where: {
              date: {
                [Sequelize.Op.lte]: dateUnAnAvant, // Date un an en arrière ou antérieure
                [Sequelize.Op.gte]: new Date(dateUnAnAvant.getFullYear(), dateUnAnAvant.getMonth() + 1, 0) // Dernier jour du mois
              },
              pays: paysFond,
            },
            order: [['date', 'DESC']], // Tri par date décroissante
          });

          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {

            'origine': findNearestDatetoyear(dates, 5, endDate)


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const targetYear = groupDatesByYear(dates).length
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[0], targetYear);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[0], targetYear);

          const portfolioReturns = rendementsTableau['origine']

          const benchmarkReturns = rendementsTableauindice['origine'];
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['origine']], [...rendementsTableauindice['origine']])
          const beta = calculateBeta(rendementsTableau['origine'], rendementsTableauindice['origine'])
          const VAR95 = calculateVAR95([...rendementsTableau["origine"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["origine"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["origine"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["origine"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["origine"]], 0)
          const sortino = calculateSortinoRatio([...rendementsTableau["origine"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const trackingError = calculateTrackingError([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["origine"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]]).rsq
          const r2 = calculerR2([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["origine"] * 100,
              volatilityInd: volatilitesind["origine"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              /* delaiRecouvrement,
               betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        }





      })
  })
  //revoir
  app.get('/api/ratiosnewithdate/:year/:id/:date', async (req, res) => {
    try {
      // Récupérer les taux_sans_risques en fonction des valeurs de la table fond
      const tauxSansRisques = await tsr.findAll({
        attributes: ['valeur', 'valeur2', 'semaine', 'rate', 'date', 'pays'],
        where: { pays: "Nigeria" },
      });

      const tableauDonneestsr = tauxSansRisques.map(d => ({
        valeur: d.valeur,
        valeur2: d.valeur2,
        semaine: d.semaine,
        rate: d.rate,
        date: d.date,
        pays: d.pays,
      }));

      const response = await vl.findAll({
        where: {
          fund_id: req.params.id,
          date: { [Op.lte]: req.params.date }
        },
        order: [['date', 'DESC']]
      });

      const tauxsr = -0.0234;
      const values = response.map(data => data.value);
      const dates = response.map(data => moment(data.date).format('YYYY-MM-DD'));
      const valuesindifref = response.map(data => data.indRef);

      const lastPreviousDate = findLastDateOfPreviousMonth(dates);
      const lastValue = values[dates.indexOf(lastPreviousDate)];
      const lastValueInd = valuesindifref[dates.indexOf(lastPreviousDate)];

      const yArrayValuesnew = values.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
      const yArrayDatesnew = dates.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
      const yArrayValuesindifrefnew = valuesindifref.slice(dates.indexOf(lastPreviousDate), dates.length - 1);

      const donneesarray = yArrayValuesnew.map((value, i) => ({ date: yArrayDatesnew[i], value }));
      const donneesarrayindref = yArrayValuesindifrefnew.map((value, i) => ({ date: yArrayDatesnew[i], value }));

      let tauxsrannu = trouverElementLePlusProche(tableauDonneestsr, findNearestDateAnnualized(dates, 1, lastPreviousDate));

      if (req.params.year === "1") {
        handleCalculations(req, res, donneesarray, donneesarrayindref, dates, values, valuesindifref, lastPreviousDate, 1, tableauDonneestsr, tauxsr);
      } else if (req.params.year === "3") {
        handleCalculations(req, res, donneesarray, donneesarrayindref, dates, values, valuesindifref, lastPreviousDate, 3, tableauDonneestsr, tauxsr);
      } else if (req.params.year === "5") {
        handleCalculations(req, res, donneesarray, donneesarrayindref, dates, values, valuesindifref, lastPreviousDate, 5, tableauDonneestsr, tauxsr);
      } else if (req.params.year === "8") {
        handleCalculations(req, res, donneesarray, donneesarrayindref, dates, values, valuesindifref, lastPreviousDate, 8, tableauDonneestsr, tauxsr);
      } else if (req.params.year === "10") {
        handleCalculations(req, res, donneesarray, donneesarrayindref, dates, values, valuesindifref, lastPreviousDate, 10, tableauDonneestsr, tauxsr);
      } else if (req.params.year === "12") {
        handleCalculations(req, res, donneesarray, donneesarrayindref, dates, values, valuesindifref, lastPreviousDate, 12, tableauDonneestsr, tauxsr);
      } else if (req.params.year === "origine") {
        handleCalculations(req, res, donneesarray, donneesarrayindref, dates, values, valuesindifref, lastPreviousDate, groupDatesByYear(dates).length, tableauDonneestsr, tauxsr);
      } else {
        res.status(400).json({ code: 400, message: "Invalid year parameter" });
      }
    } catch (error) {
      console.error('Erreur lors du traitement des ratios:', error);
      res.status(500).json({ code: 500, message: 'Erreur interne du serveur' });
    }
  });

  function handleCalculations(req, res, donneesarray, donneesarrayindref, dates, values, valuesindifref, lastPreviousDate, years, tableauDonneestsr, tauxsr) {
    let rendementsTableau = {};
    let rendementsTableauindice = {};
    let volatilites = {};
    let volatilitesind = {};

    let rendementsTableaujour = {};
    let rendementsTableauindicejour = {};
    let volatilitesjour = {};
    let volatilitesindjour = {};

    let rendementsTableaumois = {};
    let rendementsTableauindicemois = {};
    let volatilitesmois = {};
    let volatilitesindmois = {};
    const periods = {};
    periods[`${years}_ans`] = findNearestDatetoyear(dates, years, lastPreviousDate);
    let Vls = [];
    let Vlsindice = [];
    for (let [periode, dateDebut] of Object.entries(periods)) {

      const donneesPeriodesemaine = grouperParSemaine(donneesarray).filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(lastPreviousDate));
      const donneesPeriodeindicesemaine = grouperParSemaine(donneesarrayindref).filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(lastPreviousDate));

      const donneesPeriodejour = grouperParJour(donneesarray).filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(lastPreviousDate));
      const donneesPeriodeindicejour = grouperParJour(donneesarrayindref).filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(lastPreviousDate));

      const donneesPeriodemois = grouperParMois(donneesarray).filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(lastPreviousDate));
      const donneesPeriodeindicemois = grouperParMois(donneesarrayindref).filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(lastPreviousDate));
      for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
        Vls.push(donneesPeriodejour[i].value)
      }
      for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
        Vlsindice.push(donneesPeriodeindicejour[i].value)
      }
      rendementsTableau[periode] = calculerRendements(donneesPeriodesemaine);
      rendementsTableauindice[periode] = calculerRendements(donneesPeriodeindicesemaine);
      volatilites[periode] = calculerVolatilite(rendementsTableau[periode]);
      volatilitesind[periode] = calculerVolatilite(rendementsTableauindice[periode]);

      rendementsTableaujour[periode] = calculerRendements(donneesPeriodejour);
      rendementsTableauindicejour[periode] = calculerRendements(donneesPeriodeindicejour);
      volatilitesjour[periode] = calculerVolatilitejour(rendementsTableaujour[periode]);
      volatilitesindjour[periode] = calculerVolatilitejour(rendementsTableauindicejour[periode]);

      rendementsTableaumois[periode] = calculerRendements(donneesPeriodemois);
      rendementsTableauindicemois[periode] = calculerRendements(donneesPeriodeindicemois);
      volatilitesmois[periode] = calculerVolatilitemois(rendementsTableaumois[periode]);
      volatilitesindmois[periode] = calculerVolatilitemois(rendementsTableauindicemois[periode]);
    }

    const periode = Object.keys(periods)[0];
    const yDate = findNearestDateAnnualized(dates, parseInt(req.params.year), lastPreviousDate);
    const CAGR = calculerCAGR(values[dates.indexOf(yDate)], values[dates.indexOf(lastPreviousDate)], parseInt(req.params.year));

    const result = {
      volatility: volatilites[periode] * 100,
      volatilityjour: volatilitesjour[periode] * 100,
      volatilitymois: volatilitesmois[periode] * 100,
      volatilityInd: volatilitesind[periode] * 100,
      volatilityIndjour: volatilitesindjour[periode] * 100,
      volatilityIndmois: volatilitesindmois[periode] * 100,
      beta: calculateBetanew(rendementsTableau[periode], rendementsTableauindice[periode]),
      betajour: calculateBetanew(rendementsTableaujour[periode], rendementsTableauindicejour[periode]),
      betamois: calculateBetanew(rendementsTableaumois[periode], rendementsTableauindicemois[periode]),
      perfannu: calculateAnnualizedPerformance(values[dates.indexOf(lastPreviousDate)], values[dates.indexOf(yDate)], parseInt(req.params.year)) * 100,
      CAGR,
      perfannuInd: calculateAnnualizedPerformance(valuesindifref[dates.indexOf(lastPreviousDate)], valuesindifref[dates.indexOf(yDate)], parseInt(req.params.year)) * 100,
      info: calculateInformationRatio(rendementsTableau[periode], rendementsTableauindice[periode]),
      infojour: calculateInformationRatiojour(rendementsTableaujour[periode], rendementsTableauindicejour[periode]),
      infomois: calculateInformationRatio(rendementsTableaumois[periode], rendementsTableauindicemois[periode]),
      r2: calculerR2(rendementsTableau[periode], rendementsTableauindice[periode]),
      r2jour: calculerR2(rendementsTableaujour[periode], rendementsTableauindicejour[periode]),
      r2mois: calculerR2(rendementsTableaumois[periode], rendementsTableauindicemois[periode]),
      correlation: quants.corrcoef(rendementsTableau[periode], rendementsTableauindice[periode], 0),
      correlationjour: quants.corrcoef(rendementsTableaujour[periode], rendementsTableauindicejour[periode], 0),
      correlationmois: quants.corrcoef(rendementsTableaumois[periode], rendementsTableauindicemois[periode], 0),
      omega: calculateOmegaRatio(rendementsTableau[periode], 0),
      omegajour: calculateOmegaRatio(rendementsTableaujour[periode], 0),
      omegamois: calculateOmegaRatio(rendementsTableaumois[periode], 0),
      sortino: calculateSortinoRatio(rendementsTableau[periode], -0.00473, 0.01),
      sortinojour: calculateSortinoRatio(rendementsTableaujour[periode], -0.00473, 0.01),
      sortinomois: calculateSortinoRatio(rendementsTableaumois[periode], -0.00473, 0.01),
      calamar: calculateCalmarRatio(calculateMaxDrawdown(Vls.reverse()), CAGR),
      pertemax: -calculateMaxDrawdown(Vls.reverse()) * 100,
      pertemaxInd: -calculateMaxDrawdown(Vlsindice.reverse()) * 100,
      dsr: calculerDSRAnnualise(rendementsTableau[periode], 0.01),
      dsrjour: calculerDSRAnnualise(rendementsTableaujour[periode], 0.01),
      dsrmois: calculerDSRAnnualise(rendementsTableaumois[periode], 0.01),
      ratiosharpe: (CAGR - tauxsr) / volatilites[periode],
      ratiosharpejour: (CAGR - tauxsr) / volatilitesjour[periode],
      ratiosharpemois: (CAGR - tauxsr) / volatilitesmois[periode],
      trackingerror: calculateTrackingError(rendementsTableau[periode], rendementsTableauindice[periode]) * 100,
      trackingerrorjour: calculateTrackingError(rendementsTableaujour[periode], rendementsTableauindicejour[periode]) * 100,
      trackingerrormois: calculateTrackingError(rendementsTableaumois[periode], rendementsTableauindicemois[periode]) * 100,
      delaiRecouvrement: calculerDelaiRecouvrementFonds(Vls.reverse()),
      betahaussier: calculateHaussierBeta(rendementsTableau[periode], rendementsTableauindice[periode]),
      betahaussierjour: calculateHaussierBeta(rendementsTableaujour[periode], rendementsTableauindicejour[periode]),
      betahaussiermois: calculateHaussierBeta(rendementsTableaumois[periode], rendementsTableauindicemois[periode]),
      betabaissier: calculateDownsideBeta(rendementsTableau[periode], rendementsTableauindice[periode]),
      betabaissierjour: calculateDownsideBeta(rendementsTableaujour[periode], rendementsTableauindicejour[periode]),
      betabaissiermois: calculateDownsideBeta(rendementsTableaumois[periode], rendementsTableauindicemois[periode]),
      upcapture: calculateUpCaptureRatio(rendementsTableau[periode], rendementsTableauindice[periode]),
      upcapturejour: calculateUpCaptureRatio(rendementsTableaujour[periode], rendementsTableauindicejour[periode]),
      upcapturemois: calculateUpCaptureRatio(rendementsTableaumois[periode], rendementsTableauindicemois[periode]),
      downcapture: calculateDownCaptureRatio(rendementsTableau[periode], rendementsTableauindice[periode]),
      downcapturejour: calculateDownCaptureRatio(rendementsTableaujour[periode], rendementsTableauindicejour[periode]),
      downcapturemois: calculateDownCaptureRatio(rendementsTableaumois[periode], rendementsTableauindicemois[periode]),
      skewness: calculerSkewness(rendementsTableau[periode], volatilites[periode]),
      skewnessjour: calculerSkewness(rendementsTableaujour[periode], volatilitesjour[periode]),
      skewnessmois: calculerSkewness(rendementsTableaumois[periode], volatilitesmois[periode]),
      kurtosis: calculateKurtosis(rendementsTableau[periode]),
      kurtosisjour: calculateKurtosis(rendementsTableaujour[periode]),
      kurtosismois: calculateKurtosis(rendementsTableaumois[periode]),
      var95: calculateVAR95(rendementsTableau[periode], 0.95) * 100,
      var95jour: calculateVAR95(rendementsTableaujour[periode], 0.95) * 100,
      var95mois: calculateVAR95(rendementsTableaumois[periode], 0.95) * 100,
      var99: calculateVAR99(rendementsTableau[periode], 0.99) * 100,
      var99jour: calculateVAR99(rendementsTableaujour[periode], 0.99) * 100,
      var99mois: calculateVAR99(rendementsTableaumois[periode], 0.99) * 100
    };

    res.json({ code: 200, data: result });
  }
  ////
  ////////////////////////////////////////////////////
  app.get('/api/ratiosnewithdate1/:year/:id/:date', async (req, res) => {
    // Récupérer les taux_sans_risques en fonction des valeurs de la table fond
    const tauxSansRisques = await tsr.findAll({
      attributes: ['valeur', 'valeur2', 'semaine', 'rate', 'date', 'pays'],
      where: {
        // Ajoutez les conditions spécifiques en fonction de votre logique
        pays: "Nigeria",
      },
    });

    // Tableau pour stocker les résultats
    const tableauDonneestsr = [];

    // Boucle à travers les résultats et stocke les données dans le tableau
    tauxSansRisques.forEach(d => {
      tableauDonneestsr.push({
        valeur: d.valeur,
        valeur2: d.valeur2,
        semaine: d.semaine,
        rate: d.rate,
        date: d.date,
        pays: d.pays,
      });
    });

    await vl.findAll({
      where: {
        fund_id: req.params.id,
        date: { [Op.lte]: req.params.date } // Filtrer les valeurs inférieures ou égales à la date fournie
      },
      order: [
        ['date', 'DESC'] // Modification ici pour trier par date en ordre décroissant
      ]
    })
      .then(async (response) => {
        // const tauxsr=0.03;-0.0116;-0,0234
        const tauxsr = -0.0234;
        // Valeurs liquidatives
        const values = response.map((data) => data.value);
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const tsrValues = response.map((data) => data.tsr);
        const valuesindifref = response.map((data) => data.indRef);


        const lastValue = values[dates.indexOf(findLastDateOfPreviousMonth(dates))];
        const lastValueInd = valuesindifref[dates.indexOf(findLastDateOfPreviousMonth(dates))];


        // Dernière date du mois précédent
        const lastPreviousDate = findLastDateOfPreviousMonth(dates)

        const yArrayValuesnew = values.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayDatesnew = dates.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayValuesindifrefnew = valuesindifref.slice(dates.indexOf(lastPreviousDate), dates.length - 1);

        const donneesarray = [];
        const donneesarrayindref = [];

        for (let i = 0; i < yArrayValuesnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesnew[i];

          donneesarray.push({ date, value });
        }

        for (let i = 0; i < yArrayValuesindifrefnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesindifrefnew[i];

          donneesarrayindref.push({ date, value });
        }


        //  const tauxGroupesParSemaine = grouperTauxParSemaine(tableauDonneestsr);
        /*   tableauDonneestsr.forEach((expObject) => {
       expObject.date = grouperTauxParSemaine(expObject.semaine);
     });*/
        let tauxsrannu = trouverElementLePlusProche(tableauDonneestsr, findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)));

        //si le nombre de rendements de l'indice
        if (req.params.year === "1") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '1_an': findNearestDatetoyear(dates, 1, endDate),

          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSSjour);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;
          }

          if (rendementsTableau['1_an'].length > 0) {

            const yDate = findNearestDateAnnualized(dates, 1, lastPreviousDate)

            const portfolioReturns = rendementsTableau['1_an']

            const benchmarkReturns = rendementsTableauindice['1_an'];
            const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], lastValue, 1)

            //  const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
            //  const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])
            const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
            const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);

            const info = calculateInformationRatio([...rendementsTableau['1_an']], [...rendementsTableauindice['1_an']])
            const infojour = calculateInformationRatiojour([...rendementsTableaujour['1_an']], [...rendementsTableauindicejour['1_an']])
            const infomois = calculateInformationRatio([...rendementsTableaumois['1_an']], [...rendementsTableauindicemois['1_an']])

            // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
            const beta = calculateBetanew(rendementsTableau['1_an'], rendementsTableauindice['1_an'])
            const betajour = calculateBetanew(rendementsTableaujour['1_an'], rendementsTableauindicejour['1_an'])
            const betamois = calculateBetanew(rendementsTableaumois['1_an'], rendementsTableauindicemois['1_an'])

            const VAR95 = calculateVAR95([...rendementsTableau["1_an"]], 0.95);
            const VAR95jour = calculateVAR95([...rendementsTableaujour["1_an"]], 0.95);
            const VAR95mois = calculateVAR95([...rendementsTableaumois["1_an"]], 0.95);

            const VAR99 = calculateVAR99([...rendementsTableau["1_an"]], 0.99)
            const VAR99jour = calculateVAR99([...rendementsTableaujour["1_an"]], 0.99)
            const VAR99mois = calculateVAR99([...rendementsTableaumois["1_an"]], 0.99)

            const skewness = calculerSkewness([...rendementsTableau["1_an"]], volatilites["1_an"])
            const skewnessjour = calculerSkewness([...rendementsTableaujour["1_an"]], volatilitesjour["1_an"])
            const skewnessmois = calculerSkewness([...rendementsTableaumois["1_an"]], volatilitesmois["1_an"])


            const kurtosis = calculateKurtosis([...rendementsTableau["1_an"]])
            const kurtosisjour = calculateKurtosis([...rendementsTableaujour["1_an"]])
            const kurtosismois = calculateKurtosis([...rendementsTableaumois["1_an"]])

            const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
            const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
            const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0.01)
            const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["1_an"]], 0.01)
            const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["1_an"]], 0.01)

            const omega = calculateOmegaRatio([...rendementsTableau["1_an"]], 0);
            const omegajour = calculateOmegaRatio([...rendementsTableaujour["1_an"]], 0);
            const omegamois = calculateOmegaRatio([...rendementsTableaumois["1_an"]], 0);

            const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

            const sortino = calculateSortinoRatio([...rendementsTableau["1_an"]], -0.00473, 0.01);
            const sortinojour = calculateSortinoRatio([...rendementsTableaujour["1_an"]], -0.00473, 0.01);
            const sortinomois = calculateSortinoRatio([...rendementsTableaumois["1_an"]], -0.00473, 0.01);

            const betaBaiss = calculateDownsideBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const betaHaussier = calculateHaussierBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const trackingError = calculateTrackingError([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const trackingErrormois = calculateTrackingError([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            // const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0) 

            const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


            // const ratioSharpe = calculateSharpeRatio(rendementsTableau["1_an"], 0.000751923)
            const ratioSharpe = (CAGR - tauxsr) / volatilites["1_an"];
            const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["1_an"];
            const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["1_an"];

            const correlation = quants.corrcoef([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]], 0)
            const correlationjour = quants.corrcoef([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]], 0)
            const correlationmois = quants.corrcoef([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]], 0)

            // const r2 = quants.linreg([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]]).rsq
            const r2 = calculerR2([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const r2jour = calculerR2([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const r2mois = calculerR2([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])



            res.json({
              code: 200,
              data: {

                volatility: volatilites["1_an"] * 100,
                volatilityjour: volatilitesjour["1_an"] * 100,
                volatilitymois: volatilitesmois["1_an"] * 100,
                volatilityInd: volatilitesind["1_an"] * 100,
                volatilityIndjour: volatilitesindjour["1_an"] * 100,
                volatilityIndmois: volatilitesindmois["1_an"] * 100,
                beta,
                betajour,
                betamois,
                perfAnnualisee: perfAnnualisee * 100,
                CAGR,
                perfAnnualiseeInd: perfAnnualiseeInd * 100,
                info,
                infojour: infojour,
                infomois: infomois,
                r2,
                r2jour,
                r2mois,
                // skewness,
                correlation,
                correlationjour,
                correlationmois,
                omega,
                omegajour,
                omegamois,
                sortino,
                sortinojour,
                sortinomois,
                calmar,

                // volatilityInd,
                maxDrawdown: -maxDrawdown * 100,
                maxDrawdownInd: -maxDrawdownInd * 100,
                dsr,
                dsrjour,
                dsrmois,
                ratioSharpe,
                ratioSharpejour,
                ratioSharpemois,
                // kurtosis,
                // betaHaussier,
                // betaBaiss,
                VAR95: VAR95 * 100,
                VAR95jour: VAR95jour * 100,
                VAR95jour: VAR95mois * 100,
                trackingError: trackingError * 100,
                trackingErrorjour: trackingErrorjour * 100,
                trackingErrorjour: trackingErrormois * 100,

                VAR99: VAR99 * 100,
                VAR99jour: VAR99jour * 100,
                VAR99mois: VAR99mois * 100,

                delaiRecouvrement,
                betaHaussier,
                betaHaussierjour,
                betaHaussiermois,

                betaBaiss,
                betaBaissjour,
                betaBaissmois,

                UpCaptureRatio,
                UpCaptureRatiojour,
                UpCaptureRatiomois,

                DownCaptureRatio,
                DownCaptureRatiojour,
                DownCaptureRatiomois,

                skewness,
                skewnessjour,
                skewnessmois,

                kurtosis,
                kurtosisjour,
                kurtosismois,


                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          } else {
            res.json({
              code: 200,
              data: {
                volatility: '-',
                volatilityInd: '-',
                beta: '-',
                perfAnnualisee: '-',
                perfAnnualiseeInd: '-',
                info: '-',
                r2: '-',
                // skewness,
                correlation: '-',
                omega: '-',
                sortino: '-',
                calmar: '-',
                // volatilityInd,
                maxDrawdown: '-',
                maxDrawdownInd: '-',
                dsr: '-',
                ratioSharpe: '-',
                // kurtosis,
                betaHaussier: '-',
                betaBaiss: '-',
                VAR95: '-',
                trackingError: '-',
                VAR99: '-',
                /* delaiRecouvrement,
                 betaHaussier,*/
                // betaBaiss:'-',
                /*  upCaptureRatio,
                  downCaptureRatio,*/
                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          }
        } else if (req.params.year === "3") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '3_ans': findNearestDatetoyear(dates, 3, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};


          let Vls = [];
          let Vlsindice = [];

          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //   if(rendementsTableau['3_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 3, lastPreviousDate)
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], lastValue, 3)
          const portfolioReturns = rendementsTableau['3_ans']

          const benchmarkReturns = rendementsTableauindice['3_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          //  const varindice = calculateVariance([...rendementsTableauindice['3_ans']]);
          //  const cov = calculateCovariance(rendementsTableau['3_ans'], [...rendementsTableauindice['3_ans']])
          /*
                  const info= calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
                  const infojour= calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          
                  // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
                  const beta=calculateBeta(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
                  const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
                  const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99);
                
                console.log(valuesindifref.slice((dates.indexOf(lastPreviousDate)),dates.indexOf(yDate)  + 1))
                  const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
                  const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
                  const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0)
                  const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
                  const calmar = calculateCalmarRatio(maxDrawdown,CAGR)
                  const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]],-0.00473,  0.01);
                  const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
                  const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
                  const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const delaiRecouvrement=calculerDelaiRecouvrementFonds(Vls.reverse());
          
                  
          
          
                  //const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], -0.00473)
                //  const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
                  const ratioSharpe = (CAGR- tauxsr)/volatilites["3_ans"];
          
                  const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
                  
                 // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
                  const r2 = calculerR2([...rendementsTableau["3_ans"]],[...rendementsTableauindice["3_ans"]])
          */
          const info = calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['3_ans']], [...rendementsTableauindicemois['3_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['3_ans'], rendementsTableauindicejour['3_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['3_ans'], rendementsTableauindicemois['3_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["3_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["3_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["3_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["3_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["3_ans"]], volatilites["3_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["3_ans"]], volatilitesjour["3_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["3_ans"]], volatilitesmois["3_ans"])

          const kurtosis = calculateKurtosis([...rendementsTableau["3_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["3_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["3_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["3_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["3_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["3_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["3_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["3_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["3_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["3_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["3_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["3_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["3_ans"] * 100,
              volatilityjour: volatilitesjour["3_ans"] * 100,
              volatilitymois: volatilitesmois["3_ans"] * 100,
              volatilityInd: volatilitesind["3_ans"] * 100,
              volatilityIndjour: volatilitesindjour["3_ans"] * 100,
              volatilityIndmois: volatilitesindmois["3_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,

              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*   }else{
               res.json({
                 code: 200,
                 data: {
                   volatility: '-',
                   volatilityInd: '-',
                   beta:'-',
                   perfAnnualisee: '-',
                   perfAnnualiseeInd: '-',
                   info:'-',
                   r2:'-',
                   // skewness,
                   correlation:'-',
                   omega:'-',
                   sortino:'-',
                   calmar:'-',
                   // volatilityInd,
                   maxDrawdown: '-',
                   maxDrawdownInd: '-',
                   dsr:'-',
                   ratioSharpe:'-',
                   // kurtosis,
                   // betaHaussier,
                   // betaBaiss,
                   VAR95: '-',
                   trackingError: '-',
                   VAR99: '-',
                 
                  
                   betaBaiss:'-',
                  
                   // dd: (perfAnnualisee - perfAnnualiseeInd)
                   // delaiRecouvrementInd
                 }
               })
             }*/
        } else if (req.params.year === "5") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          console.log(donneesarray);
          console.log(donneesGroupéesSS)

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '5_ans': findNearestDatetoyear(dates, 5, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            //  console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            console.log(donneesPeriodesemaine);

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //     if(rendementsTableau['5_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 5, lastPreviousDate)

          const portfolioReturns = rendementsTableau['5_ans']
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], lastValue, 5)
          const benchmarkReturns = rendementsTableauindice['5_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          //    const varindice = calculateVariance([...rendementsTableauindice['5_ans']]);
          //    const cov = calculateCovariance(rendementsTableau['5_ans'], [...rendementsTableauindice['5_ans']])
          const info = calculateInformationRatio([...rendementsTableau['5_ans']], [...rendementsTableauindice['5_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['5_ans']], [...rendementsTableauindicejour['5_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['5_ans']], [...rendementsTableauindicemois['5_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['5_ans'], rendementsTableauindice['5_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['5_ans'], rendementsTableauindicejour['5_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['5_ans'], rendementsTableauindicemois['5_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["5_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["5_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["5_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["5_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["5_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["5_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["5_ans"]], volatilites["5_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["5_ans"]], volatilitesjour["5_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["5_ans"]], volatilitesmois["5_ans"])
          const kurtosis = calculateKurtosis([...rendementsTableau["5_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["5_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["5_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["5_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["5_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["5_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["5_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["5_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["5_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["5_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["5_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["5_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["5_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["5_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["5_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["5_ans"] * 100,
              volatilityjour: volatilitesjour["5_ans"] * 100,
              volatilitymois: volatilitesmois["5_ans"] * 100,
              volatilityInd: volatilitesind["5_ans"] * 100,
              volatilityIndjour: volatilitesindjour["5_ans"] * 100,
              volatilityIndmois: volatilitesindmois["5_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*  }else{
              res.json({
                code: 200,
                data: {
                  volatility: '-',
                  volatilityInd: '-',
                  beta:'-',
                  perfAnnualisee: '-',
                  perfAnnualiseeInd: '-',
                  info:'-',
                  r2:'-',
                  // skewness,
                  correlation:'-',
                  omega:'-',
                  sortino:'-',
                  calmar:'-',
                  // volatilityInd,
                  maxDrawdown: '-',
                  maxDrawdownInd: '-',
                  dsr:'-',
                  ratioSharpe:'-',
                  // kurtosis,
                  // betaHaussier,
                  // betaBaiss,
                  VAR95: '-',
                  trackingError: '-',
                  VAR99: '-',
               
                  betaBaiss:'-',
                  
                  // dd: (perfAnnualisee - perfAnnualiseeInd)
                  // delaiRecouvrementInd
                }
              })
            }*/
        } else if (req.params.year === "8") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '8_ans': findNearestDatetoyear(dates, 8, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 8, lastPreviousDate)

          const portfolioReturns = rendementsTableau['8_ans']

          const benchmarkReturns = rendementsTableauindice['8_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['8_ans']], [...rendementsTableauindice['8_ans']])
          const beta = calculateBeta(rendementsTableau['8_ans'], rendementsTableauindice['8_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["8_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["8_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["8_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["8_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["8_ans"]], 8)
          const sortino = calculateSortinoRatio([...rendementsTableau["8_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["8_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["8_ans"] * 100,
              volatilityInd: volatilitesind["8_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "10") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '10_ans': findNearestDatetoyear(dates, 10, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 10, lastPreviousDate)

          const portfolioReturns = rendementsTableau['10_ans']

          const benchmarkReturns = rendementsTableauindice['10_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatiojour([...rendementsTableaujour['10_ans']], [...rendementsTableauindicejour['10_ans']])
          const beta = calculateBeta(rendementsTableau['10_ans'], rendementsTableauindice['10_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["10_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["10_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["10_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["10_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["10_ans"]], 10)
          const sortino = calculateSortinoRatio([...rendementsTableau["10_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["10_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["10_ans"] * 100,
              volatilityInd: volatilitesind["10_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*  betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "12") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '12_ans': findNearestDatetoyear(dates, 12, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 12, lastPreviousDate)

          const portfolioReturns = rendementsTableau['12_ans']

          const benchmarkReturns = rendementsTableauindice['12_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['12_ans']], [...rendementsTableauindice['12_ans']])
          const beta = calculateBeta(rendementsTableau['12_ans'], rendementsTableauindice['12_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["12_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["12_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["12_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["12_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["12_ans"]], 12)
          const sortino = calculateSortinoRatio([...rendementsTableau["12_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["12_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]], 0)

          //const r2 = quants.linreg([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["12_ans"] * 100,
              volatilityInd: volatilitesind["12_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /* betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "origine") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {

            'origine': findNearestDatetoyear(dates, 5, endDate)


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const targetYear = groupDatesByYear(dates).length
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[0], targetYear);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[0], targetYear);

          const portfolioReturns = rendementsTableau['origine']

          const benchmarkReturns = rendementsTableauindice['origine'];
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['origine']], [...rendementsTableauindice['origine']])
          const beta = calculateBeta(rendementsTableau['origine'], rendementsTableauindice['origine'])
          const VAR95 = calculateVAR95([...rendementsTableau["origine"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["origine"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["origine"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["origine"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["origine"]], 0)
          const sortino = calculateSortinoRatio([...rendementsTableau["origine"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const trackingError = calculateTrackingError([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["origine"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]]).rsq
          const r2 = calculerR2([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["origine"] * 100,
              volatilityInd: volatilitesind["origine"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              /* delaiRecouvrement,
               betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        }





      })
  })
  ///////////////////////////////////////////////////

  app.get('/api/ratiosnewdev/:year/:id/:devise', async (req, res) => {
    // Récupérer les taux_sans_risques en fonction des valeurs de la table fond
    const tauxSansRisques = await tsr.findAll({
      attributes: ['valeur', 'valeur2', 'semaine', 'rate', 'date', 'pays'],
      where: {
        // Ajoutez les conditions spécifiques en fonction de votre logique
        pays: "Nigeria",
      },
    });

    // Tableau pour stocker les résultats
    const tableauDonneestsr = [];

    // Boucle à travers les résultats et stocke les données dans le tableau
    tauxSansRisques.forEach(d => {
      tableauDonneestsr.push({
        valeur: d.valeur,
        valeur2: d.valeur2,
        semaine: d.semaine,
        rate: d.rate,
        date: d.date,
        pays: d.pays,
      });
    });

    await vl.findAll({
      where: {
        fund_id: req.params.id
      },
      order: [
        ['date', 'DESC'] // Modification ici pour trier par date en ordre décroissant
      ]
    })
      .then(async (response) => {
        // const tauxsr=0.03;-0.0116;-0,0234
        const tauxsr = -0.0234;
        let values;
        // Valeurs liquidatives
        if (req.params.devise == "USD") {
          values = response.map((data) => data.value_USD);
        } else {
          values = response.map((data) => data.value_EUR);

        }
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const tsrValues = response.map((data) => data.tsr);
        const valuesindifref = response.map((data) => data.indRef);
        /* let valuesindifref;
         if (req.params.devise == "USD") {
           valuesindifref = response.map((data) => data.indRef_USD);
         } else {
           valuesindifref = response.map((data) => data.indRef_EUR);
   
         }*/


        const lastValue = values[dates.indexOf(findLastDateOfPreviousMonth(dates))];
        const lastValueInd = valuesindifref[dates.indexOf(findLastDateOfPreviousMonth(dates))];


        // Dernière date du mois précédent
        const lastPreviousDate = findLastDateOfPreviousMonth(dates)

        const yArrayValuesnew = values.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayDatesnew = dates.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayValuesindifrefnew = valuesindifref.slice(dates.indexOf(lastPreviousDate), dates.length - 1);

        const donneesarray = [];
        const donneesarrayindref = [];

        for (let i = 0; i < yArrayValuesnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesnew[i];

          donneesarray.push({ date, value });
        }

        for (let i = 0; i < yArrayValuesindifrefnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesindifrefnew[i];

          donneesarrayindref.push({ date, value });
        }


        //  const tauxGroupesParSemaine = grouperTauxParSemaine(tableauDonneestsr);
        /*   tableauDonneestsr.forEach((expObject) => {
       expObject.date = grouperTauxParSemaine(expObject.semaine);
     });*/
        let tauxsrannu = trouverElementLePlusProche(tableauDonneestsr, findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)));

        //si le nombre de rendements de l'indice
        if (req.params.year === "1") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '1_an': findNearestDatetoyear(dates, 1, endDate),

          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSSjour);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;
          }

          if (rendementsTableau['1_an'].length > 0) {

            const yDate = findNearestDateAnnualized(dates, 1, lastPreviousDate)

            const portfolioReturns = rendementsTableau['1_an']

            const benchmarkReturns = rendementsTableauindice['1_an'];
            const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], lastValue, 1)

            //  const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
            //  const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])
            const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
            const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);

            const info = calculateInformationRatio([...rendementsTableau['1_an']], [...rendementsTableauindice['1_an']])
            const infojour = calculateInformationRatiojour([...rendementsTableaujour['1_an']], [...rendementsTableauindicejour['1_an']])
            const infomois = calculateInformationRatio([...rendementsTableaumois['1_an']], [...rendementsTableauindicemois['1_an']])

            // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
            const beta = calculateBetanew(rendementsTableau['1_an'], rendementsTableauindice['1_an'])
            const betajour = calculateBetanew(rendementsTableaujour['1_an'], rendementsTableauindicejour['1_an'])
            const betamois = calculateBetanew(rendementsTableaumois['1_an'], rendementsTableauindicemois['1_an'])

            const VAR95 = calculateVAR95([...rendementsTableau["1_an"]], 0.95);
            const VAR95jour = calculateVAR95([...rendementsTableaujour["1_an"]], 0.95);
            const VAR95mois = calculateVAR95([...rendementsTableaumois["1_an"]], 0.95);

            const VAR99 = calculateVAR99([...rendementsTableau["1_an"]], 0.99)
            const VAR99jour = calculateVAR99([...rendementsTableaujour["1_an"]], 0.99)
            const VAR99mois = calculateVAR99([...rendementsTableaumois["1_an"]], 0.99)

            const skewness = calculerSkewness([...rendementsTableau["1_an"]], volatilites["1_an"])
            const skewnessjour = calculerSkewness([...rendementsTableaujour["1_an"]], volatilitesjour["1_an"])
            const skewnessmois = calculerSkewness([...rendementsTableaumois["1_an"]], volatilitesmois["1_an"])


            const kurtosis = calculateKurtosis([...rendementsTableau["1_an"]])
            const kurtosisjour = calculateKurtosis([...rendementsTableaujour["1_an"]])
            const kurtosismois = calculateKurtosis([...rendementsTableaumois["1_an"]])

            const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
            const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
            const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0.01)
            const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["1_an"]], 0.01)
            const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["1_an"]], 0.01)

            const omega = calculateOmegaRatio([...rendementsTableau["1_an"]], 0);
            const omegajour = calculateOmegaRatio([...rendementsTableaujour["1_an"]], 0);
            const omegamois = calculateOmegaRatio([...rendementsTableaumois["1_an"]], 0);

            const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

            const sortino = calculateSortinoRatio([...rendementsTableau["1_an"]], -0.00473, 0.01);
            const sortinojour = calculateSortinoRatio([...rendementsTableaujour["1_an"]], -0.00473, 0.01);
            const sortinomois = calculateSortinoRatio([...rendementsTableaumois["1_an"]], -0.00473, 0.01);

            const betaBaiss = calculateDownsideBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const betaHaussier = calculateHaussierBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const trackingError = calculateTrackingError([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const trackingErrormois = calculateTrackingError([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            // const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0) 

            const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


            // const ratioSharpe = calculateSharpeRatio(rendementsTableau["1_an"], 0.000751923)
            const ratioSharpe = (CAGR - tauxsr) / volatilites["1_an"];
            const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["1_an"];
            const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["1_an"];

            const correlation = quants.corrcoef([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]], 0)
            const correlationjour = quants.corrcoef([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]], 0)
            const correlationmois = quants.corrcoef([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]], 0)

            // const r2 = quants.linreg([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]]).rsq
            const r2 = calculerR2([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const r2jour = calculerR2([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const r2mois = calculerR2([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])



            res.json({
              code: 200,
              data: {

                volatility: volatilites["1_an"] * 100,
                volatilityjour: volatilitesjour["1_an"] * 100,
                volatilitymois: volatilitesmois["1_an"] * 100,
                volatilityInd: volatilitesind["1_an"] * 100,
                volatilityIndjour: volatilitesindjour["1_an"] * 100,
                volatilityIndmois: volatilitesindmois["1_an"] * 100,
                beta,
                betajour,
                betamois,
                perfAnnualisee: perfAnnualisee * 100,
                CAGR,
                perfAnnualiseeInd: perfAnnualiseeInd * 100,
                info,
                infojour: infojour,
                infomois: infomois,
                r2,
                r2jour,
                r2mois,
                // skewness,
                correlation,
                correlationjour,
                correlationmois,
                omega,
                omegajour,
                omegamois,
                sortino,
                sortinojour,
                sortinomois,
                calmar,

                // volatilityInd,
                maxDrawdown: -maxDrawdown * 100,
                maxDrawdownInd: -maxDrawdownInd * 100,
                dsr,
                dsrjour,
                dsrmois,
                ratioSharpe,
                ratioSharpejour,
                ratioSharpemois,
                // kurtosis,
                // betaHaussier,
                // betaBaiss,
                VAR95: VAR95 * 100,
                VAR95jour: VAR95jour * 100,
                VAR95jour: VAR95mois * 100,
                trackingError: trackingError * 100,
                trackingErrorjour: trackingErrorjour * 100,
                trackingErrorjour: trackingErrormois * 100,

                VAR99: VAR99 * 100,
                VAR99jour: VAR99jour * 100,
                VAR99mois: VAR99mois * 100,

                delaiRecouvrement,
                betaHaussier,
                betaHaussierjour,
                betaHaussiermois,

                betaBaiss,
                betaBaissjour,
                betaBaissmois,

                UpCaptureRatio,
                UpCaptureRatiojour,
                UpCaptureRatiomois,

                DownCaptureRatio,
                DownCaptureRatiojour,
                DownCaptureRatiomois,

                skewness,
                skewnessjour,
                skewnessmois,

                kurtosis,
                kurtosisjour,
                kurtosismois,


                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          } else {
            res.json({
              code: 200,
              data: {
                volatility: '-',
                volatilityInd: '-',
                beta: '-',
                perfAnnualisee: '-',
                perfAnnualiseeInd: '-',
                info: '-',
                r2: '-',
                // skewness,
                correlation: '-',
                omega: '-',
                sortino: '-',
                calmar: '-',
                // volatilityInd,
                maxDrawdown: '-',
                maxDrawdownInd: '-',
                dsr: '-',
                ratioSharpe: '-',
                // kurtosis,
                betaHaussier: '-',
                betaBaiss: '-',
                VAR95: '-',
                trackingError: '-',
                VAR99: '-',
                /* delaiRecouvrement,
                 betaHaussier,*/
                // betaBaiss:'-',
                /*  upCaptureRatio,
                  downCaptureRatio,*/
                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          }
        } else if (req.params.year === "3") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '3_ans': findNearestDatetoyear(dates, 3, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};


          let Vls = [];
          let Vlsindice = [];

          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //   if(rendementsTableau['3_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 3, lastPreviousDate)
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], lastValue, 3)
          const portfolioReturns = rendementsTableau['3_ans']

          const benchmarkReturns = rendementsTableauindice['3_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          //  const varindice = calculateVariance([...rendementsTableauindice['3_ans']]);
          //  const cov = calculateCovariance(rendementsTableau['3_ans'], [...rendementsTableauindice['3_ans']])
          /*
                  const info= calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
                  const infojour= calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          
                  // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
                  const beta=calculateBeta(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
                  const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
                  const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99);
                
                console.log(valuesindifref.slice((dates.indexOf(lastPreviousDate)),dates.indexOf(yDate)  + 1))
                  const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
                  const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
                  const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0)
                  const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
                  const calmar = calculateCalmarRatio(maxDrawdown,CAGR)
                  const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]],-0.00473,  0.01);
                  const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
                  const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
                  const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const delaiRecouvrement=calculerDelaiRecouvrementFonds(Vls.reverse());
          
                  
          
          
                  //const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], -0.00473)
                //  const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
                  const ratioSharpe = (CAGR- tauxsr)/volatilites["3_ans"];
          
                  const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
                  
                 // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
                  const r2 = calculerR2([...rendementsTableau["3_ans"]],[...rendementsTableauindice["3_ans"]])
          */
          const info = calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['3_ans']], [...rendementsTableauindicemois['3_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['3_ans'], rendementsTableauindicejour['3_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['3_ans'], rendementsTableauindicemois['3_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["3_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["3_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["3_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["3_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["3_ans"]], volatilites["3_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["3_ans"]], volatilitesjour["3_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["3_ans"]], volatilitesmois["3_ans"])

          const kurtosis = calculateKurtosis([...rendementsTableau["3_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["3_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["3_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["3_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["3_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["3_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["3_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["3_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["3_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["3_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["3_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["3_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["3_ans"] * 100,
              volatilityjour: volatilitesjour["3_ans"] * 100,
              volatilitymois: volatilitesmois["3_ans"] * 100,
              volatilityInd: volatilitesind["3_ans"] * 100,
              volatilityIndjour: volatilitesindjour["3_ans"] * 100,
              volatilityIndmois: volatilitesindmois["3_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,

              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*   }else{
               res.json({
                 code: 200,
                 data: {
                   volatility: '-',
                   volatilityInd: '-',
                   beta:'-',
                   perfAnnualisee: '-',
                   perfAnnualiseeInd: '-',
                   info:'-',
                   r2:'-',
                   // skewness,
                   correlation:'-',
                   omega:'-',
                   sortino:'-',
                   calmar:'-',
                   // volatilityInd,
                   maxDrawdown: '-',
                   maxDrawdownInd: '-',
                   dsr:'-',
                   ratioSharpe:'-',
                   // kurtosis,
                   // betaHaussier,
                   // betaBaiss,
                   VAR95: '-',
                   trackingError: '-',
                   VAR99: '-',
                 
                  
                   betaBaiss:'-',
                  
                   // dd: (perfAnnualisee - perfAnnualiseeInd)
                   // delaiRecouvrementInd
                 }
               })
             }*/
        } else if (req.params.year === "5") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          console.log(donneesarray);
          console.log(donneesGroupéesSS)

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '5_ans': findNearestDatetoyear(dates, 5, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            //  console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            console.log(donneesPeriodesemaine);

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //     if(rendementsTableau['5_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 5, lastPreviousDate)

          const portfolioReturns = rendementsTableau['5_ans']
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], lastValue, 5)
          const benchmarkReturns = rendementsTableauindice['5_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          //    const varindice = calculateVariance([...rendementsTableauindice['5_ans']]);
          //    const cov = calculateCovariance(rendementsTableau['5_ans'], [...rendementsTableauindice['5_ans']])
          const info = calculateInformationRatio([...rendementsTableau['5_ans']], [...rendementsTableauindice['5_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['5_ans']], [...rendementsTableauindicejour['5_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['5_ans']], [...rendementsTableauindicemois['5_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['5_ans'], rendementsTableauindice['5_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['5_ans'], rendementsTableauindicejour['5_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['5_ans'], rendementsTableauindicemois['5_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["5_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["5_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["5_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["5_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["5_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["5_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["5_ans"]], volatilites["5_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["5_ans"]], volatilitesjour["5_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["5_ans"]], volatilitesmois["5_ans"])
          const kurtosis = calculateKurtosis([...rendementsTableau["5_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["5_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["5_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["5_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["5_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["5_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["5_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["5_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["5_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["5_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["5_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["5_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["5_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["5_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["5_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["5_ans"] * 100,
              volatilityjour: volatilitesjour["5_ans"] * 100,
              volatilitymois: volatilitesmois["5_ans"] * 100,
              volatilityInd: volatilitesind["5_ans"] * 100,
              volatilityIndjour: volatilitesindjour["5_ans"] * 100,
              volatilityIndmois: volatilitesindmois["5_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*  }else{
              res.json({
                code: 200,
                data: {
                  volatility: '-',
                  volatilityInd: '-',
                  beta:'-',
                  perfAnnualisee: '-',
                  perfAnnualiseeInd: '-',
                  info:'-',
                  r2:'-',
                  // skewness,
                  correlation:'-',
                  omega:'-',
                  sortino:'-',
                  calmar:'-',
                  // volatilityInd,
                  maxDrawdown: '-',
                  maxDrawdownInd: '-',
                  dsr:'-',
                  ratioSharpe:'-',
                  // kurtosis,
                  // betaHaussier,
                  // betaBaiss,
                  VAR95: '-',
                  trackingError: '-',
                  VAR99: '-',
               
                  betaBaiss:'-',
                  
                  // dd: (perfAnnualisee - perfAnnualiseeInd)
                  // delaiRecouvrementInd
                }
              })
            }*/
        } else if (req.params.year === "8") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '8_ans': findNearestDatetoyear(dates, 8, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 8, lastPreviousDate)

          const portfolioReturns = rendementsTableau['8_ans']

          const benchmarkReturns = rendementsTableauindice['8_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['8_ans']], [...rendementsTableauindice['8_ans']])
          const beta = calculateBeta(rendementsTableau['8_ans'], rendementsTableauindice['8_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["8_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["8_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["8_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["8_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["8_ans"]], 8)
          const sortino = calculateSortinoRatio([...rendementsTableau["8_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["8_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["8_ans"] * 100,
              volatilityInd: volatilitesind["8_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "10") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '10_ans': findNearestDatetoyear(dates, 10, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 10, lastPreviousDate)

          const portfolioReturns = rendementsTableau['10_ans']

          const benchmarkReturns = rendementsTableauindice['10_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatiojour([...rendementsTableaujour['10_ans']], [...rendementsTableauindicejour['10_ans']])
          const beta = calculateBeta(rendementsTableau['10_ans'], rendementsTableauindice['10_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["10_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["10_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["10_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["10_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["10_ans"]], 10)
          const sortino = calculateSortinoRatio([...rendementsTableau["10_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["10_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["10_ans"] * 100,
              volatilityInd: volatilitesind["10_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*  betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "12") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '12_ans': findNearestDatetoyear(dates, 12, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 12, lastPreviousDate)

          const portfolioReturns = rendementsTableau['12_ans']

          const benchmarkReturns = rendementsTableauindice['12_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['12_ans']], [...rendementsTableauindice['12_ans']])
          const beta = calculateBeta(rendementsTableau['12_ans'], rendementsTableauindice['12_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["12_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["12_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["12_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["12_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["12_ans"]], 12)
          const sortino = calculateSortinoRatio([...rendementsTableau["12_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["12_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]], 0)

          //const r2 = quants.linreg([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["12_ans"] * 100,
              volatilityInd: volatilitesind["12_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /* betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "origine") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {

            'origine': findNearestDatetoyear(dates, 5, endDate)


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const targetYear = groupDatesByYear(dates).length
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[0], targetYear);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[0], targetYear);

          const portfolioReturns = rendementsTableau['origine']

          const benchmarkReturns = rendementsTableauindice['origine'];
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['origine']], [...rendementsTableauindice['origine']])
          const beta = calculateBeta(rendementsTableau['origine'], rendementsTableauindice['origine'])
          const VAR95 = calculateVAR95([...rendementsTableau["origine"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["origine"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["origine"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["origine"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["origine"]], 0)
          const sortino = calculateSortinoRatio([...rendementsTableau["origine"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const trackingError = calculateTrackingError([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["origine"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]]).rsq
          const r2 = calculerR2([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["origine"] * 100,
              volatilityInd: volatilitesind["origine"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              /* delaiRecouvrement,
               betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        }





      })
  })

  app.get('/api/ratiosnewdevwithdate/:year/:id/:devise/:date', async (req, res) => {
    // Récupérer les taux_sans_risques en fonction des valeurs de la table fond
    const tauxSansRisques = await tsr.findAll({
      attributes: ['valeur', 'valeur2', 'semaine', 'rate', 'date', 'pays'],
      where: {
        // Ajoutez les conditions spécifiques en fonction de votre logique
        pays: "Nigeria",
      },
    });

    // Tableau pour stocker les résultats
    const tableauDonneestsr = [];

    // Boucle à travers les résultats et stocke les données dans le tableau
    tauxSansRisques.forEach(d => {
      tableauDonneestsr.push({
        valeur: d.valeur,
        valeur2: d.valeur2,
        semaine: d.semaine,
        rate: d.rate,
        date: d.date,
        pays: d.pays,
      });
    });

    await vl.findAll({
      where: {
        fund_id: req.params.id,
        date: { [Op.lte]: req.params.date } // Filtrer les valeurs inférieures ou égales à la date fournie
      },
      order: [
        ['date', 'DESC']
      ]
    })
      .then(async (response) => {
        // const tauxsr=0.03;-0.0116;-0,0234
        const tauxsr = -0.0234;
        let values;
        // Valeurs liquidatives
        if (req.params.devise == "USD") {
          values = response.map((data) => data.value_USD);
        } else {
          values = response.map((data) => data.value_EUR);

        }
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const tsrValues = response.map((data) => data.tsr);
        const valuesindifref = response.map((data) => data.indRef);
        /* let valuesindifref;
         if (req.params.devise == "USD") {
           valuesindifref = response.map((data) => data.indRef_USD);
         } else {
           valuesindifref = response.map((data) => data.indRef_EUR);
   
         }*/


        const lastValue = values[dates.indexOf(findLastDateOfPreviousMonth(dates))];
        const lastValueInd = valuesindifref[dates.indexOf(findLastDateOfPreviousMonth(dates))];


        // Dernière date du mois précédent
        const lastPreviousDate = findLastDateOfPreviousMonth(dates)

        const yArrayValuesnew = values.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayDatesnew = dates.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayValuesindifrefnew = valuesindifref.slice(dates.indexOf(lastPreviousDate), dates.length - 1);

        const donneesarray = [];
        const donneesarrayindref = [];

        for (let i = 0; i < yArrayValuesnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesnew[i];

          donneesarray.push({ date, value });
        }

        for (let i = 0; i < yArrayValuesindifrefnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesindifrefnew[i];

          donneesarrayindref.push({ date, value });
        }


        //  const tauxGroupesParSemaine = grouperTauxParSemaine(tableauDonneestsr);
        /*   tableauDonneestsr.forEach((expObject) => {
       expObject.date = grouperTauxParSemaine(expObject.semaine);
     });*/
        let tauxsrannu = trouverElementLePlusProche(tableauDonneestsr, findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)));

        //si le nombre de rendements de l'indice
        if (req.params.year === "1") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '1_an': findNearestDatetoyear(dates, 1, endDate),

          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSSjour);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;
          }

          if (rendementsTableau['1_an'].length > 0) {

            const yDate = findNearestDateAnnualized(dates, 1, lastPreviousDate)

            const portfolioReturns = rendementsTableau['1_an']

            const benchmarkReturns = rendementsTableauindice['1_an'];
            const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], lastValue, 1)

            //  const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
            //  const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])
            const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
            const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);

            const info = calculateInformationRatio([...rendementsTableau['1_an']], [...rendementsTableauindice['1_an']])
            const infojour = calculateInformationRatiojour([...rendementsTableaujour['1_an']], [...rendementsTableauindicejour['1_an']])
            const infomois = calculateInformationRatio([...rendementsTableaumois['1_an']], [...rendementsTableauindicemois['1_an']])

            // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
            const beta = calculateBetanew(rendementsTableau['1_an'], rendementsTableauindice['1_an'])
            const betajour = calculateBetanew(rendementsTableaujour['1_an'], rendementsTableauindicejour['1_an'])
            const betamois = calculateBetanew(rendementsTableaumois['1_an'], rendementsTableauindicemois['1_an'])

            const VAR95 = calculateVAR95([...rendementsTableau["1_an"]], 0.95);
            const VAR95jour = calculateVAR95([...rendementsTableaujour["1_an"]], 0.95);
            const VAR95mois = calculateVAR95([...rendementsTableaumois["1_an"]], 0.95);

            const VAR99 = calculateVAR99([...rendementsTableau["1_an"]], 0.99)
            const VAR99jour = calculateVAR99([...rendementsTableaujour["1_an"]], 0.99)
            const VAR99mois = calculateVAR99([...rendementsTableaumois["1_an"]], 0.99)

            const skewness = calculerSkewness([...rendementsTableau["1_an"]], volatilites["1_an"])
            const skewnessjour = calculerSkewness([...rendementsTableaujour["1_an"]], volatilitesjour["1_an"])
            const skewnessmois = calculerSkewness([...rendementsTableaumois["1_an"]], volatilitesmois["1_an"])


            const kurtosis = calculateKurtosis([...rendementsTableau["1_an"]])
            const kurtosisjour = calculateKurtosis([...rendementsTableaujour["1_an"]])
            const kurtosismois = calculateKurtosis([...rendementsTableaumois["1_an"]])

            const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
            const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
            const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0.01)
            const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["1_an"]], 0.01)
            const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["1_an"]], 0.01)

            const omega = calculateOmegaRatio([...rendementsTableau["1_an"]], 0);
            const omegajour = calculateOmegaRatio([...rendementsTableaujour["1_an"]], 0);
            const omegamois = calculateOmegaRatio([...rendementsTableaumois["1_an"]], 0);

            const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

            const sortino = calculateSortinoRatio([...rendementsTableau["1_an"]], -0.00473, 0.01);
            const sortinojour = calculateSortinoRatio([...rendementsTableaujour["1_an"]], -0.00473, 0.01);
            const sortinomois = calculateSortinoRatio([...rendementsTableaumois["1_an"]], -0.00473, 0.01);

            const betaBaiss = calculateDownsideBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const betaHaussier = calculateHaussierBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const trackingError = calculateTrackingError([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const trackingErrormois = calculateTrackingError([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            // const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0) 

            const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


            // const ratioSharpe = calculateSharpeRatio(rendementsTableau["1_an"], 0.000751923)
            const ratioSharpe = (CAGR - tauxsr) / volatilites["1_an"];
            const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["1_an"];
            const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["1_an"];

            const correlation = quants.corrcoef([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]], 0)
            const correlationjour = quants.corrcoef([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]], 0)
            const correlationmois = quants.corrcoef([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]], 0)

            // const r2 = quants.linreg([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]]).rsq
            const r2 = calculerR2([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const r2jour = calculerR2([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const r2mois = calculerR2([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])



            res.json({
              code: 200,
              data: {

                volatility: volatilites["1_an"] * 100,
                volatilityjour: volatilitesjour["1_an"] * 100,
                volatilitymois: volatilitesmois["1_an"] * 100,
                volatilityInd: volatilitesind["1_an"] * 100,
                volatilityIndjour: volatilitesindjour["1_an"] * 100,
                volatilityIndmois: volatilitesindmois["1_an"] * 100,
                beta,
                betajour,
                betamois,
                perfAnnualisee: perfAnnualisee * 100,
                CAGR,
                perfAnnualiseeInd: perfAnnualiseeInd * 100,
                info,
                infojour: infojour,
                infomois: infomois,
                r2,
                r2jour,
                r2mois,
                // skewness,
                correlation,
                correlationjour,
                correlationmois,
                omega,
                omegajour,
                omegamois,
                sortino,
                sortinojour,
                sortinomois,
                calmar,

                // volatilityInd,
                maxDrawdown: -maxDrawdown * 100,
                maxDrawdownInd: -maxDrawdownInd * 100,
                dsr,
                dsrjour,
                dsrmois,
                ratioSharpe,
                ratioSharpejour,
                ratioSharpemois,
                // kurtosis,
                // betaHaussier,
                // betaBaiss,
                VAR95: VAR95 * 100,
                VAR95jour: VAR95jour * 100,
                VAR95jour: VAR95mois * 100,
                trackingError: trackingError * 100,
                trackingErrorjour: trackingErrorjour * 100,
                trackingErrorjour: trackingErrormois * 100,

                VAR99: VAR99 * 100,
                VAR99jour: VAR99jour * 100,
                VAR99mois: VAR99mois * 100,

                delaiRecouvrement,
                betaHaussier,
                betaHaussierjour,
                betaHaussiermois,

                betaBaiss,
                betaBaissjour,
                betaBaissmois,

                UpCaptureRatio,
                UpCaptureRatiojour,
                UpCaptureRatiomois,

                DownCaptureRatio,
                DownCaptureRatiojour,
                DownCaptureRatiomois,

                skewness,
                skewnessjour,
                skewnessmois,

                kurtosis,
                kurtosisjour,
                kurtosismois,


                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          } else {
            res.json({
              code: 200,
              data: {
                volatility: '-',
                volatilityInd: '-',
                beta: '-',
                perfAnnualisee: '-',
                perfAnnualiseeInd: '-',
                info: '-',
                r2: '-',
                // skewness,
                correlation: '-',
                omega: '-',
                sortino: '-',
                calmar: '-',
                // volatilityInd,
                maxDrawdown: '-',
                maxDrawdownInd: '-',
                dsr: '-',
                ratioSharpe: '-',
                // kurtosis,
                betaHaussier: '-',
                betaBaiss: '-',
                VAR95: '-',
                trackingError: '-',
                VAR99: '-',
                /* delaiRecouvrement,
                 betaHaussier,*/
                // betaBaiss:'-',
                /*  upCaptureRatio,
                  downCaptureRatio,*/
                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          }
        } else if (req.params.year === "3") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '3_ans': findNearestDatetoyear(dates, 3, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};


          let Vls = [];
          let Vlsindice = [];

          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //   if(rendementsTableau['3_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 3, lastPreviousDate)
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], lastValue, 3)
          const portfolioReturns = rendementsTableau['3_ans']

          const benchmarkReturns = rendementsTableauindice['3_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          //  const varindice = calculateVariance([...rendementsTableauindice['3_ans']]);
          //  const cov = calculateCovariance(rendementsTableau['3_ans'], [...rendementsTableauindice['3_ans']])
          /*
                  const info= calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
                  const infojour= calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          
                  // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
                  const beta=calculateBeta(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
                  const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
                  const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99);
                
                console.log(valuesindifref.slice((dates.indexOf(lastPreviousDate)),dates.indexOf(yDate)  + 1))
                  const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
                  const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
                  const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0)
                  const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
                  const calmar = calculateCalmarRatio(maxDrawdown,CAGR)
                  const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]],-0.00473,  0.01);
                  const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
                  const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
                  const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const delaiRecouvrement=calculerDelaiRecouvrementFonds(Vls.reverse());
          
                  
          
          
                  //const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], -0.00473)
                //  const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
                  const ratioSharpe = (CAGR- tauxsr)/volatilites["3_ans"];
          
                  const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
                  
                 // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
                  const r2 = calculerR2([...rendementsTableau["3_ans"]],[...rendementsTableauindice["3_ans"]])
          */
          const info = calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['3_ans']], [...rendementsTableauindicemois['3_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['3_ans'], rendementsTableauindicejour['3_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['3_ans'], rendementsTableauindicemois['3_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["3_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["3_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["3_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["3_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["3_ans"]], volatilites["3_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["3_ans"]], volatilitesjour["3_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["3_ans"]], volatilitesmois["3_ans"])

          const kurtosis = calculateKurtosis([...rendementsTableau["3_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["3_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["3_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["3_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["3_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["3_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["3_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["3_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["3_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["3_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["3_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["3_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["3_ans"] * 100,
              volatilityjour: volatilitesjour["3_ans"] * 100,
              volatilitymois: volatilitesmois["3_ans"] * 100,
              volatilityInd: volatilitesind["3_ans"] * 100,
              volatilityIndjour: volatilitesindjour["3_ans"] * 100,
              volatilityIndmois: volatilitesindmois["3_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,

              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*   }else{
               res.json({
                 code: 200,
                 data: {
                   volatility: '-',
                   volatilityInd: '-',
                   beta:'-',
                   perfAnnualisee: '-',
                   perfAnnualiseeInd: '-',
                   info:'-',
                   r2:'-',
                   // skewness,
                   correlation:'-',
                   omega:'-',
                   sortino:'-',
                   calmar:'-',
                   // volatilityInd,
                   maxDrawdown: '-',
                   maxDrawdownInd: '-',
                   dsr:'-',
                   ratioSharpe:'-',
                   // kurtosis,
                   // betaHaussier,
                   // betaBaiss,
                   VAR95: '-',
                   trackingError: '-',
                   VAR99: '-',
                 
                  
                   betaBaiss:'-',
                  
                   // dd: (perfAnnualisee - perfAnnualiseeInd)
                   // delaiRecouvrementInd
                 }
               })
             }*/
        } else if (req.params.year === "5") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          console.log(donneesarray);
          console.log(donneesGroupéesSS)

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '5_ans': findNearestDatetoyear(dates, 5, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            //  console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            console.log(donneesPeriodesemaine);

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //     if(rendementsTableau['5_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 5, lastPreviousDate)

          const portfolioReturns = rendementsTableau['5_ans']
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], lastValue, 5)
          const benchmarkReturns = rendementsTableauindice['5_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          //    const varindice = calculateVariance([...rendementsTableauindice['5_ans']]);
          //    const cov = calculateCovariance(rendementsTableau['5_ans'], [...rendementsTableauindice['5_ans']])
          const info = calculateInformationRatio([...rendementsTableau['5_ans']], [...rendementsTableauindice['5_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['5_ans']], [...rendementsTableauindicejour['5_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['5_ans']], [...rendementsTableauindicemois['5_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['5_ans'], rendementsTableauindice['5_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['5_ans'], rendementsTableauindicejour['5_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['5_ans'], rendementsTableauindicemois['5_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["5_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["5_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["5_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["5_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["5_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["5_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["5_ans"]], volatilites["5_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["5_ans"]], volatilitesjour["5_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["5_ans"]], volatilitesmois["5_ans"])
          const kurtosis = calculateKurtosis([...rendementsTableau["5_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["5_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["5_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["5_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["5_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["5_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["5_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["5_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["5_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["5_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["5_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["5_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["5_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["5_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["5_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["5_ans"] * 100,
              volatilityjour: volatilitesjour["5_ans"] * 100,
              volatilitymois: volatilitesmois["5_ans"] * 100,
              volatilityInd: volatilitesind["5_ans"] * 100,
              volatilityIndjour: volatilitesindjour["5_ans"] * 100,
              volatilityIndmois: volatilitesindmois["5_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*  }else{
              res.json({
                code: 200,
                data: {
                  volatility: '-',
                  volatilityInd: '-',
                  beta:'-',
                  perfAnnualisee: '-',
                  perfAnnualiseeInd: '-',
                  info:'-',
                  r2:'-',
                  // skewness,
                  correlation:'-',
                  omega:'-',
                  sortino:'-',
                  calmar:'-',
                  // volatilityInd,
                  maxDrawdown: '-',
                  maxDrawdownInd: '-',
                  dsr:'-',
                  ratioSharpe:'-',
                  // kurtosis,
                  // betaHaussier,
                  // betaBaiss,
                  VAR95: '-',
                  trackingError: '-',
                  VAR99: '-',
               
                  betaBaiss:'-',
                  
                  // dd: (perfAnnualisee - perfAnnualiseeInd)
                  // delaiRecouvrementInd
                }
              })
            }*/
        } else if (req.params.year === "8") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '8_ans': findNearestDatetoyear(dates, 8, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 8, lastPreviousDate)

          const portfolioReturns = rendementsTableau['8_ans']

          const benchmarkReturns = rendementsTableauindice['8_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['8_ans']], [...rendementsTableauindice['8_ans']])
          const beta = calculateBeta(rendementsTableau['8_ans'], rendementsTableauindice['8_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["8_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["8_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["8_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["8_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["8_ans"]], 8)
          const sortino = calculateSortinoRatio([...rendementsTableau["8_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["8_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["8_ans"] * 100,
              volatilityInd: volatilitesind["8_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "10") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '10_ans': findNearestDatetoyear(dates, 10, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 10, lastPreviousDate)

          const portfolioReturns = rendementsTableau['10_ans']

          const benchmarkReturns = rendementsTableauindice['10_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatiojour([...rendementsTableaujour['10_ans']], [...rendementsTableauindicejour['10_ans']])
          const beta = calculateBeta(rendementsTableau['10_ans'], rendementsTableauindice['10_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["10_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["10_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["10_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["10_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["10_ans"]], 10)
          const sortino = calculateSortinoRatio([...rendementsTableau["10_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["10_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["10_ans"] * 100,
              volatilityInd: volatilitesind["10_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*  betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "12") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '12_ans': findNearestDatetoyear(dates, 12, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 12, lastPreviousDate)

          const portfolioReturns = rendementsTableau['12_ans']

          const benchmarkReturns = rendementsTableauindice['12_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['12_ans']], [...rendementsTableauindice['12_ans']])
          const beta = calculateBeta(rendementsTableau['12_ans'], rendementsTableauindice['12_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["12_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["12_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["12_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["12_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["12_ans"]], 12)
          const sortino = calculateSortinoRatio([...rendementsTableau["12_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["12_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]], 0)

          //const r2 = quants.linreg([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["12_ans"] * 100,
              volatilityInd: volatilitesind["12_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /* betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "origine") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {

            'origine': findNearestDatetoyear(dates, 5, endDate)


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const targetYear = groupDatesByYear(dates).length
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[0], targetYear);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[0], targetYear);

          const portfolioReturns = rendementsTableau['origine']

          const benchmarkReturns = rendementsTableauindice['origine'];
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['origine']], [...rendementsTableauindice['origine']])
          const beta = calculateBeta(rendementsTableau['origine'], rendementsTableauindice['origine'])
          const VAR95 = calculateVAR95([...rendementsTableau["origine"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["origine"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["origine"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["origine"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["origine"]], 0)
          const sortino = calculateSortinoRatio([...rendementsTableau["origine"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const trackingError = calculateTrackingError([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["origine"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]]).rsq
          const r2 = calculerR2([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["origine"] * 100,
              volatilityInd: volatilitesind["origine"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              /* delaiRecouvrement,
               betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        }





      })
  })


  app.get('/api/ratiosnnnn/:year/:id', async (req, res) => {
    await vl.findAll({
      where: {
        fund_id: req.params.id
      }, order: [
        ['date', 'DESC']
      ]
    })
      .then(async (response) => {
        const values = response.map((data) => data.value);
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'))
        const valuesindifref = response.map((data) => data.indRef)

        const lastPreviousDate = findLastDateOfPreviousMonth(dates)
        const yArrayValuesnew = values.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayDatesnew = dates.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayValuesindifrefnew = valuesindifref.slice(dates.indexOf(lastPreviousDate), dates.length - 1);

        const donneesarray = [];
        const donneesarrayindref = [];

        for (let i = 0; i < yArrayValuesnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesnew[i];

          donneesarray.push({ date, value });
        }
      })
    if (req.params.year === "3") {
      let donneesGroupéesSS = grouperParSemaine(donneesarray)
      let endDate = moment(lastPreviousDate)
      let periods = {
        '3_ans': findNearestDatetoyear(dates, 3, endDate)
      }
      let volatilite = {}
      let rendementsTableau = {};
      for (let [periode, dateDebut] of Object.entries(periods)) {
        let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate))
        let rendementsPeriode = calculerRendements(donneesPeriodesemaine)
        rendementsTableau[periode] = rendementsPeriode;
        volatilites[periode] = calculerVolatilite(rendementsPeriode);
      }

    }
  })
  async function getbase100portefeuilleData(portefeuilleId) {
    try {
      const transactions = await portefeuille_base100.findAll({
        where: {
          portefeuille_id: portefeuilleId
        },
        order: [
          ['date', 'ASC']
        ]
      });
      return transactions;
    } catch (error) {
      throw new Error("Erreur lors de la récupération des transactions : " + error.message);
    }
  }
  async function getTransactionData(portefeuilleId) {
    try {
      const transactions = await transaction.findAll({
        where: {
          portefeuille_id: portefeuilleId
        },
        order: [
          ['date', 'ASC']
        ]
      });
      return transactions;
    } catch (error) {
      throw new Error("Erreur lors de la récupération des transactions : " + error.message);
    }
  }
  app.get('/api/ratiosportefeuille/:year/:id', async (req, res) => {
    // Récupérer les taux_sans_risques en fonction des valeurs de la table fond
    const tauxSansRisques = await tsr.findAll({
      attributes: ['valeur', 'valeur2', 'semaine', 'rate', 'date', 'pays'],
      where: {
        // Ajoutez les conditions spécifiques en fonction de votre logique
        pays: "Nigeria",
      },
    });

    const transactionDatas = await getTransactionData(req.params.id);



    await portefeuille_vl_cumul.findAll({
      where: {
        portefeuille_id: req.params.id
      },
      order: [
        ['date', 'DESC'] // Modification ici pour trier par date en ordre décroissant
      ]
    })
      .then(async (response) => {

        // const tauxsr=0.03;-0.0116;-0,0234
        //const tauxsr = -0.0234;
        const tauxsr = 0.03
        // const tauxacc = -0.00473;
        const tauxacc = 0.02;

        // Valeurs liquidatives
        const values = response.map((data) => data.base_100_bis);
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        //  const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const valuesindifref = response.map((data) => data.base_100_bis);


        const lastValue = values[dates.indexOf(findLastDateOfPreviousMonth(dates))];
        const lastValueInd = valuesindifref[dates.indexOf(findLastDateOfPreviousMonth(dates))];


        // Dernière date du mois précédent
        const lastPreviousDate = findLastDateOfPreviousMonth(dates)

        const yArrayValuesnew = values.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayDatesnew = dates.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayValuesindifrefnew = values.slice(dates.indexOf(lastPreviousDate), dates.length - 1);

        const donneesarray = [];
        const donneesarrayindref = [];

        for (let i = 0; i < yArrayValuesnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesnew[i];

          donneesarray.push({ date, value });
        }

        for (let i = 0; i < yArrayValuesindifrefnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesindifrefnew[i];

          donneesarrayindref.push({ date, value });
        }




        //si le nombre de rendements de l'indice
        if (req.params.year === "1") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '1_an': findNearestDatetoyear(dates, 1, endDate),

          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSSjour);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;
          }

          if (rendementsTableau['1_an'].length > 0) {

            const yDate = findNearestDateAnnualized(dates, 1, lastPreviousDate)

            const portfolioReturns = rendementsTableau['1_an']

            const benchmarkReturns = rendementsTableauindice['1_an'];
            const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], lastValue, 1)

            //  const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
            //  const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])
            const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
            const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);

            const info = calculateInformationRatio([...rendementsTableau['1_an']], [...rendementsTableauindice['1_an']])
            const infojour = calculateInformationRatiojour([...rendementsTableaujour['1_an']], [...rendementsTableauindicejour['1_an']])
            const infomois = calculateInformationRatio([...rendementsTableaumois['1_an']], [...rendementsTableauindicemois['1_an']])

            // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
            const beta = calculateBetanew(rendementsTableau['1_an'], rendementsTableauindice['1_an'])
            const betajour = calculateBetanew(rendementsTableaujour['1_an'], rendementsTableauindicejour['1_an'])
            const betamois = calculateBetanew(rendementsTableaumois['1_an'], rendementsTableauindicemois['1_an'])

            const VAR95 = calculateVAR95([...rendementsTableau["1_an"]], 0.95);
            const VAR95jour = calculateVAR95([...rendementsTableaujour["1_an"]], 0.95);
            const VAR95mois = calculateVAR95([...rendementsTableaumois["1_an"]], 0.95);

            const VAR99 = calculateVAR99([...rendementsTableau["1_an"]], 0.99)
            const VAR99jour = calculateVAR99([...rendementsTableaujour["1_an"]], 0.99)
            const VAR99mois = calculateVAR99([...rendementsTableaumois["1_an"]], 0.99)

            const skewness = calculerSkewness([...rendementsTableau["1_an"]], volatilites["1_an"])
            const skewnessjour = calculerSkewness([...rendementsTableaujour["1_an"]], volatilitesjour["1_an"])
            const skewnessmois = calculerSkewness([...rendementsTableaumois["1_an"]], volatilitesmois["1_an"])


            const kurtosis = calculateKurtosis([...rendementsTableau["1_an"]])
            const kurtosisjour = calculateKurtosis([...rendementsTableaujour["1_an"]])
            const kurtosismois = calculateKurtosis([...rendementsTableaumois["1_an"]])

            const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
            const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
            const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0.01)
            const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["1_an"]], 0.01)
            const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["1_an"]], 0.01)

            const omega = calculateOmegaRatio([...rendementsTableau["1_an"]], 0);
            const omegajour = calculateOmegaRatio([...rendementsTableaujour["1_an"]], 0);
            const omegamois = calculateOmegaRatio([...rendementsTableaumois["1_an"]], 0);

            const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

            const sortino = calculateSortinoRatio([...rendementsTableau["1_an"]], tauxacc, 0.01);
            const sortinojour = calculateSortinoRatio([...rendementsTableaujour["1_an"]], tauxacc, 0.01);
            const sortinomois = calculateSortinoRatio([...rendementsTableaumois["1_an"]], tauxacc, 0.01);

            const betaBaiss = calculateDownsideBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const betaHaussier = calculateHaussierBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const trackingError = calculateTrackingError([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const trackingErrormois = calculateTrackingError([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            // const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0) 

            const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


            // const ratioSharpe = calculateSharpeRatio(rendementsTableau["1_an"], 0.000751923)
            const ratioSharpe = (CAGR - tauxsr) / volatilites["1_an"];
            const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["1_an"];
            const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["1_an"];

            const correlation = quants.corrcoef([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]], 0)
            const correlationjour = quants.corrcoef([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]], 0)
            const correlationmois = quants.corrcoef([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]], 0)

            // const r2 = quants.linreg([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]]).rsq
            const r2 = calculerR2([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const r2jour = calculerR2([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const r2mois = calculerR2([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])



            res.json({
              code: 200,
              data: {

                volatility: volatilites["1_an"] * 100,
                volatilityjour: volatilitesjour["1_an"] * 100,
                volatilitymois: volatilitesmois["1_an"] * 100,
                volatilityInd: volatilitesind["1_an"] * 100,
                volatilityIndjour: volatilitesindjour["1_an"] * 100,
                volatilityIndmois: volatilitesindmois["1_an"] * 100,
                beta,
                betajour,
                betamois,
                perfAnnualisee: perfAnnualisee * 100,
                CAGR,
                perfAnnualiseeInd: perfAnnualiseeInd * 100,
                info,
                infojour: infojour,
                infomois: infomois,
                r2,
                r2jour,
                r2mois,
                // skewness,
                correlation,
                correlationjour,
                correlationmois,
                omega,
                omegajour,
                omegamois,
                sortino,
                sortinojour,
                sortinomois,
                calmar,

                // volatilityInd,
                maxDrawdown: -maxDrawdown * 100,
                maxDrawdownInd: -maxDrawdownInd * 100,
                dsr,
                dsrjour,
                dsrmois,
                ratioSharpe,
                ratioSharpejour,
                ratioSharpemois,
                // kurtosis,
                // betaHaussier,
                // betaBaiss,
                VAR95: VAR95 * 100,
                VAR95jour: VAR95jour * 100,
                VAR95jour: VAR95mois * 100,
                trackingError: trackingError * 100,
                trackingErrorjour: trackingErrorjour * 100,
                trackingErrorjour: trackingErrormois * 100,

                VAR99: VAR99 * 100,
                VAR99jour: VAR99jour * 100,
                VAR99mois: VAR99mois * 100,

                delaiRecouvrement,
                betaHaussier,
                betaHaussierjour,
                betaHaussiermois,

                betaBaiss,
                betaBaissjour,
                betaBaissmois,

                UpCaptureRatio,
                UpCaptureRatiojour,
                UpCaptureRatiomois,

                DownCaptureRatio,
                DownCaptureRatiojour,
                DownCaptureRatiomois,

                skewness,
                skewnessjour,
                skewnessmois,

                kurtosis,
                kurtosisjour,
                kurtosismois,


                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          } else {
            res.json({
              code: 200,
              data: {
                volatility: '-',
                volatilityInd: '-',
                beta: '-',
                perfAnnualisee: '-',
                perfAnnualiseeInd: '-',
                info: '-',
                r2: '-',
                // skewness,
                correlation: '-',
                omega: '-',
                sortino: '-',
                calmar: '-',
                // volatilityInd,
                maxDrawdown: '-',
                maxDrawdownInd: '-',
                dsr: '-',
                ratioSharpe: '-',
                // kurtosis,
                betaHaussier: '-',
                betaBaiss: '-',
                VAR95: '-',
                trackingError: '-',
                VAR99: '-',
                /* delaiRecouvrement,
                 betaHaussier,*/
                // betaBaiss:'-',
                /*  upCaptureRatio,
                  downCaptureRatio,*/
                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          }
        } else if (req.params.year === "3") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '3_ans': findNearestDatetoyear(dates, 3, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};


          let Vls = [];
          let Vlsindice = [];

          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //   if(rendementsTableau['3_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 3, lastPreviousDate)
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], lastValue, 3)
          const portfolioReturns = rendementsTableau['3_ans']

          const benchmarkReturns = rendementsTableauindice['3_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          //  const varindice = calculateVariance([...rendementsTableauindice['3_ans']]);
          //  const cov = calculateCovariance(rendementsTableau['3_ans'], [...rendementsTableauindice['3_ans']])
          /*
                  const info= calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
                  const infojour= calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          
                  // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
                  const beta=calculateBeta(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
                  const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
                  const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99);
                
                console.log(valuesindifref.slice((dates.indexOf(lastPreviousDate)),dates.indexOf(yDate)  + 1))
                  const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
                  const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
                  const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0)
                  const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
                  const calmar = calculateCalmarRatio(maxDrawdown,CAGR)
                  const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]],-0.00473,  0.01);
                  const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
                  const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
                  const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const delaiRecouvrement=calculerDelaiRecouvrementFonds(Vls.reverse());
          
                  
          
          
                  //const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], -0.00473)
                //  const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
                  const ratioSharpe = (CAGR- tauxsr)/volatilites["3_ans"];
          
                  const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
                  
                 // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
                  const r2 = calculerR2([...rendementsTableau["3_ans"]],[...rendementsTableauindice["3_ans"]])
          */
          const info = calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['3_ans']], [...rendementsTableauindicemois['3_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['3_ans'], rendementsTableauindicejour['3_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['3_ans'], rendementsTableauindicemois['3_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["3_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["3_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["3_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["3_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["3_ans"]], volatilites["3_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["3_ans"]], volatilitesjour["3_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["3_ans"]], volatilitesmois["3_ans"])

          const kurtosis = calculateKurtosis([...rendementsTableau["3_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["3_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["3_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["3_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["3_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["3_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["3_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]], tauxacc, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["3_ans"]], tauxacc, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["3_ans"]], tauxacc, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["3_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["3_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["3_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["3_ans"] * 100,
              volatilityjour: volatilitesjour["3_ans"] * 100,
              volatilitymois: volatilitesmois["3_ans"] * 100,
              volatilityInd: volatilitesind["3_ans"] * 100,
              volatilityIndjour: volatilitesindjour["3_ans"] * 100,
              volatilityIndmois: volatilitesindmois["3_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,

              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*   }else{
               res.json({
                 code: 200,
                 data: {
                   volatility: '-',
                   volatilityInd: '-',
                   beta:'-',
                   perfAnnualisee: '-',
                   perfAnnualiseeInd: '-',
                   info:'-',
                   r2:'-',
                   // skewness,
                   correlation:'-',
                   omega:'-',
                   sortino:'-',
                   calmar:'-',
                   // volatilityInd,
                   maxDrawdown: '-',
                   maxDrawdownInd: '-',
                   dsr:'-',
                   ratioSharpe:'-',
                   // kurtosis,
                   // betaHaussier,
                   // betaBaiss,
                   VAR95: '-',
                   trackingError: '-',
                   VAR99: '-',
                 
                  
                   betaBaiss:'-',
                  
                   // dd: (perfAnnualisee - perfAnnualiseeInd)
                   // delaiRecouvrementInd
                 }
               })
             }*/
        } else if (req.params.year === "5") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          console.log(donneesarray);
          console.log(donneesGroupéesSS)

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '5_ans': findNearestDatetoyear(dates, 5, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            //  console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            console.log(donneesPeriodesemaine);

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //     if(rendementsTableau['5_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 5, lastPreviousDate)

          const portfolioReturns = rendementsTableau['5_ans']
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], lastValue, 5)
          const benchmarkReturns = rendementsTableauindice['5_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          //    const varindice = calculateVariance([...rendementsTableauindice['5_ans']]);
          //    const cov = calculateCovariance(rendementsTableau['5_ans'], [...rendementsTableauindice['5_ans']])
          const info = calculateInformationRatio([...rendementsTableau['5_ans']], [...rendementsTableauindice['5_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['5_ans']], [...rendementsTableauindicejour['5_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['5_ans']], [...rendementsTableauindicemois['5_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['5_ans'], rendementsTableauindice['5_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['5_ans'], rendementsTableauindicejour['5_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['5_ans'], rendementsTableauindicemois['5_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["5_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["5_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["5_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["5_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["5_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["5_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["5_ans"]], volatilites["5_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["5_ans"]], volatilitesjour["5_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["5_ans"]], volatilitesmois["5_ans"])
          const kurtosis = calculateKurtosis([...rendementsTableau["5_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["5_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["5_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["5_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["5_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["5_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["5_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["5_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["5_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["5_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["5_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["5_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["5_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["5_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["5_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["5_ans"] * 100,
              volatilityjour: volatilitesjour["5_ans"] * 100,
              volatilitymois: volatilitesmois["5_ans"] * 100,
              volatilityInd: volatilitesind["5_ans"] * 100,
              volatilityIndjour: volatilitesindjour["5_ans"] * 100,
              volatilityIndmois: volatilitesindmois["5_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*  }else{
              res.json({
                code: 200,
                data: {
                  volatility: '-',
                  volatilityInd: '-',
                  beta:'-',
                  perfAnnualisee: '-',
                  perfAnnualiseeInd: '-',
                  info:'-',
                  r2:'-',
                  // skewness,
                  correlation:'-',
                  omega:'-',
                  sortino:'-',
                  calmar:'-',
                  // volatilityInd,
                  maxDrawdown: '-',
                  maxDrawdownInd: '-',
                  dsr:'-',
                  ratioSharpe:'-',
                  // kurtosis,
                  // betaHaussier,
                  // betaBaiss,
                  VAR95: '-',
                  trackingError: '-',
                  VAR99: '-',
               
                  betaBaiss:'-',
                  
                  // dd: (perfAnnualisee - perfAnnualiseeInd)
                  // delaiRecouvrementInd
                }
              })
            }*/
        } else if (req.params.year === "8") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '8_ans': findNearestDatetoyear(dates, 8, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 8, lastPreviousDate)

          const portfolioReturns = rendementsTableau['8_ans']

          const benchmarkReturns = rendementsTableauindice['8_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['8_ans']], [...rendementsTableauindice['8_ans']])
          const beta = calculateBeta(rendementsTableau['8_ans'], rendementsTableauindice['8_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["8_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["8_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["8_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["8_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["8_ans"]], 8)
          const sortino = calculateSortinoRatio([...rendementsTableau["8_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["8_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["8_ans"] * 100,
              volatilityInd: volatilitesind["8_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "10") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '10_ans': findNearestDatetoyear(dates, 10, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 10, lastPreviousDate)

          const portfolioReturns = rendementsTableau['10_ans']

          const benchmarkReturns = rendementsTableauindice['10_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatiojour([...rendementsTableaujour['10_ans']], [...rendementsTableauindicejour['10_ans']])
          const beta = calculateBeta(rendementsTableau['10_ans'], rendementsTableauindice['10_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["10_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["10_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["10_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["10_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["10_ans"]], 10)
          const sortino = calculateSortinoRatio([...rendementsTableau["10_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["10_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["10_ans"] * 100,
              volatilityInd: volatilitesind["10_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*  betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "12") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '12_ans': findNearestDatetoyear(dates, 12, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 12, lastPreviousDate)

          const portfolioReturns = rendementsTableau['12_ans']

          const benchmarkReturns = rendementsTableauindice['12_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['12_ans']], [...rendementsTableauindice['12_ans']])
          const beta = calculateBeta(rendementsTableau['12_ans'], rendementsTableauindice['12_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["12_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["12_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["12_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["12_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["12_ans"]], 12)
          const sortino = calculateSortinoRatio([...rendementsTableau["12_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["12_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]], 0)

          //const r2 = quants.linreg([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["12_ans"] * 100,
              volatilityInd: volatilitesind["12_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /* betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "origine") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {

            'origine': findNearestDatetoyear(dates, 5, endDate)


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const targetYear = groupDatesByYear(dates).length
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[0], targetYear);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[0], targetYear);

          const portfolioReturns = rendementsTableau['origine']

          const benchmarkReturns = rendementsTableauindice['origine'];
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['origine']], [...rendementsTableauindice['origine']])
          const beta = calculateBeta(rendementsTableau['origine'], rendementsTableauindice['origine'])
          const VAR95 = calculateVAR95([...rendementsTableau["origine"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["origine"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["origine"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["origine"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["origine"]], 0)
          const sortino = calculateSortinoRatio([...rendementsTableau["origine"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const trackingError = calculateTrackingError([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["origine"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]]).rsq
          const r2 = calculerR2([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["origine"] * 100,
              volatilityInd: volatilitesind["origine"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              /* delaiRecouvrement,
               betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        }





      })
  })

  app.get('/api/ratiosportefeuilledev/:year/:id/:devise', async (req, res) => {
    // Récupérer les taux_sans_risques en fonction des valeurs de la table fond
    const tauxSansRisques = await tsr.findAll({
      attributes: ['valeur', 'valeur2', 'semaine', 'rate', 'date', 'pays'],
      where: {
        // Ajoutez les conditions spécifiques en fonction de votre logique
        pays: "Nigeria",
      },
    });

    const transactionDatas = await getTransactionData(req.params.id);

    // Tableau pour stocker les résultats
    const tableauDonneestsr = [];

    // Boucle à travers les résultats et stocke les données dans le tableau
    tauxSansRisques.forEach(d => {
      tableauDonneestsr.push({
        valeur: d.valeur,
        valeur2: d.valeur2,
        semaine: d.semaine,
        rate: d.rate,
        date: d.date,
        pays: d.pays,
      });
    });

    await portefeuille_vl_cumul.findAll({
      where: {
        portefeuille_id: req.params.id
      },
      order: [
        ['date', 'DESC'] // Modification ici pour trier par date en ordre décroissant
      ]
    })
      .then(async (response) => {
        let baseProperty;
        if (req.params.devise === 'EUR') {
          baseProperty = 'base_100_bis_EUR';
        } else if (req.params.devise === 'USD') {
          baseProperty = 'base_100_bis_USD';
        } else {
          // Handle other cases or set a default property
          baseProperty = 'base_100_bis';
        }
        // const tauxsr=0.03;-0.0116;-0,0234
        const tauxsr = -0.0234;
        // Valeurs liquidatives
        const values = response.map((data) => data[baseProperty]);
        const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        //  const dates = response.map((data) => moment(data.date).format('YYYY-MM-DD'));
        const valuesindifref = response.map((data) => data[baseProperty]);


        const lastValue = values[dates.indexOf(findLastDateOfPreviousMonth(dates))];
        const lastValueInd = valuesindifref[dates.indexOf(findLastDateOfPreviousMonth(dates))];


        // Dernière date du mois précédent
        const lastPreviousDate = findLastDateOfPreviousMonth(dates)

        const yArrayValuesnew = values.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayDatesnew = dates.slice(dates.indexOf(lastPreviousDate), dates.length - 1);
        const yArrayValuesindifrefnew = values.slice(dates.indexOf(lastPreviousDate), dates.length - 1);

        const donneesarray = [];
        const donneesarrayindref = [];

        for (let i = 0; i < yArrayValuesnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesnew[i];

          donneesarray.push({ date, value });
        }

        for (let i = 0; i < yArrayValuesindifrefnew.length; i++) {
          const date = yArrayDatesnew[i];
          const value = yArrayValuesindifrefnew[i];

          donneesarrayindref.push({ date, value });
        }


        //  const tauxGroupesParSemaine = grouperTauxParSemaine(tableauDonneestsr);
        /*   tableauDonneestsr.forEach((expObject) => {
       expObject.date = grouperTauxParSemaine(expObject.semaine);
     });*/
        let tauxsrannu = trouverElementLePlusProche(tableauDonneestsr, findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)));

        //si le nombre de rendements de l'indice
        if (req.params.year === "1") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '1_an': findNearestDatetoyear(dates, 1, endDate),

          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSSjour);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;
          }

          if (rendementsTableau['1_an'].length > 0) {

            const yDate = findNearestDateAnnualized(dates, 1, lastPreviousDate)

            const portfolioReturns = rendementsTableau['1_an']

            const benchmarkReturns = rendementsTableauindice['1_an'];
            const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], lastValue, 1)

            //  const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
            //  const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])
            const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);
            const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 1, findLastDateOfPreviousMonth(dates)))], 1);

            const info = calculateInformationRatio([...rendementsTableau['1_an']], [...rendementsTableauindice['1_an']])
            const infojour = calculateInformationRatiojour([...rendementsTableaujour['1_an']], [...rendementsTableauindicejour['1_an']])
            const infomois = calculateInformationRatio([...rendementsTableaumois['1_an']], [...rendementsTableauindicemois['1_an']])

            // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
            const beta = calculateBetanew(rendementsTableau['1_an'], rendementsTableauindice['1_an'])
            const betajour = calculateBetanew(rendementsTableaujour['1_an'], rendementsTableauindicejour['1_an'])
            const betamois = calculateBetanew(rendementsTableaumois['1_an'], rendementsTableauindicemois['1_an'])

            const VAR95 = calculateVAR95([...rendementsTableau["1_an"]], 0.95);
            const VAR95jour = calculateVAR95([...rendementsTableaujour["1_an"]], 0.95);
            const VAR95mois = calculateVAR95([...rendementsTableaumois["1_an"]], 0.95);

            const VAR99 = calculateVAR99([...rendementsTableau["1_an"]], 0.99)
            const VAR99jour = calculateVAR99([...rendementsTableaujour["1_an"]], 0.99)
            const VAR99mois = calculateVAR99([...rendementsTableaumois["1_an"]], 0.99)

            const skewness = calculerSkewness([...rendementsTableau["1_an"]], volatilites["1_an"])
            const skewnessjour = calculerSkewness([...rendementsTableaujour["1_an"]], volatilitesjour["1_an"])
            const skewnessmois = calculerSkewness([...rendementsTableaumois["1_an"]], volatilitesmois["1_an"])


            const kurtosis = calculateKurtosis([...rendementsTableau["1_an"]])
            const kurtosisjour = calculateKurtosis([...rendementsTableaujour["1_an"]])
            const kurtosismois = calculateKurtosis([...rendementsTableaumois["1_an"]])

            const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
            const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
            const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0.01)
            const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["1_an"]], 0.01)
            const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["1_an"]], 0.01)

            const omega = calculateOmegaRatio([...rendementsTableau["1_an"]], 0);
            const omegajour = calculateOmegaRatio([...rendementsTableaujour["1_an"]], 0);
            const omegamois = calculateOmegaRatio([...rendementsTableaumois["1_an"]], 0);

            const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

            const sortino = calculateSortinoRatio([...rendementsTableau["1_an"]], -0.00473, 0.01);
            const sortinojour = calculateSortinoRatio([...rendementsTableaujour["1_an"]], -0.00473, 0.01);
            const sortinomois = calculateSortinoRatio([...rendementsTableaumois["1_an"]], -0.00473, 0.01);

            const betaBaiss = calculateDownsideBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const betaHaussier = calculateHaussierBeta([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const trackingError = calculateTrackingError([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const trackingErrormois = calculateTrackingError([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])

            // const dsr = calculerDSRAnnualise([...rendementsTableau["1_an"]], 0) 

            const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


            // const ratioSharpe = calculateSharpeRatio(rendementsTableau["1_an"], 0.000751923)
            const ratioSharpe = (CAGR - tauxsr) / volatilites["1_an"];
            const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["1_an"];
            const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["1_an"];

            const correlation = quants.corrcoef([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]], 0)
            const correlationjour = quants.corrcoef([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]], 0)
            const correlationmois = quants.corrcoef([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]], 0)

            // const r2 = quants.linreg([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]]).rsq
            const r2 = calculerR2([...rendementsTableau["1_an"]], [...rendementsTableauindice["1_an"]])
            const r2jour = calculerR2([...rendementsTableaujour["1_an"]], [...rendementsTableauindicejour["1_an"]])
            const r2mois = calculerR2([...rendementsTableaumois["1_an"]], [...rendementsTableauindicemois["1_an"]])



            res.json({
              code: 200,
              data: {

                volatility: volatilites["1_an"] * 100,
                volatilityjour: volatilitesjour["1_an"] * 100,
                volatilitymois: volatilitesmois["1_an"] * 100,
                volatilityInd: volatilitesind["1_an"] * 100,
                volatilityIndjour: volatilitesindjour["1_an"] * 100,
                volatilityIndmois: volatilitesindmois["1_an"] * 100,
                beta,
                betajour,
                betamois,
                perfAnnualisee: perfAnnualisee * 100,
                CAGR,
                perfAnnualiseeInd: perfAnnualiseeInd * 100,
                info,
                infojour: infojour,
                infomois: infomois,
                r2,
                r2jour,
                r2mois,
                // skewness,
                correlation,
                correlationjour,
                correlationmois,
                omega,
                omegajour,
                omegamois,
                sortino,
                sortinojour,
                sortinomois,
                calmar,

                // volatilityInd,
                maxDrawdown: -maxDrawdown * 100,
                maxDrawdownInd: -maxDrawdownInd * 100,
                dsr,
                dsrjour,
                dsrmois,
                ratioSharpe,
                ratioSharpejour,
                ratioSharpemois,
                // kurtosis,
                // betaHaussier,
                // betaBaiss,
                VAR95: VAR95 * 100,
                VAR95jour: VAR95jour * 100,
                VAR95jour: VAR95mois * 100,
                trackingError: trackingError * 100,
                trackingErrorjour: trackingErrorjour * 100,
                trackingErrorjour: trackingErrormois * 100,

                VAR99: VAR99 * 100,
                VAR99jour: VAR99jour * 100,
                VAR99mois: VAR99mois * 100,

                delaiRecouvrement,
                betaHaussier,
                betaHaussierjour,
                betaHaussiermois,

                betaBaiss,
                betaBaissjour,
                betaBaissmois,

                UpCaptureRatio,
                UpCaptureRatiojour,
                UpCaptureRatiomois,

                DownCaptureRatio,
                DownCaptureRatiojour,
                DownCaptureRatiomois,

                skewness,
                skewnessjour,
                skewnessmois,

                kurtosis,
                kurtosisjour,
                kurtosismois,


                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          } else {
            res.json({
              code: 200,
              data: {
                volatility: '-',
                volatilityInd: '-',
                beta: '-',
                perfAnnualisee: '-',
                perfAnnualiseeInd: '-',
                info: '-',
                r2: '-',
                // skewness,
                correlation: '-',
                omega: '-',
                sortino: '-',
                calmar: '-',
                // volatilityInd,
                maxDrawdown: '-',
                maxDrawdownInd: '-',
                dsr: '-',
                ratioSharpe: '-',
                // kurtosis,
                betaHaussier: '-',
                betaBaiss: '-',
                VAR95: '-',
                trackingError: '-',
                VAR99: '-',
                /* delaiRecouvrement,
                 betaHaussier,*/
                // betaBaiss:'-',
                /*  upCaptureRatio,
                  downCaptureRatio,*/
                // dd: (perfAnnualisee - perfAnnualiseeInd)
                // delaiRecouvrementInd
              }
            })
          }
        } else if (req.params.year === "3") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '3_ans': findNearestDatetoyear(dates, 3, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};


          let Vls = [];
          let Vlsindice = [];

          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //   if(rendementsTableau['3_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 3, lastPreviousDate)
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], lastValue, 3)
          const portfolioReturns = rendementsTableau['3_ans']

          const benchmarkReturns = rendementsTableauindice['3_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 3, findLastDateOfPreviousMonth(dates)))], 3);
          //  const varindice = calculateVariance([...rendementsTableauindice['3_ans']]);
          //  const cov = calculateCovariance(rendementsTableau['3_ans'], [...rendementsTableauindice['3_ans']])
          /*
                  const info= calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
                  const infojour= calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          
                  // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
                  const beta=calculateBeta(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
                  const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
                  const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99);
                
                console.log(valuesindifref.slice((dates.indexOf(lastPreviousDate)),dates.indexOf(yDate)  + 1))
                  const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
                  const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
                  const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0)
                  const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
                  const calmar = calculateCalmarRatio(maxDrawdown,CAGR)
                  const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]],-0.00473,  0.01);
                  const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
                  const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
                  const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]) 
                  const delaiRecouvrement=calculerDelaiRecouvrementFonds(Vls.reverse());
          
                  
          
          
                  //const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], -0.00473)
                //  const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
                  const ratioSharpe = (CAGR- tauxsr)/volatilites["3_ans"];
          
                  const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
                  
                 // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
                  const r2 = calculerR2([...rendementsTableau["3_ans"]],[...rendementsTableauindice["3_ans"]])
          */
          const info = calculateInformationRatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['3_ans']], [...rendementsTableauindicejour['3_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['3_ans']], [...rendementsTableauindicemois['3_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['3_ans'], rendementsTableauindice['3_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['3_ans'], rendementsTableauindicejour['3_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['3_ans'], rendementsTableauindicemois['3_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["3_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["3_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["3_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["3_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["3_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["3_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["3_ans"]], volatilites["3_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["3_ans"]], volatilitesjour["3_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["3_ans"]], volatilitesmois["3_ans"])

          const kurtosis = calculateKurtosis([...rendementsTableau["3_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["3_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["3_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["3_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["3_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["3_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["3_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["3_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["3_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["3_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["3_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["3_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["3_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["3_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["3_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["3_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["3_ans"]], [...rendementsTableauindice["3_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["3_ans"]], [...rendementsTableauindicejour["3_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["3_ans"]], [...rendementsTableauindicemois["3_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["3_ans"] * 100,
              volatilityjour: volatilitesjour["3_ans"] * 100,
              volatilitymois: volatilitesmois["3_ans"] * 100,
              volatilityInd: volatilitesind["3_ans"] * 100,
              volatilityIndjour: volatilitesindjour["3_ans"] * 100,
              volatilityIndmois: volatilitesindmois["3_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,

              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*   }else{
               res.json({
                 code: 200,
                 data: {
                   volatility: '-',
                   volatilityInd: '-',
                   beta:'-',
                   perfAnnualisee: '-',
                   perfAnnualiseeInd: '-',
                   info:'-',
                   r2:'-',
                   // skewness,
                   correlation:'-',
                   omega:'-',
                   sortino:'-',
                   calmar:'-',
                   // volatilityInd,
                   maxDrawdown: '-',
                   maxDrawdownInd: '-',
                   dsr:'-',
                   ratioSharpe:'-',
                   // kurtosis,
                   // betaHaussier,
                   // betaBaiss,
                   VAR95: '-',
                   trackingError: '-',
                   VAR99: '-',
                 
                  
                   betaBaiss:'-',
                  
                   // dd: (perfAnnualisee - perfAnnualiseeInd)
                   // delaiRecouvrementInd
                 }
               })
             }*/
        } else if (req.params.year === "5") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          console.log(donneesarray);
          console.log(donneesGroupéesSS)

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '5_ans': findNearestDatetoyear(dates, 5, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            //  console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            console.log(donneesPeriodesemaine);

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilitejour(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilitejour(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilitemois(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilitemois(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          //     if(rendementsTableau['5_an'].length>0){
          const yDate = findNearestDateAnnualized(dates, 5, lastPreviousDate)

          const portfolioReturns = rendementsTableau['5_ans']
          const CAGR = calculerCAGR(values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], lastValue, 5)
          const benchmarkReturns = rendementsTableauindice['5_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 5, findLastDateOfPreviousMonth(dates)))], 5);
          //    const varindice = calculateVariance([...rendementsTableauindice['5_ans']]);
          //    const cov = calculateCovariance(rendementsTableau['5_ans'], [...rendementsTableauindice['5_ans']])
          const info = calculateInformationRatio([...rendementsTableau['5_ans']], [...rendementsTableauindice['5_ans']])
          const infojour = calculateInformationRatiojour([...rendementsTableaujour['5_ans']], [...rendementsTableauindicejour['5_ans']])
          const infomois = calculateInformationRatiojour([...rendementsTableaumois['5_ans']], [...rendementsTableauindicemois['5_ans']])

          // const info= calculateInformationRationew(portfolioReturns,benchmarkReturns)* Math.sqrt(52);
          const beta = calculateBetanew(rendementsTableau['5_ans'], rendementsTableauindice['5_ans'])
          const betajour = calculateBetanew(rendementsTableaujour['5_ans'], rendementsTableauindicejour['5_ans'])
          const betamois = calculateBetanew(rendementsTableaumois['5_ans'], rendementsTableauindicemois['5_ans'])

          const VAR95 = calculateVAR95([...rendementsTableau["5_ans"]], 0.95);
          const VAR95jour = calculateVAR95([...rendementsTableaujour["5_ans"]], 0.95);
          const VAR95mois = calculateVAR95([...rendementsTableaumois["5_ans"]], 0.95);

          const VAR99 = calculateVAR99([...rendementsTableau["5_ans"]], 0.99)
          const VAR99jour = calculateVAR99([...rendementsTableaujour["5_ans"]], 0.99)
          const VAR99mois = calculateVAR99([...rendementsTableaumois["5_ans"]], 0.99)

          const skewness = calculerSkewness([...rendementsTableau["5_ans"]], volatilites["5_ans"])
          const skewnessjour = calculerSkewness([...rendementsTableaujour["5_ans"]], volatilitesjour["5_ans"])
          const skewnessmois = calculerSkewness([...rendementsTableaumois["5_ans"]], volatilitesmois["5_ans"])
          const kurtosis = calculateKurtosis([...rendementsTableau["5_ans"]])
          const kurtosisjour = calculateKurtosis([...rendementsTableaujour["5_ans"]])
          const kurtosismois = calculateKurtosis([...rendementsTableaumois["5_ans"]])

          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0.01)
          const dsrjour = calculerDSRAnnualise([...rendementsTableaujour["5_ans"]], 0.01)
          const dsrmois = calculerDSRAnnualise([...rendementsTableaumois["5_ans"]], 0.01)

          const omega = calculateOmegaRatio([...rendementsTableau["5_ans"]], 0);
          const omegajour = calculateOmegaRatio([...rendementsTableaujour["5_ans"]], 0);
          const omegamois = calculateOmegaRatio([...rendementsTableaumois["5_ans"]], 0);

          const calmar = calculateCalmarRatio(maxDrawdown, CAGR)

          const sortino = calculateSortinoRatio([...rendementsTableau["5_ans"]], -0.00473, 0.01);
          const sortinojour = calculateSortinoRatio([...rendementsTableaujour["5_ans"]], -0.00473, 0.01);
          const sortinomois = calculateSortinoRatio([...rendementsTableaumois["5_ans"]], -0.00473, 0.01);

          const betaBaiss = calculateDownsideBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaBaissjour = calculateDownsideBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaBaissmois = calculateDownsideBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const betaHaussier = calculateHaussierBeta([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const betaHaussierjour = calculateHaussierBeta([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const betaHaussiermois = calculateHaussierBeta([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const trackingError = calculateTrackingError([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const trackingErrorjour = calculateTrackingError([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const trackingErrormois = calculateTrackingError([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const DownCaptureRatiojour = calculateDownCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const DownCaptureRatiomois = calculateDownCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const UpCaptureRatiojour = calculateUpCaptureRatio([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const UpCaptureRatiomois = calculateUpCaptureRatio([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])

          // const dsr = calculerDSRAnnualise([...rendementsTableau["5_ans"]], 0) 

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());


          // const ratioSharpe = calculateSharpeRatio(rendementsTableau["5_ans"], 0.000751923)
          const ratioSharpe = (CAGR - tauxsr) / volatilites["5_ans"];
          const ratioSharpejour = (CAGR - tauxsr) / volatilitesjour["5_ans"];
          const ratioSharpemois = (CAGR - tauxsr) / volatilitesmois["5_ans"];

          const correlation = quants.corrcoef([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]], 0)
          const correlationjour = quants.corrcoef([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]], 0)
          const correlationmois = quants.corrcoef([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["5_ans"]], [...rendementsTableauindice["5_ans"]])
          const r2jour = calculerR2([...rendementsTableaujour["5_ans"]], [...rendementsTableauindicejour["5_ans"]])
          const r2mois = calculerR2([...rendementsTableaumois["5_ans"]], [...rendementsTableauindicemois["5_ans"]])



          res.json({
            code: 200,
            data: {

              volatility: volatilites["5_ans"] * 100,
              volatilityjour: volatilitesjour["5_ans"] * 100,
              volatilitymois: volatilitesmois["5_ans"] * 100,
              volatilityInd: volatilitesind["5_ans"] * 100,
              volatilityIndjour: volatilitesindjour["5_ans"] * 100,
              volatilityIndmois: volatilitesindmois["5_ans"] * 100,
              beta,
              betajour,
              betamois,
              perfAnnualisee: perfAnnualisee * 100,
              CAGR,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              infojour: infojour,
              infomois: infomois,
              r2,
              r2jour,
              r2mois,
              // skewness,
              correlation,
              correlationjour,
              correlationmois,
              omega,
              omegajour,
              omegamois,
              sortino,
              sortinojour,
              sortinomois,
              calmar,

              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              dsrjour,
              dsrmois,
              ratioSharpe,
              ratioSharpejour,
              ratioSharpemois,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              VAR95jour: VAR95jour * 100,
              VAR95jour: VAR95mois * 100,
              trackingError: trackingError * 100,
              trackingErrorjour: trackingErrorjour * 100,
              trackingErrorjour: trackingErrormois * 100,

              VAR99: VAR99 * 100,
              VAR99jour: VAR99jour * 100,
              VAR99mois: VAR99mois * 100,

              delaiRecouvrement,
              betaHaussier,
              betaHaussierjour,
              betaHaussiermois,

              betaBaiss,
              betaBaissjour,
              betaBaissmois,

              UpCaptureRatio,
              UpCaptureRatiojour,
              UpCaptureRatiomois,

              DownCaptureRatio,
              DownCaptureRatiojour,
              DownCaptureRatiomois,

              skewness,
              skewnessjour,
              skewnessmois,

              kurtosis,
              kurtosisjour,
              kurtosismois,
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
          /*  }else{
              res.json({
                code: 200,
                data: {
                  volatility: '-',
                  volatilityInd: '-',
                  beta:'-',
                  perfAnnualisee: '-',
                  perfAnnualiseeInd: '-',
                  info:'-',
                  r2:'-',
                  // skewness,
                  correlation:'-',
                  omega:'-',
                  sortino:'-',
                  calmar:'-',
                  // volatilityInd,
                  maxDrawdown: '-',
                  maxDrawdownInd: '-',
                  dsr:'-',
                  ratioSharpe:'-',
                  // kurtosis,
                  // betaHaussier,
                  // betaBaiss,
                  VAR95: '-',
                  trackingError: '-',
                  VAR99: '-',
               
                  betaBaiss:'-',
                  
                  // dd: (perfAnnualisee - perfAnnualiseeInd)
                  // delaiRecouvrementInd
                }
              })
            }*/
        } else if (req.params.year === "8") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '8_ans': findNearestDatetoyear(dates, 8, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 8, lastPreviousDate)

          const portfolioReturns = rendementsTableau['8_ans']

          const benchmarkReturns = rendementsTableauindice['8_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 8, findLastDateOfPreviousMonth(dates)))], 8);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['8_ans']], [...rendementsTableauindice['8_ans']])
          const beta = calculateBeta(rendementsTableau['8_ans'], rendementsTableauindice['8_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["8_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["8_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["8_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["8_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["8_ans"]], 8)
          const sortino = calculateSortinoRatio([...rendementsTableau["8_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])
          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["8_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["8_ans"]], [...rendementsTableauindice["8_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["8_ans"] * 100,
              volatilityInd: volatilitesind["8_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "10") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '10_ans': findNearestDatetoyear(dates, 10, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 10, lastPreviousDate)

          const portfolioReturns = rendementsTableau['10_ans']

          const benchmarkReturns = rendementsTableauindice['10_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 10, findLastDateOfPreviousMonth(dates)))], 10);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatiojour([...rendementsTableaujour['10_ans']], [...rendementsTableauindicejour['10_ans']])
          const beta = calculateBeta(rendementsTableau['10_ans'], rendementsTableauindice['10_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["10_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["10_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["10_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["10_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["10_ans"]], 10)
          const sortino = calculateSortinoRatio([...rendementsTableau["10_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["10_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["10_ans"]], [...rendementsTableauindice["10_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["10_ans"] * 100,
              volatilityInd: volatilitesind["10_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /*  betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "12") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {
            '12_ans': findNearestDatetoyear(dates, 12, endDate),


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const yDate = findNearestDateAnnualized(dates, 12, lastPreviousDate)

          const portfolioReturns = rendementsTableau['12_ans']

          const benchmarkReturns = rendementsTableauindice['12_ans'];
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[dates.indexOf(findNearestDateAnnualized(dates, 12, findLastDateOfPreviousMonth(dates)))], 12);
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['12_ans']], [...rendementsTableauindice['12_ans']])
          const beta = calculateBeta(rendementsTableau['12_ans'], rendementsTableauindice['12_ans'])
          const VAR95 = calculateVAR95([...rendementsTableau["12_ans"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["12_ans"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["12_ans"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["12_ans"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["12_ans"]], 12)
          const sortino = calculateSortinoRatio([...rendementsTableau["12_ans"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const trackingError = calculateTrackingError([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])

          const delaiRecouvrement = calculerDelaiRecouvrementFonds(Vls.reverse());



          const ratioSharpe = calculateSharpeRatio(rendementsTableau["12_ans"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]], 0)

          //const r2 = quants.linreg([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]]).rsq
          const r2 = calculerR2([...rendementsTableau["12_ans"]], [...rendementsTableauindice["12_ans"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["12_ans"] * 100,
              volatilityInd: volatilitesind["12_ans"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              delaiRecouvrement,
              /* betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        } else if (req.params.year === "origine") {
          let donneesGroupéesSS = grouperParSemaine(donneesarray);
          let donneesGroupéesindice = grouperParSemaine(donneesarrayindref);

          let donneesGroupéesSSjour = grouperParJour(donneesarray);
          let donneesGroupéesindicejour = grouperParJour(donneesarrayindref);

          let donneesGroupéesSSmois = grouperParMois(donneesarray);
          let donneesGroupéesindicemois = grouperParMois(donneesarrayindref);


          // Calcul de la volatilité pour différentes périodes
          let endDate = moment(lastPreviousDate);
          let periods = {

            'origine': findNearestDatetoyear(dates, 5, endDate)


          };
          let tauxensemainefilte = {};

          let volatilites = {};
          let volatilitesind = {};
          let rendementsTableau = {};
          let rendementsTableauindice = {};

          let volatilitesjour = {};
          let volatilitesindjour = {};
          let rendementsTableaujour = {};
          let rendementsTableauindicejour = {};


          let volatilitesmois = {};
          let volatilitesindmois = {};
          let rendementsTableaumois = {};
          let rendementsTableauindicemois = {};
          let Vls = [];
          let Vlsindice = [];
          for (let [periode, dateDebut] of Object.entries(periods)) {
            console.log(donneesGroupéesSS);

            let donneesPeriodesemaine = donneesGroupéesSS.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicesemaine = donneesGroupéesindice.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            //let donneestauxPeriodesemaine = tableauDonneestsr.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let donneesPeriodejour = donneesGroupéesSSjour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicejour = donneesGroupéesindicejour.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            for (let i = 0; i <= donneesPeriodejour.length - 1; i++) {
              Vls.push(donneesPeriodejour[i].value)
            }
            for (let i = 0; i <= donneesPeriodeindicejour.length - 1; i++) {
              Vlsindice.push(donneesPeriodeindicejour[i].value)
            }
            let donneesPeriodemois = donneesGroupéesSSmois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));
            let donneesPeriodeindicemois = donneesGroupéesindicemois.filter(d => moment(d.date, 'YYYY-MM-DD').isSameOrAfter(dateDebut) && moment(d.date, 'YYYY-MM-DD').isSameOrBefore(endDate));

            let rendementsPeriode = calculerRendements(donneesPeriodesemaine);
            let rendementsPeriodeindice = calculerRendements(donneesPeriodeindicesemaine);
            rendementsTableau[periode] = rendementsPeriode;
            rendementsTableauindice[periode] = rendementsPeriodeindice;

            volatilites[periode] = calculerVolatilite(rendementsPeriode);
            volatilitesind[periode] = calculerVolatilite(rendementsPeriodeindice);

            let rendementsPeriodejour = calculerRendements(donneesPeriodejour);
            let rendementsPeriodeindicejour = calculerRendements(donneesPeriodeindicejour);
            rendementsTableaujour[periode] = rendementsPeriodejour;
            rendementsTableauindicejour[periode] = rendementsPeriodeindicejour;

            volatilitesjour[periode] = calculerVolatilite(rendementsPeriodejour);
            volatilitesindjour[periode] = calculerVolatilite(rendementsPeriodeindicejour);

            let rendementsPeriodemois = calculerRendements(donneesPeriodemois);
            let rendementsPeriodeindicemois = calculerRendements(donneesPeriodeindicemois);
            rendementsTableaumois[periode] = rendementsPeriodemois;
            rendementsTableauindicemois[periode] = rendementsPeriodeindicemois;

            volatilitesmois[periode] = calculerVolatilite(rendementsPeriodemois);
            volatilitesindmois[periode] = calculerVolatilite(rendementsPeriodeindicemois);
            //tauxensemainefilte = donneestauxPeriodesemaine;

          }
          const targetYear = groupDatesByYear(dates).length
          const perfAnnualisee = calculateAnnualizedPerformance(lastValue, values[0], targetYear);
          const perfAnnualiseeInd = calculateAnnualizedPerformance(lastValueInd, valuesindifref[0], targetYear);

          const portfolioReturns = rendementsTableau['origine']

          const benchmarkReturns = rendementsTableauindice['origine'];
          //   const varindice = calculateVariance([...rendementsTableauindice['1_an']]);
          //   const cov = calculateCovariance(rendementsTableau['1_an'], [...rendementsTableauindice['1_an']])

          //const info= quants.inforatio([...rendementsTableau['3_ans']], [...rendementsTableauindice['3_ans']])* Math.sqrt(52)
          const info = calculateInformationRatio([...rendementsTableau['origine']], [...rendementsTableauindice['origine']])
          const beta = calculateBeta(rendementsTableau['origine'], rendementsTableauindice['origine'])
          const VAR95 = calculateVAR95([...rendementsTableau["origine"]], 0.95);
          const VAR99 = calculateVAR99([...rendementsTableau["origine"]], 0.99)
          const maxDrawdown = calculateMaxDrawdown(Vls.reverse())
          const maxDrawdownInd = calculateMaxDrawdown(Vlsindice.reverse())
          const dsr = calculerDSRAnnualise([...rendementsTableau["origine"]], 0.01)
          const omega = calculateOmegaRatio([...rendementsTableau["origine"]], 0);
          const calmar = calculateCalmarRatio([...rendementsTableau["origine"]], 0)
          const sortino = calculateSortinoRatio([...rendementsTableau["origine"]], -0.00473, 0.01);
          const betaBaiss = calculateDownsideBeta([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const trackingError = calculateTrackingError([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const DownCaptureRatio = calculateDownCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])
          const UpCaptureRatio = calculateUpCaptureRatio([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])




          const ratioSharpe = calculateSharpeRatio(rendementsTableau["origine"], -0.00473)
          const correlation = quants.corrcoef([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]], 0)

          // const r2 = quants.linreg([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]]).rsq
          const r2 = calculerR2([...rendementsTableau["origine"]], [...rendementsTableauindice["origine"]])


          console.log(beta);

          res.json({
            code: 200,
            data: {
              volatility: volatilites["origine"] * 100,
              volatilityInd: volatilitesind["origine"] * 100,
              beta,
              perfAnnualisee: perfAnnualisee * 100,
              perfAnnualiseeInd: perfAnnualiseeInd * 100,
              info,
              r2,
              // skewness,
              correlation,
              omega,
              sortino,
              calmar,
              // volatilityInd,
              maxDrawdown: -maxDrawdown * 100,
              maxDrawdownInd: -maxDrawdownInd * 100,
              dsr,
              ratioSharpe,
              // kurtosis,
              // betaHaussier,
              // betaBaiss,
              VAR95: VAR95 * 100,
              trackingError: trackingError * 100,
              VAR99: VAR99 * 100,
              /* delaiRecouvrement,
               betaHaussier,*/
              betaBaiss,
              /*  upCaptureRatio,
                downCaptureRatio,*/
              // dd: (perfAnnualisee - perfAnnualiseeInd)
              // delaiRecouvrementInd
            }
          })
        }





      })
  })



  app.get('/api/robotadvisor/fonds', async (req, res) => {
    const ids = req.query.ids.split(',');
    const fundIds = ids; // Séparer les IDs des fonds par une virgule
    var PortfolioAllocation = require('portfolio-allocation');
    const formdata = req.params.formData;
    var minWeight = [];
    var maxWeight = []
    if (req.query.minweight) {
      minWeight = JSON.parse(req.query.minweight);
      maxWeight = JSON.parse(req.query.maxweight);
    }

    const minReturn = req.query.minReturn / 100;
    const maxReturn = req.query.maxReturn / 100;
    const minVolatility = req.query.minVolatility / 100;
    const maxVolatility = req.query.maxVolatility / 100;

    // const totalInvestment = 100000;
    try {
      // Obtenir l'historique de chaque fond et trouver les dates communes
      const fundData = await Promise.all(
        fundIds.map(async fundId => {
          const data = await vl.findAll({
            where: {
              fund_id: fundId
            },
            order: [
              ['date', 'ASC']
            ]
          });
          return {
            fundId,
            data
          };
        })
      );

      // Trouver l'ensemble commun de dates
      const commonDates = findCommonDates(fundData.map(entry => entry.data));
      // Filtrer les dates pour s'assurer qu'elles sont entre le 1er janvier et le 31 décembre

      // Filtrer les données pour inclure uniquement les dates communes
      const filteredData = fundData.map(entry => {
        const filteredValues = entry.data.filter(row => commonDates.includes(moment(row.date).format('YYYY-MM-DD')));
        return {
          fundId: entry.fundId,
          values: filteredValues.map(row => row.value)
        };
      });
      // Calculer les rendements pour chaque fond
      const returnsData = filteredData.map(entry => {
        const values = entry.values;
        const ArrayDates = groupDatesByYear(commonDates);
        const adaptValues = adaptValuesToGroupedYears(values, ArrayDates);
        const adaptValues1 = AdaptTableauwithdate(adaptValues, ArrayDates);
        // const valueYearArray = adaptValues1.map((entry) => Object.values(entry)[0].map((data) => data[2]));
        return {
          fundId: entry.fundId,
          returns: adaptValues1
        };
      });
      const ddd = returnsData.map(entry => entry.returns);
      // const filteredDdd = ddd.map(subArray => subArray.filter(value => value.length == 12)); 
      //const filteredDdd = ddd;
      // Calcul des performances glissantes
      const extraireRendements = ddd.map(fond => {
        return fond.map(anneeData => anneeData[2]);
      });
      const tableauConcatené = extraireRendements.map((sousTableau) => {
        // Appliquer un flatMap sur chaque sous-tableau
        return sousTableau.flatMap((element) => element);
      });
      console.log(tableauConcatené);
      const tableauTransformé = [];
      for (let i = 0; i < tableauConcatené[0].length; i++) {
        const colonne = [];
        for (let j = 0; j < tableauConcatené.length; j++) {
          colonne.push(tableauConcatené[j][i]);
        }
        tableauTransformé.push(colonne);
      }


      const minnestedArray = [];
      for (let i = 0; i < fundIds.length; i++) {
        minnestedArray.push(minReturn);
      }
      const maxnestedArray = [];
      for (let i = 0; i < fundIds.length; i++) {
        maxnestedArray.push(maxReturn);
      }
      const meanReturns = PortfolioAllocation.meanVector(tableauConcatené);
      const covMatrix = PortfolioAllocation.covarianceMatrix(tableauConcatené);
      var opt = {}
      if (minWeight.length > 0) {
        opt = {
          discretizationType: 'volatility',
          nbPortfolios: 1000,
          optimizationMethod: 'automatic',
          constraints: {
            minWeights: minWeight,// exemple
            maxWeights: maxWeight, // exemple

          }
        };
      } else {
        opt = {
          discretizationType: 'volatility',
          nbPortfolios: 1000,
          optimizationMethod: 'automatic',

        };
      }

      const portfolios = PortfolioAllocation.meanVarianceEfficientFrontierPortfolios(meanReturns, covMatrix, opt
      );
      console.log(portfolios)
      // Filtrer les portefeuilles en fonction des contraintes
      const filteredPortfolios = portfolios.filter(portfolio => {
        const portfolioReturn = portfolio[1];
        const portfolioVolatility = portfolio[2];
        return portfolioReturn >= minReturn && portfolioReturn <= maxReturn &&
          portfolioVolatility >= minVolatility && portfolioVolatility <= maxVolatility;
      });

      // Affichage des portefeuilles efficients filtrés
      console.log("Portefeuilles efficients filtrés :");
      filteredPortfolios.forEach((portfolio, index) => {
        console.log(`Portefeuille ${index + 1}:`);
        console.log("Poids:", portfolio[0]);
        console.log("Rendement:", portfolio[1]);
        console.log("Volatilité:", portfolio[2]);
        console.log("------------");
      });

      /*
              // Calcul de la matrice de covariance des rendements des actifs
              const covMatrix = PortfolioAllocation.covarianceMatrix(tableauTransformé);
              const meanReturns = PortfolioAllocation.meanVector(tableauTransformé);
      
              // Vous pouvez continuer avec le reste de votre code ici...
        
              // Afficher les résultats
              console.log('La matrice de covariance des rendements des actifs est :');
              console.log(covMatrix);
              //var targetReturn = 0.02; // Rendement attendu de 2% par mois
             // var weights = PortfolioAllocation.proportionalMinimumVarianceWeights(covMatrix, targetReturn);
              // Calculer les poids optimaux du portefeuille qui minimise la variance
              // var weights = PortfolioAllocation.globalMinimumVarianceWeights(covMatrix);
              const weights = PortfolioAllocation.meanVarianceOptimizationWeights(meanReturns,covMatrix, {
                constraints: {
                 // return:targetReturn,
                  maxVolatility: maxVolatility
                },
              }).weights;
      
              let investmentAmounts = calculateInvestmentAmounts(weights, totalInvestment);
      
              // Afficher les résultats
              console.log('Les poids optimaux du portefeuille sont :');
              for (var i = 0; i < fundIds.length; i++) {
                  console.log(fundIds[i] + ' : ' + weights[i]);
              }*/


      res.json({
        code: 200,
        data: {
          filteredPortfolios: filteredPortfolios,
          //  investmentAmounts:investmentAmounts
          // Ajoutez d'autres données si nécessaire
        }
      });
    } catch (error) {
      res.status(500).json({
        code: 500,
        message: 'Une erreur s\'est produite lors du traitement de la demande.',
        error: error.message
      });
    }
  });

  app.get('/api/roboadvisorsetvalue', async (req, res) => {
    try {
      const { date, montantinvest, fundids, portefeuilleselect, poids } = req.query;
      const poidsfond = poids.split(',');
      const fondids = fundids.split(',');


      for (const fond of fondids) {
        const index = fondids.indexOf(fond);

        // Rechercher la valeur du fond pour la date spécifiée
        let vls = await vl.findAll({
          where: {
            fund_id: fond, date: {
              [Op.gte]: date // Remplacez 'votreDate' par la date que vous souhaitez comparer.
            }
          }
        });


        // Récupérer toutes les dates dans la table vl_fond
        //  const toutesLesDates = await Fond.findAll({ attributes: ['date'] });

        // Calculer la valorisation pour chaque date à partir de la date spécifiée
        const valorisations = [];
        const quantite = (montantinvest * poidsfond[index]) / vls[0].value;
        for (const dateRow of vls) {

          const valorisation = quantite * dateRow.value;
          valorisations.push({ date: dateRow.date, value: valorisation, fund_id: fond, portefeuille_id: portefeuilleselect });

        }

        // Insérer les nouvelles valorisations dans la table vl_portefeuille
        await portefeuilles_proposes_vls.bulkCreate(valorisations);
      }
      const updatedData = {
        poidsportefeuille: poidsfond
      };

      // Assuming 'portefeuille' is your model for updating data in your database
      await portefeuille.update(updatedData, {
        where: { id: portefeuilleselect },
      });
      return res.json({ code: 200, data: "Succes" });
    } catch (error) {
      console.error(error);
      res.status(500).json({ error: "Erreur lors du calcul de la valorisation" });
    }
  });

  app.post('/api/postportefeuillepropose', async (req, res) => {
    try {
      const { portfolios } = req.body;

      // Loop through portfolios to insert each one
      for (const portfolio of portfolios) {
        const { poids, fond, simulation_id, portefeuille_id, nom } = portfolio;

        await simulationportefeuille.create({
          poids: poids.toString(), // Convertir poids en chaîne de caractères
          fond_ids: fond,
          nom,
          simulation_id,
          portefeuille_id // Assuming this is auto-incremented by your database
        });
      }

      // Respond with a success message
      res.status(200).json({ message: 'Données insérées avec succès' });
    } catch (error) {
      // Handle errors
      console.error('Erreur lors de l\'insertion en base de données :', error);
      res.status(500).json({ message: 'Erreur lors de l\'insertion en base de données' });
    }
  });

  app.get('/api/getsimulationportefeuillebyuser/:id', async (req, res) => {
    simulationportefeuille.findAll({
      where: {
        simulation_id: req.params.id

      },
      order: [
        ['id', 'ASC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const simulations = response.map(data => ({
          id: data.portefeuille_id,
          poids: data.poids, // Remplacez avec la propriété correcte de l'objet
          nom: data.nom,
          fond_ids: data.fond_ids


        }));
        res.json({
          code: 200,
          data: {
            simulations,
            //  valorisation

          }
        })

      })
  })

  app.get('/api/rendement/fonds', async (req, res) => {
    const { categorie, ids } = req.query;
    let whereClause = {};

    if (categorie) {
      const categories = categorie.split(',').map(id => id); // Convertir les IDs en entiers

      whereClause = { categorie_globale: { [Op.in]: categories } };
    } else if (ids) {
      const fundIds = ids.split(',').map(id => parseInt(id, 10)); // Convertir les IDs en entiers
      whereClause = { id: { [Op.in]: fundIds } };
    }

    try {
      const fundData = await fond.findAll({
        where: whereClause,
        attributes: ['nom_fond', 'id', 'categorie_globale', 'periodicite', 'pays'], // Ajustez les attributs ici
        include: [
          {
            model: rendement,
            attributes: ['id', 'date', 'fond_id', 'rendement_semaine', 'rendement_mensuel'], // Ajustez les attributs ici
            order: [['date', 'ASC']]
          }
        ]
      });

      // Vérifier la périodicité
      let periodicite = 'Journalière';
      const isHebdomadaire = fundData.some(fund => fund.periodicite === 'Hebdomadaire');
      if (isHebdomadaire) {
        periodicite = 'Hebdomadaire';
      }

      const formattedData = fundData.map(fund => ({
        nom_fond: fund.nom_fond,
        idfond: fund.id,
        categorie: fund.categorie_globale,
        pays: fund.pays,
        rendements: fund.rendements.map(rendement => ({
          date: rendement.date,
          rendement_semaine: rendement.rendement_semaine,
          rendement_mensuel: rendement.rendement_mensuel
        }))
      }));

      res.json({
        code: 200,
        data: {
          fonds: formattedData,
          periodicite: periodicite
        }
      });
    } catch (error) {
      res.status(500).json({
        code: 500,
        message: 'Une erreur s\'est produite lors du traitement de la demande.',
        error: error.message
      });
    }
  });


// Fonction pour calculer les rendements quotidiens
async function calculatejourReturns(fundId) {
  const vlData = await vl.findAll({
    where: {
      fund_id: fundId,
      date: {
        [Op.between]: ['2023-01-01', '2023-12-31']
      }
    },
    order: [['date', 'ASC']],
    attributes: ['date', 'value']
  });

  const dailyReturns = vlData.map((vl, index) => {
    if (index === 0) return null; // Pas de rendement pour le premier jour
    const previousValue = vlData[index - 1].value;
    const currentValue = vl.value;
    const dailyReturn = (currentValue - previousValue) / previousValue;
    return {
      date: vl.date,
      rendement_jour: dailyReturn,
      fond_id: fundId
    };
  }).filter(rendement => rendement !== null);

  return dailyReturns;
}

// Fonction pour insérer les rendements dans la base de données
async function insertRendements(rendements) {
  try {
    await rendement.bulkCreate(rendements);
  } catch (error) {
    console.error('Error inserting rendements:', error);
    throw error;
  }
}
app.get('/api/saverendementsjour', async (req, res) => {

  try {
    const fonds = await vl.findAll({
        attributes: ['fund_id'],
        group: ['fund_id']
      });

      // Traiter chaque fonds de manière séquentielle
    for (const fund of fonds) {
      const fundId = fund.fund_id;

      // Calculer les rendements pour ce fonds
      const dailyReturns = await calculatejourReturns(fundId);

      // Insérer les rendements dans la base de données
      await insertRendements(dailyReturns);
    }

    res.status(200).json({ message: 'Rendements calculés et insérés avec succès' });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors du calcul ou de l\'insertion des rendements', error });
  }
});

  app.get('/api/saverendements', async (req, res) => {
    try {
      const fonds = await vl.findAll({
        attributes: ['fund_id'],
        group: ['fund_id']
      });

      for (const fund of fonds) {
        const fundId = fund.fund_id;
        const valorisations = await vl.findAll({
          where: { fund_id: fundId },
          order: [['date', 'ASC']]
        });

        let weeklyValues = {};
        let monthlyValues = {};
        valorisations.forEach((v) => {
          const date = moment(v.date);
          const week = date.isoWeek().toString().padStart(2, '0');
          const year = date.year();
          const month = (date.month() + 1).toString().padStart(2, '0'); // +1 pour obtenir le mois en format 1-12

          weeklyValues[`${year}_W${week}`] = v.value;
          monthlyValues[`${year}_M${month}`] = v.value;
        });

        const sortedWeeklyValues = Object.entries(weeklyValues)
          .sort((a, b) => (a[0] > b[0] ? 1 : -1))
          .reverse();

        // Convertir monthlyValues en un tableau d'entrées, puis trier et inverser
        const sortedMonthlyValues = Object.entries(monthlyValues)
          .sort((a, b) => (a[0] > b[0] ? 1 : -1))
          .reverse();

        let previousWeekValue = null;
        for (const [week, value] of sortedWeeklyValues) {
          if (previousWeekValue !== null) {
            const rendement_semaine = (value - previousWeekValue) / previousWeekValue;
            await rendement.create({
              date: week,
              fond_id: fundId,
              lastvl:value,
              rendement_semaine,
              rendement_mensuel: null
            });
          }
          previousWeekValue = value;
        }

        let previousMonthValue = null;
        for (const [month, value] of sortedMonthlyValues) {
          if (previousMonthValue !== null) {
            const rendement_mensuel = (value - previousMonthValue) / previousMonthValue;
            await rendement.create({
              date: month,
              fond_id: fundId,
              lastvl:value,
              rendement_semaine: null,
              rendement_mensuel
            });
          }
          previousMonthValue = value;
        }
      }

      res.status(200).send('Rendements calculés et enregistrés avec succès.');
    } catch (error) {
      console.error(error);
      res.status(500).send('Erreur lors du calcul des rendements.');
    }
  });
  const calculateDailyWeeklyReturns = (data) => {
    return data.map((entry, index) => {
      const currentDate = moment(entry.date);
      const weekAgoDate = currentDate.subtract(7, 'days').format('YYYY-MM-DD');
      const weekAgoEntry = data.find(row => moment(row.date).format('YYYY-MM-DD') === weekAgoDate);

      if (weekAgoEntry) {
        const weeklyReturn = (entry.value - weekAgoEntry.value) / weekAgoEntry.value;
        return {
          ...entry,
          weeklyReturn,
        };
      } else {
        return {
          ...entry,
          weeklyReturn: null, // Si pas de données disponibles pour la semaine précédente
        };
      }
    }).filter(entry => entry.weeklyReturn !== null);
  };

  // Fonction pour extraire uniquement la troisième variable de chaque sous-liste
  function extractLastVariable(data) {
    const result = [];
    for (const sublist of data) {
      if (sublist.length > 0) {
        const lastVariable = sublist[sublist.length - 1][2]; // La troisième valeur de chaque sous-liste
        result.push(lastVariable);
      }
    }
    return result;
  }
  function calculateInvestmentAmounts(weights, totalInvestment) {
    const investmentAmounts = {};
    for (const [asset, weight] of Object.entries(weights)) {
      investmentAmounts[asset] = weight * totalInvestment;
    }
    return investmentAmounts;
  }

  // Fonction pour trouver les dates communes parmi plusieurs ensembles de données
  function findCommonDates(dataSets) {
    const dateSets = dataSets.map(data => new Set(data.map(row => moment(row.date).format('YYYY-MM-DD'))));
    let commonDates = [...dateSets[0]];
    for (let i = 1; i < dateSets.length; i++) {
      commonDates = commonDates.filter(date => dateSets[i].has(date));
    }
    return commonDates;
  }
  function convertDateFormat(dateString) {
    // Define an array to map month abbreviations to month numbers
    const months = {
      Jan: '01',
      Feb: '02',
      Mar: '03',
      Apr: '04',
      May: '05',
      Jun: '06',
      Jul: '07',
      Aug: '08',
      Sep: '09',
      Oct: '10',
      Nov: '11',
      Dec: '12',
    };

    // Split the input date string by hyphen and space
    const dateParts = dateString.split('-');

    // Extract day, month, and year from the dateParts array
    const day = dateParts[0];
    const monthAbbreviation = dateParts[1];
    const year = dateParts[2];

    // Convert the month abbreviation to a numeric month
    const month = months[monthAbbreviation];

    // Create the "yyyy-mm-dd" format date string
    const convertedDate = `${year}-${month}-${day}`;

    return convertedDate;
  }

  app.post('/api/postsimulation', async (req, res) => {
    try {
      const {
        nom,
        description,
        userid

        // Ajoutez d'autres champs ici
      } = req.body;


      simulation.create({
        nom: nom,
        description: description,
        user_id: userid

      })



      // Répondez avec un message de succès ou autre réponse appropriée
      res.status(200).json({ message: 'Données insérées avec succès' });
    } catch (error) {
      // Gérez les erreurs ici
      console.error('Erreur lors de l\'insertion en base de données :', error);
      res.status(500).json({ message: 'Erreur lors de l\'insertion en base de données' });
    }
  });
  app.get('/api/getsimulationbyuser/:id', async (req, res) => {
    simulation.findAll({
      where: {
        user_id: req.params.id

      },
      order: [
        ['id', 'ASC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const simulations = response.map(data => ({
          id: data.id,
          nom: data.nom, // Remplacez avec la propriété correcte de l'objet
          description: data.description


        }));
        res.json({
          code: 200,
          data: {
            simulations,
            //  valorisation

          }
        })

      })
  })

  app.get('/api/getportefeuillebysimulation/:id', async (req, res) => {
    simulationportefeuille.findAll({
      where: {
        simulation_id: req.params.id

      },
      order: [
        ['id', 'ASC']
      ]
    })
      .then(response => {
        //const funds = response.map((data) => data.id);

        const simulations = response.map(data => ({
          nom: data.nom, // Remplacez avec la propriété correcte de l'objet
          fond_ids: data.fond_ids,
          poids: data.poids,
          portefeuille_id: data.portefeuille_id,


        }));
        res.json({
          code: 200,
          data: {
            simulations,
            //  valorisation

          }
        })

      })
  })


  //All sur le robot 
  async function getFundsWithAllDates() {
    const dateCount = await date_valorisation.count();
    const fundsWithAllDates = await fond.findAll({
      include: [{
        model: vl,
        required: true,
        attributes: [],
        where: {
          date: {
            [Sequelize.Op.in]: Sequelize.literal(`(SELECT date FROM date_valorisations)`)
          }
        }
      }],
      group: ['fond_investissements.id'],
      having: Sequelize.literal(`COUNT(DISTINCT valorisations.date) = ${dateCount}`)
    });
    return fundsWithAllDates;
  }

  async function calculateDailyReturns(fundId) {
    const vlData = await vl.findAll({
      where: { fund_id: fundId , date: {
        [Op.between]: ['2023-01-01', '2023-12-31']
      }},
      order: [['date', 'DESC']],
      attributes: ['date', 'value']
    });
  
    const dailyReturns = vlData.map((vl, index) => {
      if (index === 0) return null; // Pas de rendement pour le premier jour
      const previousValue = vlData[index - 1].value;
      const currentValue = vl.value;
      const dailyReturn = (currentValue - previousValue) / previousValue;
      return dailyReturn;
    }).filter(rendement => rendement !== null);
  
    return dailyReturns;
  }

  function calculateSRRI(volatilite) {
    volatilite=parseFloat(volatilite)
    if (volatilite < 0.5) {
      return 1; // Niveau 1 de SRRI
    } else if (volatilite >= 0.5 && volatilite < 2) {
      return 2; // Niveau 2 de SRRI
    } else if (volatilite >= 2 && volatilite < 5) {
      return 3; // Niveau 3 de SRRI
    } else if (volatilite >= 5 && volatilite < 10) {
      return 4; // Niveau 4 de SRRI
    } else if (volatilite >= 10 && volatilite < 15) {
      return 5; // Niveau 5 de SRRI
    } else if (volatilite >= 15 && volatilite < 25) {
      return 6; // Niveau 6 de SRRI
    } else if (volatilite >= 25) {
      return 7; // Niveau 7 de SRRI
    } else {
      return null; // Cas de valeur invalide ou non spécifiée
    }
  }

  // Fonction pour compiler les données de fond
  async function compileFundData(funds) {
    const fundData = [];
  
    for (const fund of funds) {
      try {

      //  const dailyReturns = await calculateDailyReturns(fund.id);
        // Récupérer les rendements journaliers depuis la base de données
        const dailyReturns = await rendement.findAll({
          where: { 
            fond_id: fund.id,
            date: {
              [Op.between]: ['2023-01-01', '2023-12-31']
            }
          },
          order: [['date', 'ASC']],
          attributes: ['date', 'rendement_jour']
        });
        const performance = await performences.findOne({
          where: { fond_id: fund.id },
          order: [['date', 'DESC']],
        });
  
        let srriLevel;
        if (performance && performance.volatility3an !== null && performance.volatility3an !== undefined) {
          srriLevel = calculateSRRI(performance.volatility3an);
        } else {
          srriLevel = 0;
        }
  
        const performancess = performance || {}; // Utilise un objet vide comme valeur par défaut
  
        fundData.push({
          Date: '2023-01-01', // Remplacez par la date actuelle ou la date de votre choix
          Rendement_jour: dailyReturns,
          Nom_du_fonds: fund.nom_fond,
          Id_du_fonds: fund.id,
          Categorie_global_fundafrica: fund.categorie_globale,
          Categorie_local_fundafrica: fund.categorie_local,
          Categorie_sous_regional_fundafrica: fund.categorie_regionale,
          Indice_de_reference_local_fundafrica: fund.indice_de_reference_local_fundafrica,
          SRRI: srriLevel,
          Pays: fund.pays,
          Devise: fund.dev_libelle,
          Performances_2023: performancess.perf1an ?? null,
          Performances_2022: performancess.perf3an ?? null,
          Performance_YTD: performancess.ytd ?? null,
          Date_derniere_VL: '2024-06-06'
        });
      } catch (error) {
        console.error(`Error processing fund ID ${fund.id}:`, error);
        // Vous pouvez choisir de continuer ou d'arrêter selon l'erreur
      }
    }
  
    return fundData;
  }
  
  // Route GET pour récupérer les données de fond
app.get('/api/funds', async (req, res) => {
  try {
    const fundsWithAllDates = await getFundsWithAllDates();
    const fundData = await compileFundData(fundsWithAllDates);
    res.json(fundData);
  } catch (error) {
    console.error('Erreur lors de la récupération des données de fonds:', error);
    res.status(500).json({ error: 'Une erreur est survenue lors de la récupération des données de fonds.' });
  }
});

app.get('/api/rendementjour/fonds/2023', async (req, res) => {
  try {
      // Récupérer toutes les dates de valorisation pour l'année 2023
      const datesValorisation = await date_valorisation.findAll({
          attributes: ['date'],
          where: {
              date: {
                  [Op.between]: ['2023-01-01', '2023-12-31']
              }
          }
      });

      const datesArray = datesValorisation.map(d => d.date); // Convertir en tableau de dates

      // Récupérer les fonds ayant des rendements pour les dates de valorisation
      const fonds = await fond.findAll({
          include: [{
              model: rendement,
              required: true,
              where: {
                  date: {
                      [Op.in]: datesArray // Filtrer par les dates de valorisation
                  }
              }
          }]
      });

      const fund_data = [];

      for (const fund of fonds) {
          // Récupérer les rendements journaliers pour chaque fonds
          const dailyReturns = await rendement.findAll({
              where: {
                  fond_id: fund.id,
                  date: {
                      [Op.in]: datesArray // Limiter aux dates de valorisation
                  }
              },
              order: [['date', 'ASC']]
          });

          // Vérifier si le fonds a 249 rendements
          if (dailyReturns.length === 248) {
              const performance = await performences.findOne({
                  where: { fond_id: fund.id },
              });

              const srriLevel = performance && performance.volatility3an ? calculateSRRI(performance.volatility3an) : 0;

              dailyReturns.forEach(returnEntry => {
                  fund_data.push({
                      Date: returnEntry.date,
                      "Performance journalière": returnEntry.rendement_jour,
                      "Nom du fonds": fund.nom_fond,
                      "Id du fonds": fund.id,
                      "Catégorie global fundafrica": fund.categorie_globale,
                      "Catégorie local fundafrica": fund.categorie_local,
                      "Catégorie sous régional fundafrica": fund.categorie_regionale,
                      "Indice de référence local fundafrica": fund.indice_de_reference_local_fundafrica,
                      SRRI: srriLevel,
                      Pays: fund.pays,
                      Devise: fund.dev_libelle,
                      "Performances 2023": performance ? performance.perf1an : null,
                      "Performances 2022": performance ? performance.perf3an : null,
                      "Performance YTD": performance ? performance.ytd : null,
                      "Date dernière VL": '2023-12-31' // Remplacez par la date réelle si nécessaire
                  });
              });
          }
      }

      res.json({ fund_data });
  } catch (error) {
      console.error('Erreur lors de la récupération des rendements des fonds:', error);
      res.status(500).json({ error: 'Une erreur est survenue lors de la récupération des rendements des fonds.' });
  }
});


//Gestion des api key
function generateApiKey() {
  const apiKey = crypto.randomBytes(20).toString('hex');
  const renewalToken = crypto.randomBytes(20).toString('hex');
  return { apiKey, renewalToken };
}
// Middleware pour vérifier la clé API
async function checkApiKey(req, res, next) {
  const apiKey = req.header('x-api-key');
  if (!apiKey) {
      return res.status(403).json({ message: "Clé API manquante" });
  }

  try {
      const apiKeyInfo = await apikeys.findOne({ where: { api_key: apiKey } });
      
      if (!apiKeyInfo) {
          return res.status(403).json({ message: "Clé API invalide" });
      }

      const now = moment();
      // Vérifier si la clé a expiré
      if (moment(apiKeyInfo.expires_at).isBefore(now)) {
          return res.status(403).json({ message: "Clé API expirée" });
      }

      // Vérifier la limite d'appels
      if (apiKeyInfo.calls_made >= apiKeyInfo.rate_limit) {
          return res.status(429).json({ message: "Limite d'appels atteinte" });
      }

      // Mettre à jour le nombre d'appels
      await apikeys.update(
          { calls_made: apiKeyInfo.calls_made + 1 },
          { where: { api_key: apiKey } }
      );
      next();
  } catch (error) {
      return res.status(500).json({ message: "Erreur serveur" });
  }
}

// Route pour générer une clé API pour un utilisateur avec expiration et limites
app.post('/api/generate-api-key', async (req, res) => {
  const { user_id, duration_in_days, rate_limit } = req.body;

  if (!user_id || !duration_in_days || !rate_limit) {
      return res.status(400).json({ message: "Paramètres manquants" });
  }

  const { apiKey, renewalToken } = generateApiKey();
  const expiresAt = moment().add(duration_in_days, 'days').toDate(); // Utilisez toDate() pour obtenir un objet Date

  try {
      // Stocker la clé dans la base de données
      const newApiKey = await apikeys.create({
          user_id,
          api_key: apiKey,
          expires_at: expiresAt,
          rate_limit,
          renewal_token: renewalToken
      });

      res.status(201).json({
        code:200,
          message: "Clé API générée avec succès",
          apiKey: newApiKey.api_key,
          expires_at: newApiKey.expires_at,
          renewal_token: newApiKey.renewal_token
      });
  } catch (error) {
      return res.status(500).json({ message: "Erreur lors de la génération de la clé API" });
  }
});

// Route pour renouveler une clé API expirée
app.post('/api/renew-api-key', async (req, res) => {
  const { api_key, renewal_token, duration_in_days } = req.body;

  if (!api_key || !renewal_token || !duration_in_days) {
      return res.status(400).json({ message: "Paramètres manquants" });
  }

  try {
      const apiKeyInfo = await apikeys.findOne({
          where: { api_key, renewal_token }
      });

      if (!apiKeyInfo) {
          return res.status(403).json({ message: "Token de renouvellement ou clé API invalide" });
      }

      const expiresAt = moment().add(duration_in_days, 'days').toDate();

      // Mettre à jour la date d'expiration et réinitialiser le nombre d'appels
      await apikeys.update(
          { expires_at: expiresAt, calls_made: 0 },
          { where: { api_key } }
      );

      res.json({
          message: "Clé API renouvelée avec succès",
          new_expires_at: expiresAt
      });
  } catch (error) {
      return res.status(500).json({ message: "Erreur lors du renouvellement de la clé API" });
  }
});

// Route protégée par la clé API
app.get('/api/resource', checkApiKey, (req, res) => {
  res.json({ message: "Accès à la ressource protégée !" });
});

// Route pour récupérer toutes les clés API
app.get('/api/api-keys', async (req, res) => {
  try {
      const apiKeys = await apikeys.findAll();

      const apiKeysWithRenewal = apiKeys.map(key => ({
          api_key: key.api_key,
          user_id: key.user_id,
          expires_at: key.expires_at,
          rate_limit: key.rate_limit,
          calls_made: key.calls_made,
          renewal_token:key.renewal_token,
          is_expired: moment(key.expires_at).isBefore(moment()) // Vérifie si la clé a expiré
      }));

      res.json(apiKeysWithRenewal);
  } catch (error) {
      return res.status(500).json({ message: "Erreur lors de la récupération des clés API" });
  }
});


}